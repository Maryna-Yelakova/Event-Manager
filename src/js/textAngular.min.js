!function(a,b){"function"==typeof define&&define.amd?
// AMD. Register as an anonymous module unless amdModuleId is set
define("textAngular",["rangy","rangy/lib/rangy-selectionsaverestore"],function(c,d){return a["textAngular.name"]=b(c,d)}):"object"==typeof exports?
// Node. Does not work with strict CommonJS, but
// only CommonJS-like environments that support module.exports,
// like Node.
module.exports=b(require("rangy"),require("rangy/lib/rangy-selectionsaverestore")):a.textAngular=b(rangy)}(this,function(a){
// tests against the current jqLite/jquery implementation if this can be an element
function b(a){try{return 0!==angular.element(a).length}catch(a){return!1}}/*
	A tool definition is an object with the following key/value parameters:
		action: [function(deferred, restoreSelection)]
				a function that is executed on clicking on the button - this will allways be executed using ng-click and will
				overwrite any ng-click value in the display attribute.
				The function is passed a deferred object ($q.defer()), if this is wanted to be used `return false;` from the action and
				manually call `deferred.resolve();` elsewhere to notify the editor that the action has finished.
				restoreSelection is only defined if the rangy library is included and it can be called as `restoreSelection()` to restore the users
				selection in the WYSIWYG editor.
		display: [string]?
				Optional, an HTML element to be displayed as the button. The `scope` of the button is the tool definition object with some additional functions
				If set this will cause buttontext and iconclass to be ignored
		class: [string]?
				Optional, if set will override the taOptions.classes.toolbarButton class.
		buttontext: [string]?
				if this is defined it will replace the contents of the element contained in the `display` element
		iconclass: [string]?
				if this is defined an icon (<i>) will be appended to the `display` element with this string as it's class
		tooltiptext: [string]?
				Optional, a plain text description of the action, used for the title attribute of the action button in the toolbar by default.
		activestate: [function(commonElement)]?
				this function is called on every caret movement, if it returns true then the class taOptions.classes.toolbarButtonActive
				will be applied to the `display` element, else the class will be removed
		disabled: [function()]?
				if this function returns true then the tool will have the class taOptions.classes.disabled applied to it, else it will be removed
	Other functions available on the scope are:
		name: [string]
				the name of the tool, this is the first parameter passed into taRegisterTool
		isDisabled: [function()]
				returns true if the tool is disabled, false if it isn't
		displayActiveToolClass: [function(boolean)]
				returns true if the tool is 'active' in the currently focussed toolbar
		onElementSelect: [Object]
				This object contains the following key/value pairs and is used to trigger the ta-element-select event
				element: [String]
					an element name, will only trigger the onElementSelect action if the tagName of the element matches this string
				filter: [function(element)]?
					an optional filter that returns a boolean, if true it will trigger the onElementSelect.
				action: [function(event, element, editorScope)]
					the action that should be executed if the onElementSelect function runs
*/
// name and toolDefinition to add into the tools available to be added on the toolbar
function c(a,c){if(!a||""===a||e.hasOwnProperty(a))throw"textAngular Error: A unique name is required for a Tool Definition";if(c.display&&(""===c.display||!b(c.display))||!c.display&&!c.buttontext&&!c.iconclass)throw'textAngular Error: Tool Definition for "'+a+'" does not have a valid display/iconclass/buttontext value';e[a]=c}
// usage is:
// var t0 = performance.now();
// doSomething();
// var t1 = performance.now();
// console.log('Took', (t1 - t0).toFixed(4), 'milliseconds to do something!');
//
// turn html into pure text that shows visiblity
function d(a){var b=document.createElement("DIV");b.innerHTML=a;var c=b.textContent||b.innerText||"";// zero width space
return c.replace("â€‹",""),c=c.trim()}
// setup the global contstant functions for setting up the toolbar
// all tool definitions
var e={};angular.module("textAngularSetup",[]).constant("taRegisterTool",c).value("taTools",e).value("taOptions",{
//////////////////////////////////////////////////////////////////////////////////////
// forceTextAngularSanitize
// set false to allow the textAngular-sanitize provider to be replaced
// with angular-sanitize or a custom provider.
forceTextAngularSanitize:!0,
///////////////////////////////////////////////////////////////////////////////////////
// keyMappings
// allow customizable keyMappings for specialized key boards or languages
//
// keyMappings provides key mappings that are attached to a given commandKeyCode.
// To modify a specific keyboard binding, simply provide function which returns true
// for the event you wish to map to.
// Or to disable a specific keyboard binding, provide a function which returns false.
// Note: 'RedoKey' and 'UndoKey' are internally bound to the redo and undo functionality.
// At present, the following commandKeyCodes are in use:
// 98, 'TabKey', 'ShiftTabKey', 105, 117, 'UndoKey', 'RedoKey'
//
// To map to an new commandKeyCode, add a new key mapping such as:
// {commandKeyCode: 'CustomKey', testForKey: function (event) {
//  if (event.keyCode=57 && event.ctrlKey && !event.shiftKey && !event.altKey) return true;
// } }
// to the keyMappings. This example maps ctrl+9 to 'CustomKey'
// Then where taRegisterTool(...) is called, add a commandKeyCode: 'CustomKey' and your
// tool will be bound to ctrl+9.
//
// To disble one of the already bound commandKeyCodes such as 'RedoKey' or 'UndoKey' add:
// {commandKeyCode: 'RedoKey', testForKey: function (event) { return false; } },
// {commandKeyCode: 'UndoKey', testForKey: function (event) { return false; } },
// to disable them.
//
keyMappings:[],toolbar:[["h1","h2","h3","h4","h5","h6","p","pre","quote"],["bold","italics","underline","strikeThrough","ul","ol","redo","undo","clear"],["justifyLeft","justifyCenter","justifyRight","justifyFull","indent","outdent"],["html","insertImage","insertLink","insertVideo","wordcount","charcount"]],classes:{focussed:"focussed",toolbar:"btn-toolbar",toolbarGroup:"btn-group",toolbarButton:"btn btn-default",toolbarButtonActive:"active",disabled:"disabled",textEditor:"form-control",htmlEditor:"form-control"},defaultTagAttributes:{a:{target:""}},setup:{
// wysiwyg mode
textEditorSetup:function(a){},
// raw html
htmlEditorSetup:function(a){}},defaultFileDropHandler:/* istanbul ignore next: untestable image processing */
function(a,b){var c=new FileReader;return"image"===a.type.substring(0,5)&&(c.onload=function(){""!==c.result&&b("insertImage",c.result,!0)},c.readAsDataURL(a),!0)}}).value("taSelectableElements",["a","img"]).value("taCustomRenderers",[{
// Parse back out: '<div class="ta-insert-video" ta-insert-video src="' + urlLink + '" allowfullscreen="true" width="300" frameborder="0" height="250"></div>'
// To correct video element. For now only support youtube
selector:"img",customAttribute:"ta-insert-video",renderLogic:function(a){var b=angular.element("<iframe></iframe>"),c=a.prop("attributes");
// loop through element attributes and apply them on iframe
angular.forEach(c,function(a){b.attr(a.name,a.value)}),b.attr("src",b.attr("ta-insert-video")),a.replaceWith(b)}}]).value("taTranslations",{
// moved to sub-elements
//toggleHTML: "Toggle HTML",
//insertImage: "Please enter a image URL to insert",
//insertLink: "Please enter a URL to insert",
//insertVideo: "Please enter a youtube URL to embed",
html:{tooltip:"Toggle html / Rich Text"},
// tooltip for heading - might be worth splitting
heading:{tooltip:"Heading "},p:{tooltip:"Paragraph"},pre:{tooltip:"Preformatted text"},ul:{tooltip:"Unordered List"},ol:{tooltip:"Ordered List"},quote:{tooltip:"Quote/unquote selection or paragraph"},undo:{tooltip:"Undo"},redo:{tooltip:"Redo"},bold:{tooltip:"Bold"},italic:{tooltip:"Italic"},underline:{tooltip:"Underline"},strikeThrough:{tooltip:"Strikethrough"},justifyLeft:{tooltip:"Align text left"},justifyRight:{tooltip:"Align text right"},justifyFull:{tooltip:"Justify text"},justifyCenter:{tooltip:"Center"},indent:{tooltip:"Increase indent"},outdent:{tooltip:"Decrease indent"},clear:{tooltip:"Clear formatting"},insertImage:{dialogPrompt:"Please enter an image URL to insert",tooltip:"Insert image",hotkey:"the - possibly language dependent hotkey ... for some future implementation"},insertVideo:{tooltip:"Insert video",dialogPrompt:"Please enter a youtube URL to embed"},insertLink:{tooltip:"Insert / edit link",dialogPrompt:"Please enter a URL to insert"},editLink:{reLinkButton:{tooltip:"Relink"},unLinkButton:{tooltip:"Unlink"},targetToggle:{buttontext:"Open in New Window"}},wordcount:{tooltip:"Display words Count"},charcount:{tooltip:"Display characters Count"}}).factory("taToolFunctions",["$window","taTranslations",function(a,b){return{imgOnSelectAction:function(a,b,c){
// setup the editor toolbar
// Credit to the work at http://hackerwins.github.io/summernote/ for this editbar logic/display
var d=function(){c.updateTaBindtaTextElement(),c.hidePopover()};a.preventDefault(),c.displayElements.popover.css("width","375px");var e=c.displayElements.popoverContainer;e.empty();var f=angular.element('<div class="btn-group" style="padding-right: 6px;">'),g=angular.element('<button type="button" class="btn btn-default btn-sm btn-small" unselectable="on" tabindex="-1">100% </button>');g.on("click",function(a){a.preventDefault(),b.css({width:"100%",height:""}),d()});var h=angular.element('<button type="button" class="btn btn-default btn-sm btn-small" unselectable="on" tabindex="-1">50% </button>');h.on("click",function(a){a.preventDefault(),b.css({width:"50%",height:""}),d()});var i=angular.element('<button type="button" class="btn btn-default btn-sm btn-small" unselectable="on" tabindex="-1">25% </button>');i.on("click",function(a){a.preventDefault(),b.css({width:"25%",height:""}),d()});var j=angular.element('<button type="button" class="btn btn-default btn-sm btn-small" unselectable="on" tabindex="-1">Reset</button>');j.on("click",function(a){a.preventDefault(),b.css({width:"",height:""}),d()}),f.append(g),f.append(h),f.append(i),f.append(j),e.append(f),f=angular.element('<div class="btn-group" style="padding-right: 6px;">');var k=angular.element('<button type="button" class="btn btn-default btn-sm btn-small" unselectable="on" tabindex="-1"><i class="fa fa-align-left"></i></button>');k.on("click",function(a){a.preventDefault(),
// webkit
b.css("float","left"),
// firefox
b.css("cssFloat","left"),
// IE < 8
b.css("styleFloat","left"),d()});var l=angular.element('<button type="button" class="btn btn-default btn-sm btn-small" unselectable="on" tabindex="-1"><i class="fa fa-align-right"></i></button>');l.on("click",function(a){a.preventDefault(),
// webkit
b.css("float","right"),
// firefox
b.css("cssFloat","right"),
// IE < 8
b.css("styleFloat","right"),d()});var m=angular.element('<button type="button" class="btn btn-default btn-sm btn-small" unselectable="on" tabindex="-1"><i class="fa fa-align-justify"></i></button>');m.on("click",function(a){a.preventDefault(),
// webkit
b.css("float",""),
// firefox
b.css("cssFloat",""),
// IE < 8
b.css("styleFloat",""),d()}),f.append(k),f.append(m),f.append(l),e.append(f),f=angular.element('<div class="btn-group">');var n=angular.element('<button type="button" class="btn btn-default btn-sm btn-small" unselectable="on" tabindex="-1"><i class="fa fa-trash-o"></i></button>');n.on("click",function(a){a.preventDefault(),b.remove(),d()}),f.append(n),e.append(f),c.showPopover(b),c.showResizeOverlay(b)},aOnSelectAction:function(c,d,e){
// setup the editor toolbar
// Credit to the work at http://hackerwins.github.io/summernote/ for this editbar logic
c.preventDefault(),e.displayElements.popover.css("width","436px");var f=e.displayElements.popoverContainer;f.empty(),f.css("line-height","28px");var g=angular.element('<a href="'+d.attr("href")+'" target="_blank">'+d.attr("href")+"</a>");g.css({display:"inline-block","max-width":"200px",overflow:"hidden","text-overflow":"ellipsis","white-space":"nowrap","vertical-align":"middle"}),f.append(g);var h=angular.element('<div class="btn-group pull-right">'),i=angular.element('<button type="button" class="btn btn-default btn-sm btn-small" tabindex="-1" unselectable="on" title="'+b.editLink.reLinkButton.tooltip+'"><i class="fa fa-edit icon-edit"></i></button>');i.on("click",function(c){c.preventDefault();var f=a.prompt(b.insertLink.dialogPrompt,d.attr("href"));f&&""!==f&&"http://"!==f&&(d.attr("href",f),e.updateTaBindtaTextElement()),e.hidePopover()}),h.append(i);var j=angular.element('<button type="button" class="btn btn-default btn-sm btn-small" tabindex="-1" unselectable="on" title="'+b.editLink.unLinkButton.tooltip+'"><i class="fa fa-unlink icon-unlink"></i></button>');
// directly before this click event is fired a digest is fired off whereby the reference to $element is orphaned off
j.on("click",function(a){a.preventDefault(),d.replaceWith(d.contents()),e.updateTaBindtaTextElement(),e.hidePopover()}),h.append(j);var k=angular.element('<button type="button" class="btn btn-default btn-sm btn-small" tabindex="-1" unselectable="on">'+b.editLink.targetToggle.buttontext+"</button>");"_blank"===d.attr("target")&&k.addClass("active"),k.on("click",function(a){a.preventDefault(),d.attr("target","_blank"===d.attr("target")?"":"_blank"),k.toggleClass("active"),e.updateTaBindtaTextElement()}),h.append(k),f.append(h),e.showPopover(d)},extractYoutubeVideoId:function(a){var b=/(?:youtube(?:-nocookie)?\.com\/(?:[^\/\n\s]+\/\S+\/|(?:v|e(?:mbed)?)\/|\S*?[?&]v=)|youtu\.be\/)([a-zA-Z0-9_-]{11})/i,c=a.match(b);return c&&c[1]||null}}}]).run(["taRegisterTool","$window","taTranslations","taSelection","taToolFunctions","$sanitize","taOptions","$log",function(a,b,c,d,e,f,g,h){
// test for the version of $sanitize that is in use
// You can disable this check by setting taOptions.textAngularSanitize == false
var i={};/* istanbul ignore next, throws error */
if(f("",i),g.forceTextAngularSanitize===!0&&"taSanitize"!==i.version)throw angular.$$minErr("textAngular")("textAngularSetup","The textAngular-sanitize provider has been replaced by another -- have you included angular-sanitize by mistake?");a("html",{iconclass:"fa fa-code",tooltiptext:c.html.tooltip,action:function(){this.$editor().switchView()},activeState:function(){return this.$editor().showHtml}});
// add the Header tools
// convenience functions so that the loop works correctly
var j=function(a){return function(){return this.$editor().queryFormatBlockState(a)}},k=function(){return this.$editor().wrapSelection("formatBlock","<"+this.name.toUpperCase()+">")};angular.forEach(["h1","h2","h3","h4","h5","h6"],function(b){a(b.toLowerCase(),{buttontext:b.toUpperCase(),tooltiptext:c.heading.tooltip+b.charAt(1),action:k,activeState:j(b.toLowerCase())})}),a("p",{buttontext:"P",tooltiptext:c.p.tooltip,action:function(){return this.$editor().wrapSelection("formatBlock","<P>")},activeState:function(){return this.$editor().queryFormatBlockState("p")}}),
// key: pre -> taTranslations[key].tooltip, taTranslations[key].buttontext
a("pre",{buttontext:"pre",tooltiptext:c.pre.tooltip,action:function(){return this.$editor().wrapSelection("formatBlock","<PRE>")},activeState:function(){return this.$editor().queryFormatBlockState("pre")}}),a("ul",{iconclass:"fa fa-list-ul",tooltiptext:c.ul.tooltip,action:function(){return this.$editor().wrapSelection("insertUnorderedList",null)},activeState:function(){return this.$editor().queryCommandState("insertUnorderedList")}}),a("ol",{iconclass:"fa fa-list-ol",tooltiptext:c.ol.tooltip,action:function(){return this.$editor().wrapSelection("insertOrderedList",null)},activeState:function(){return this.$editor().queryCommandState("insertOrderedList")}}),a("quote",{iconclass:"fa fa-quote-right",tooltiptext:c.quote.tooltip,action:function(){return this.$editor().wrapSelection("formatBlock","<BLOCKQUOTE>")},activeState:function(){return this.$editor().queryFormatBlockState("blockquote")}}),a("undo",{iconclass:"fa fa-undo",tooltiptext:c.undo.tooltip,action:function(){return this.$editor().wrapSelection("undo",null)}}),a("redo",{iconclass:"fa fa-repeat",tooltiptext:c.redo.tooltip,action:function(){return this.$editor().wrapSelection("redo",null)}}),a("bold",{iconclass:"fa fa-bold",tooltiptext:c.bold.tooltip,action:function(){return this.$editor().wrapSelection("bold",null)},activeState:function(){return this.$editor().queryCommandState("bold")},commandKeyCode:98}),a("justifyLeft",{iconclass:"fa fa-align-left",tooltiptext:c.justifyLeft.tooltip,action:function(){return this.$editor().wrapSelection("justifyLeft",null)},activeState:function(a){/* istanbul ignore next: */
if(a&&"#document"===a.nodeName)return!1;var b=!1;return a&&(b="left"===a.css("text-align")||"left"===a.attr("align")||"right"!==a.css("text-align")&&"center"!==a.css("text-align")&&"justify"!==a.css("text-align")&&!this.$editor().queryCommandState("justifyRight")&&!this.$editor().queryCommandState("justifyCenter")&&!this.$editor().queryCommandState("justifyFull")),b=b||this.$editor().queryCommandState("justifyLeft")}}),a("justifyRight",{iconclass:"fa fa-align-right",tooltiptext:c.justifyRight.tooltip,action:function(){return this.$editor().wrapSelection("justifyRight",null)},activeState:function(a){/* istanbul ignore next: */
if(a&&"#document"===a.nodeName)return!1;var b=!1;return a&&(b="right"===a.css("text-align")),b=b||this.$editor().queryCommandState("justifyRight")}}),a("justifyFull",{iconclass:"fa fa-align-justify",tooltiptext:c.justifyFull.tooltip,action:function(){return this.$editor().wrapSelection("justifyFull",null)},activeState:function(a){var b=!1;return a&&(b="justify"===a.css("text-align")),b=b||this.$editor().queryCommandState("justifyFull")}}),a("justifyCenter",{iconclass:"fa fa-align-center",tooltiptext:c.justifyCenter.tooltip,action:function(){return this.$editor().wrapSelection("justifyCenter",null)},activeState:function(a){/* istanbul ignore next: */
if(a&&"#document"===a.nodeName)return!1;var b=!1;return a&&(b="center"===a.css("text-align")),b=b||this.$editor().queryCommandState("justifyCenter")}}),a("indent",{iconclass:"fa fa-indent",tooltiptext:c.indent.tooltip,action:function(){return this.$editor().wrapSelection("indent",null)},activeState:function(){return this.$editor().queryFormatBlockState("blockquote")},commandKeyCode:"TabKey"}),a("outdent",{iconclass:"fa fa-outdent",tooltiptext:c.outdent.tooltip,action:function(){return this.$editor().wrapSelection("outdent",null)},activeState:function(){return!1},commandKeyCode:"ShiftTabKey"}),a("italics",{iconclass:"fa fa-italic",tooltiptext:c.italic.tooltip,action:function(){return this.$editor().wrapSelection("italic",null)},activeState:function(){return this.$editor().queryCommandState("italic")},commandKeyCode:105}),a("underline",{iconclass:"fa fa-underline",tooltiptext:c.underline.tooltip,action:function(){return this.$editor().wrapSelection("underline",null)},activeState:function(){return this.$editor().queryCommandState("underline")},commandKeyCode:117}),a("strikeThrough",{iconclass:"fa fa-strikethrough",tooltiptext:c.strikeThrough.tooltip,action:function(){return this.$editor().wrapSelection("strikeThrough",null)},activeState:function(){return document.queryCommandState("strikeThrough")}}),a("clear",{iconclass:"fa fa-ban",tooltiptext:c.clear.tooltip,action:function(a,b){var c;this.$editor().wrapSelection("removeFormat",null);var e=angular.element(d.getSelectionElement());c=d.getAllSelectedElements();
//$log.log('selectedElements:', selectedElements);
// remove lists
var f=function(a,b){a=angular.element(a);var c=b;return b||(c=a),angular.forEach(a.children(),function(a){if("ul"===a.tagName.toLowerCase()||"ol"===a.tagName.toLowerCase())c=f(a,c);else{var b=angular.element("<p></p>");b.html(angular.element(a).html()),c.after(b),c=b}}),a.remove(),c};angular.forEach(c,function(a){"ul"!==a.nodeName.toLowerCase()&&"ol"!==a.nodeName.toLowerCase()||
//console.log('removeListElements', element);
f(a)}),angular.forEach(e.find("ul"),f),angular.forEach(e.find("ol"),f);
// clear out all class attributes. These do not seem to be cleared via removeFormat
var g=this.$editor(),h=function(a){a=angular.element(a),/* istanbul ignore next: this is not triggered in tests any longer since we now never select the whole displayELement */
a[0]!==g.displayElements.text[0]&&a.removeAttr("class"),angular.forEach(a.children(),h)};angular.forEach(e,h),
// check if in list. If not in list then use formatBlock option
e[0]&&"li"!==e[0].tagName.toLowerCase()&&"ol"!==e[0].tagName.toLowerCase()&&"ul"!==e[0].tagName.toLowerCase()&&this.$editor().wrapSelection("formatBlock","default"),b()}});/* jshint -W099 */
/****************************
	 //  we don't use this code - since the previous way CLEAR is expected to work does not clear partially selected <li>

	 var removeListElement = function(listE){
				console.log(listE);
				var _list = listE.parentNode.childNodes;
				console.log('_list', _list);
				var _preLis = [], _postLis = [], _found = false;
				for (i = 0; i < _list.length; i++) {
					if (_list[i] === listE) {
						_found = true;
					} else if (!_found) _preLis.push(_list[i]);
					else _postLis.push(_list[i]);
				}
				var _parent = angular.element(listE.parentNode);
				var newElem = angular.element('<p></p>');
				newElem.html(angular.element(listE).html());
				if (_preLis.length === 0 || _postLis.length === 0) {
					if (_postLis.length === 0) _parent.after(newElem);
					else _parent[0].parentNode.insertBefore(newElem[0], _parent[0]);

					if (_preLis.length === 0 && _postLis.length === 0) _parent.remove();
					else angular.element(listE).remove();
				} else {
					var _firstList = angular.element('<' + _parent[0].tagName + '></' + _parent[0].tagName + '>');
					var _secondList = angular.element('<' + _parent[0].tagName + '></' + _parent[0].tagName + '>');
					for (i = 0; i < _preLis.length; i++) _firstList.append(angular.element(_preLis[i]));
					for (i = 0; i < _postLis.length; i++) _secondList.append(angular.element(_postLis[i]));
					_parent.after(_secondList);
					_parent.after(newElem);
					_parent.after(_firstList);
					_parent.remove();
				}
				taSelection.setSelectionToElementEnd(newElem[0]);
			};

	 elementsSeen = [];
	 if (selectedElements.length !==0) console.log(selectedElements);
	 angular.forEach(selectedElements, function (element) {
				if (elementsSeen.indexOf(element) !== -1 || elementsSeen.indexOf(element.parentElement) !== -1) {
					return;
				}
				elementsSeen.push(element);
				if (element.nodeName.toLowerCase() === 'li') {
					console.log('removeListElement', element);
					removeListElement(element);
				}
				else if (element.parentElement && element.parentElement.nodeName.toLowerCase() === 'li') {
					console.log('removeListElement', element.parentElement);
					elementsSeen.push(element.parentElement);
					removeListElement(element.parentElement);
				}
			});
	 **********************/
/**********************
	 if(possibleNodes[0].tagName.toLowerCase() === 'li'){
				var _list = possibleNodes[0].parentNode.childNodes;
				var _preLis = [], _postLis = [], _found = false;
				for(i = 0; i < _list.length; i++){
					if(_list[i] === possibleNodes[0]){
						_found = true;
					}else if(!_found) _preLis.push(_list[i]);
					else _postLis.push(_list[i]);
				}
				var _parent = angular.element(possibleNodes[0].parentNode);
				var newElem = angular.element('<p></p>');
				newElem.html(angular.element(possibleNodes[0]).html());
				if(_preLis.length === 0 || _postLis.length === 0){
					if(_postLis.length === 0) _parent.after(newElem);
					else _parent[0].parentNode.insertBefore(newElem[0], _parent[0]);

					if(_preLis.length === 0 && _postLis.length === 0) _parent.remove();
					else angular.element(possibleNodes[0]).remove();
				}else{
					var _firstList = angular.element('<'+_parent[0].tagName+'></'+_parent[0].tagName+'>');
					var _secondList = angular.element('<'+_parent[0].tagName+'></'+_parent[0].tagName+'>');
					for(i = 0; i < _preLis.length; i++) _firstList.append(angular.element(_preLis[i]));
					for(i = 0; i < _postLis.length; i++) _secondList.append(angular.element(_postLis[i]));
					_parent.after(_secondList);
					_parent.after(newElem);
					_parent.after(_firstList);
					_parent.remove();
				}
				taSelection.setSelectionToElementEnd(newElem[0]);
			}
	 *******************/
/* istanbul ignore next: if it's javascript don't worry - though probably should show some kind of error message */
var l=function(a){return a.toLowerCase().indexOf("javascript")!==-1};a("insertImage",{iconclass:"fa fa-picture-o",tooltiptext:c.insertImage.tooltip,action:function(){var a;if(a=b.prompt(c.insertImage.dialogPrompt,"http://"),a&&""!==a&&"http://"!==a&&!l(a)){d.getSelectionElement().tagName&&"a"===d.getSelectionElement().tagName.toLowerCase()&&
// due to differences in implementation between FireFox and Chrome, we must move the
// insertion point past the <a> element, otherwise FireFox inserts inside the <a>
// With this change, both FireFox and Chrome behave the same way!
d.setSelectionAfterElement(d.getSelectionElement());
// In the past we used the simple statement:
//return this.$editor().wrapSelection('insertImage', imageLink, true);
//
// However on Firefox only, when the content is empty this is a problem
// See Issue #1201
// Investigation reveals that Firefox only inserts a <p> only!!!!
// So now we use insertHTML here and all is fine.
// NOTE: this is what 'insertImage' is supposed to do anyway!
var e='<img src="'+a+'">';return this.$editor().wrapSelection("insertHTML",e,!0)}},onElementSelect:{element:"img",action:e.imgOnSelectAction}}),a("insertVideo",{iconclass:"fa fa-youtube-play",tooltiptext:c.insertVideo.tooltip,action:function(){var a;
// block javascript here
/* istanbul ignore else: if it's javascript don't worry - though probably should show some kind of error message */
if(a=b.prompt(c.insertVideo.dialogPrompt,"https://"),!l(a)&&a&&""!==a&&"https://"!==a&&(videoId=e.extractYoutubeVideoId(a),videoId)){
// create the embed link
var f="https://www.youtube.com/embed/"+videoId,g='<img class="ta-insert-video" src="https://img.youtube.com/vi/'+videoId+'/hqdefault.jpg" ta-insert-video="'+f+'" contenteditable="false" allowfullscreen="true" frameborder="0" />';
// insert
/* istanbul ignore next: don't know how to test this... since it needs a dialogPrompt */
// due to differences in implementation between FireFox and Chrome, we must move the
// insertion point past the <a> element, otherwise FireFox inserts inside the <a>
// With this change, both FireFox and Chrome behave the same way!
return d.getSelectionElement().tagName&&"a"===d.getSelectionElement().tagName.toLowerCase()&&d.setSelectionAfterElement(d.getSelectionElement()),this.$editor().wrapSelection("insertHTML",g,!0)}},onElementSelect:{element:"img",onlyWithAttrs:["ta-insert-video"],action:e.imgOnSelectAction}}),a("insertLink",{tooltiptext:c.insertLink.tooltip,iconclass:"fa fa-link",action:function(){var a;if(
// if this link has already been set, we need to just edit the existing link
/* istanbul ignore if: we do not test this */
a=d.getSelectionElement().tagName&&"a"===d.getSelectionElement().tagName.toLowerCase()?b.prompt(c.insertLink.dialogPrompt,d.getSelectionElement().href):b.prompt(c.insertLink.dialogPrompt,"http://"),a&&""!==a&&"http://"!==a&&!l(a))return this.$editor().wrapSelection("createLink",a,!0)},activeState:function(a){return!!a&&"A"===a[0].tagName},onElementSelect:{element:"a",action:e.aOnSelectAction}}),a("wordcount",{display:'<div id="toolbarWC" style="display:block; min-width:100px;">Words: <span ng-bind="wordcount"></span></div>',disabled:!0,wordcount:0,activeState:function(){// this fires on keyup
var a=this.$editor().displayElements.text,b=a[0].innerHTML||"",c=0;/* istanbul ignore if: will default to '' when undefined */
//Set current scope
//Set editor scope
return""!==b.replace(/\s*<[^>]*?>\s*/g,"")&&""!==b.trim()&&(c=b.replace(/<\/?(b|i|em|strong|span|u|strikethrough|a|img|small|sub|sup|label)( [^>*?])?>/gi,"").replace(/(<[^>]*?>\s*<[^>]*?>)/gi," ").replace(/(<[^>]*?>)/gi,"").replace(/\s+/gi," ").match(/\S+/g).length),this.wordcount=c,this.$editor().wordcount=c,!1}}),a("charcount",{display:'<div id="toolbarCC" style="display:block; min-width:120px;">Characters: <span ng-bind="charcount"></span></div>',disabled:!0,charcount:0,activeState:function(){// this fires on keyup
var a=this.$editor().displayElements.text,b=a[0].innerText||a[0].textContent,c=b.replace(/(\r\n|\n|\r)/gm,"").replace(/^\s+/g," ").replace(/\s+$/g," ").length;
//Set current scope
//Set editor scope
return this.charcount=c,this.$editor().charcount=c,!1}})}]);// NOTE: textAngularVersion must match the Gruntfile.js 'setVersion' task.... and have format v/d+./d+./d+
var f="v1.5.12",g={ie:function(){for(var a,b=3,c=document.createElement("div"),d=c.getElementsByTagName("i");c.innerHTML="<!--[if gt IE "+ ++b+"]><i></i><![endif]-->",d[0];);return b>4?b:a}(),webkit:/AppleWebKit\/([\d.]+)/i.test(navigator.userAgent),isFirefox:navigator.userAgent.toLowerCase().indexOf("firefox")>-1},h=h||{};/* istanbul ignore next: untestable browser check */
h.now=function(){return h.now||h.mozNow||h.msNow||h.oNow||h.webkitNow||function(){return(new Date).getTime()}}();
// Global to textAngular REGEXP vars for block and list elements.
var i=/^(address|article|aside|audio|blockquote|canvas|center|dd|div|dl|fieldset|figcaption|figure|footer|form|h1|h2|h3|h4|h5|h6|header|hgroup|hr|noscript|ol|output|p|pre|section|table|tfoot|ul|video)$/i,j=/^(ul|li|ol)$/i,k=/^(#text|span|address|article|aside|audio|blockquote|canvas|center|dd|div|dl|fieldset|figcaption|figure|footer|form|h1|h2|h3|h4|h5|h6|header|hgroup|hr|noscript|ol|output|p|pre|section|table|tfoot|ul|video|li)$/i;
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/Trim#Compatibility
/* istanbul ignore next: trim shim for older browsers */
String.prototype.trim||(String.prototype.trim=function(){return this.replace(/^\s+|\s+$/g,"")});/*
	Custom stylesheet for the placeholders rules.
	Credit to: http://davidwalsh.name/add-rules-stylesheets
*/
var l,m,n,o,p,q;/* istanbul ignore else: IE <8 test*/
if(g.ie>8||void 0===g.ie){/* istanbul ignore next: preference for stylesheet loaded externally */
for(var r=document.styleSheets,s=0;s<r.length;s++)if((0===r[s].media.length||r[s].media.mediaText.match(/(all|screen)/gi))&&r[s].href&&r[s].href.match(/textangular\.(min\.|)css/gi)){l=r[s];break}/* istanbul ignore next: preference for stylesheet loaded externally */
l||(
// this sheet is used for the placeholders later on.
l=function(){
// Create the <style> tag
var a=document.createElement("style");/* istanbul ignore else : WebKit hack :( */
// Add the <style> element to the page, add as first so the styles can be overridden by custom stylesheets
return g.webkit&&a.appendChild(document.createTextNode("")),document.getElementsByTagName("head")[0].appendChild(a),a.sheet}()),
// use as: addCSSRule("header", "float: left");
m=function(a,b){return o(l,a,b)},o=function(a,b,c){var d,e;
// return the inserted stylesheet rule
// This order is important as IE 11 has both cssRules and rules but they have different lengths - cssRules is correct, rules gives an error in IE 11
/* istanbul ignore next: browser catches */
/* istanbul ignore else: untestable IE option */
/* istanbul ignore next: browser catches */
return a.cssRules?d=Math.max(a.cssRules.length-1,0):a.rules&&(d=Math.max(a.rules.length-1,0)),a.insertRule?a.insertRule(b+"{"+c+"}",d):a.addRule(b,c,d),l.rules?e=l.rules[d]:l.cssRules&&(e=l.cssRules[d]),e},q=function(a,b){var c,d;for(c=0;c<b.length;c++)/* istanbul ignore else: check for correct rule */
if(b[c].cssText===a.cssText){d=c;break}return d},n=function(a){p(l,a)},/* istanbul ignore next: tests are browser specific */
p=function(a,b){var c=a.cssRules||a.rules;if(c&&0!==c.length){var d=q(b,c);a.removeRule?a.removeRule(d):a.deleteRule(d)}}}angular.module("textAngular.factories",[]).factory("taBrowserTag",[function(){return function(a){/* istanbul ignore next: ie specific test */
/* istanbul ignore next: ie specific test */
return a?""===a?void 0===g.ie?"div":g.ie<=8?"P":"p":g.ie<=8?a.toUpperCase():a:g.ie<=8?"P":"p"}}]).factory("taApplyCustomRenderers",["taCustomRenderers","taDOM",function(a,b){return function(c){var d=angular.element("<div></div>");return d[0].innerHTML=c,angular.forEach(a,function(a){var c=[];
// get elements based on what is defined. If both defined do secondary filter in the forEach after using selector string
a.selector&&""!==a.selector?c=d.find(a.selector):a.customAttribute&&""!==a.customAttribute&&(c=b.getByAttribute(d,a.customAttribute)),
// process elements if any found
angular.forEach(c,function(b){b=angular.element(b),a.selector&&""!==a.selector&&a.customAttribute&&""!==a.customAttribute?void 0!==b.attr(a.customAttribute)&&a.renderLogic(b):a.renderLogic(b)})}),d[0].innerHTML}}]).factory("taFixChrome",function(){
// get whaterever rubbish is inserted in chrome
// should be passed an html string, returns an html string
var a=function(a){if(!a||!angular.isString(a)||a.length<=0)return a;
// remove all the Apple-converted-space spans and replace with the content of the span
/* istanbul ignore next: apple-contereted-space span match */
for(
// grab all elements with a style attibute
var b,c,d,e,f=/<([^>\/]+?)style=("([^\"]+)"|'([^']+)')([^>]*)>/gi,g=/<span class="Apple-converted-space">([^<]+)<\/span>/gi,h="",i=0;b=g.exec(a);)d=b[1],d=d.replace(/&nbsp;/gi," "),h+=a.substring(i,b.index)+d,i=b.index+b[0].length;for(/* istanbul ignore next: apple-contereted-space span has matched */
i&&(
// modified....
h+=a.substring(i),a=h,h="",i=0);b=f.exec(a);)
// one of the quoted values ' or "
/* istanbul ignore next: quotations match */
c=b[3]||b[4],
// test for chrome inserted junk
c&&c.match(/line-height: 1.[0-9]{3,12};|color: inherit; line-height: 1.1;|color: rgb\(\d{1,3}, \d{1,3}, \d{1,3}\);|background-color: rgb\(\d{1,3}, \d{1,3}, \d{1,3}\);/i)&&(
// replace original tag with new tag
c=c.replace(/( |)font-family: inherit;|( |)line-height: 1.[0-9]{3,12};|( |)color: inherit;|( |)color: rgb\(\d{1,3}, \d{1,3}, \d{1,3}\);|( |)background-color: rgb\(\d{1,3}, \d{1,3}, \d{1,3}\);/gi,""),e="<"+b[1].trim(),c.trim().length>0&&(e+=" style="+b[2].substring(0,1)+c+b[2].substring(0,1)),e+=b[5].trim()+">",h+=a.substring(i,b.index)+e,i=b.index+b[0].length);
// only replace when something has changed, else we get focus problems on inserting lists
// only replace when something has changed, else we get focus problems on inserting lists
return h+=a.substring(i),i>0?h.replace(/<span\s?>(.*?)<\/span>(<br(\/|)>|)/gi,"$1"):a};return a}).factory("taSanitize",["$sanitize",function(a){function b(a,b){for(var c,d=0,e=0,f=/<[^>]*>/gi;c=f.exec(a);)if(e=c.index,"/"===c[0].substr(1,1)){if(0===d)break;d--}else d++;
// get the start tags reversed - this is safe as we construct the strings with no content except the tags
return b+a.substring(0,e)+angular.element(b)[0].outerHTML.substring(b.length)+a.substring(e)}function c(a){if(!a||!angular.isString(a)||a.length<=0)return a;for(var d,f,g,h,i,k,l=/<([^>\/]+?)style=("([^"]+)"|'([^']+)')([^>]*)>/gi,m="",n="",o=0;f=l.exec(a);){
// one of the quoted values ' or "
/* istanbul ignore next: quotations match */
h=f[3]||f[4];var p=new RegExp(j,"i");
// test for style values to change
if(angular.isString(h)&&p.test(h)){
// remove build tag list
i="";
// find relevand tags and build a string of them
for(
// init regex here for exec
var q=new RegExp(j,"ig");g=q.exec(h);)for(d=0;d<e.length;d++)g[2*d+2]&&(i+="<"+e[d].tag+">");
// recursively find more legacy styles in html before this tag and after the previous match (if any)
k=c(a.substring(o,f.index)),
// build up html
n+=m.length>0?b(k,m):k,
// grab the style val without the transformed values
h=h.replace(new RegExp(j,"ig"),""),
// build the html tag
n+="<"+f[1].trim(),h.length>0&&(n+=' style="'+h+'"'),n+=f[5]+">",
// update the start index to after this tag
o=f.index+f[0].length,m=i}}return n+=m.length>0?b(a.substring(o),m):a.substring(o)}function d(a){if(!a||!angular.isString(a)||a.length<=0)return a;
// match all attr tags
for(
// replace all align='...' tags with text-align attributes
var b,c=/<([^>\/]+?)align=("([^"]+)"|'([^']+)')([^>]*)>/gi,d="",e=0;b=c.exec(a);){
// add all html before this tag
d+=a.substring(e,b.index),
// record last index after this tag
e=b.index+b[0].length;
// construct tag without the align attribute
var f="<"+b[1]+b[5];
// add the style attribute
/style=("([^"]+)"|'([^']+)')/gi.test(f)?/* istanbul ignore next: quotations match */
f=f.replace(/style=("([^"]+)"|'([^']+)')/i,'style="$2$3 text-align:'+(b[3]||b[4])+';"'):/* istanbul ignore next: quotations match */
f+=' style="text-align:'+(b[3]||b[4])+';"',f+=">",
// add to html
d+=f}
// return with remaining html
return d+a.substring(e)}for(var e=[{property:"font-weight",values:["bold"],tag:"b"},{property:"font-style",values:["italic"],tag:"i"}],f=[],g=0;g<e.length;g++){for(var h="("+e[g].property+":\\s*(",i=0;i<e[g].values.length;i++)/* istanbul ignore next: not needed to be tested yet */
i>0&&(h+="|"),h+=e[g].values[i];h+=");)",f.push(h)}var j="("+f.join("|")+")",k=new RegExp(/<span id="selectionBoundary_\d+_\d+" class="rangySelectionBoundary">[^<>]+?<\/span>/gi),l=new RegExp(/<span class="rangySelectionBoundary" id="selectionBoundary_\d+_\d+">[^<>]+?<\/span>/gi),m=new RegExp(/<span id="selectionBoundary_\d+_\d+" class="rangySelectionBoundary">[^<>]+?<\/span>/gi);return function(b,e,f){
// unsafe html should NEVER built into a DOM object via angular.element. This allows XSS to be inserted and run.
if(!f)try{b=c(b)}catch(a){}
// we had an issue in the past, where we dumped a whole bunch of <span>'s into the content...
// so we remove them here
// IN A FUTURE release this can be removed after all have updated through release 1.5.9
if(
// unsafe and oldsafe should be valid HTML strings
// any exceptions (lets say, color for example) should be made here but with great care
// setup unsafe element for modification
b=d(b))try{b=b.replace(k,""),b=b.replace(l,""),b=b.replace(k,""),b=b.replace(m,"")}catch(a){}var g;try{g=a(b),
// do this afterwards, then the $sanitizer should still throw for bad markup
f&&(g=b)}catch(a){g=e||""}
// Do processing for <pre> tags, removing tabs and return carriages outside of them
var h,i=g.match(/(<pre[^>]*>.*?<\/pre[^>]*>)/gi),j=g.replace(/(&#(9|10);)*/gi,""),n=/<pre[^>]*>.*?<\/pre[^>]*>/gi,o=0,p=0;for(g="";null!==(h=n.exec(j))&&o<i.length;)g+=j.substring(p,h.index)+i[o],p=h.index+h[0].length,o++;return g+j.substring(p)}}]).factory("taToolExecuteAction",["$q","$log",function(a,b){
// this must be called on a toolScope or instance
return function(c){void 0!==c&&(this.$editor=function(){return c});var d,e=a.defer(),f=e.promise,g=this.$editor();try{d=this.action(e,g.startAction()),
// We set the .finally callback here to make sure it doesn't get executed before any other .then callback.
f.finally(function(){g.endAction.call(g)})}catch(a){b.error(a)}(d||void 0===d)&&
// if true or undefined is returned then the action has finished. Otherwise the deferred action will be resolved manually.
e.resolve()}}]),angular.module("textAngular.DOM",["textAngular.factories"]).factory("taExecCommand",["taSelection","taBrowserTag","$document",function(b,c,d){var e=function(a,c){var d,e,f=a.find("li");for(e=f.length-1;e>=0;e--)d=angular.element("<"+c+">"+f[e].innerHTML+"</"+c+">"),a.after(d);a.remove(),b.setSelectionToElementEnd(d[0])},f=function(a,d,e,f,g){var h,i,j,k,l,m=a.find("li");for(i=0;i<m.length;i++)if(m[i].outerHTML===d[0].outerHTML){
// found it...
l=i,i>0&&(j=m[i-1]),i+1<m.length&&(k=m[i+1]);break}
//console.log('listElementToSelfTag', list, listElement, selfTag, bDefault, priorElement, nextElement);
// un-list the listElement
var n="";
//console.log('$target', $target[0]);
if(f?n+="<"+g+">"+d[0].innerHTML+"</"+g+">":(n+="<"+c(e)+">",n+="<li>"+d[0].innerHTML+"</li>",n+="</"+c(e)+">"),h=angular.element(n),!j)
// this is the first the list, so we just remove it...
return d.remove(),a.after(angular.element(a[0].outerHTML)),a.after(h),a.remove(),void b.setSelectionToElementEnd(h[0]);if(k){var o=(a.parent(),""),p=a[0].nodeName.toLowerCase();for(o+="<"+p+">",i=0;i<l;i++)o+="<li>"+m[i].innerHTML+"</li>";o+="</"+p+">";var q="";for(q+="<"+p+">",i=l+1;i<m.length;i++)q+="<li>"+m[i].innerHTML+"</li>";q+="</"+p+">",
//console.log(html1, $target[0], html2);
a.after(angular.element(q)),a.after(h),a.after(angular.element(o)),a.remove(),
//console.log('parent ******XXX*****', p[0]);
b.setSelectionToElementEnd(h[0])}else
// this is the last in the list, so we just remove it..
d.remove(),a.after(h),b.setSelectionToElementEnd(h[0])},g=function(a,d,e,f,g){var h,i,j,k,l,m=a.find("li"),n=[];for(i=0;i<m.length;i++)for(j=0;j<d.length;j++)m[i].isEqualNode(d[j])&&(
// found it...
n[j]=i);n[0]>0&&(k=m[n[0]-1]),n[d.length-1]+1<m.length&&(l=m[n[d.length-1]+1]);
//console.log('listElementsToSelfTag', list, listElements, selfTag, bDefault, !priorElement, !afterElement, foundIndexes[listElements.length-1], children.length);
// un-list the listElements
var o="";if(f)for(j=0;j<d.length;j++)o+="<"+g+">"+d[j].innerHTML+"</"+g+">",d[j].remove();else{for(o+="<"+c(e)+">",j=0;j<d.length;j++)o+=d[j].outerHTML,d[j].remove();o+="</"+c(e)+">"}if(h=angular.element(o),!k)
// this is the first the list, so we just remove it...
return a.after(angular.element(a[0].outerHTML)),a.after(h),a.remove(),void b.setSelectionToElementEnd(h[0]);if(!l)
// this is the last in the list, so we just remove it..
return a.after(h),void b.setSelectionToElementEnd(h[0]);
// okay it was some where in the middle... so we need to break apart the list...
var p="",q=a[0].nodeName.toLowerCase();for(p+="<"+q+">",i=0;i<n[0];i++)p+="<li>"+m[i].innerHTML+"</li>";p+="</"+q+">";var r="";for(r+="<"+q+">",i=n[d.length-1]+1;i<m.length;i++)r+="<li>"+m[i].innerHTML+"</li>";r+="</"+q+">",a.after(angular.element(r)),a.after(h),a.after(angular.element(p)),a.remove(),
//console.log('parent ******YYY*****', list.parent()[0]);
b.setSelectionToElementEnd(h[0])},h=function(a){/(<br(|\/)>)$/i.test(a.innerHTML.trim())?b.setSelectionBeforeElement(angular.element(a).find("br")[0]):b.setSelectionToElementEnd(a)},k=function(a,b){var c=angular.element("<"+b+">"+a[0].innerHTML+"</"+b+">");a.after(c),a.remove(),h(c.find("li")[0])},l=function(a,b,d){for(var e="",f=0;f<a.length;f++)e+="<"+c("li")+">"+a[f].innerHTML+"</"+c("li")+">";var g=angular.element("<"+d+">"+e+"</"+d+">");b.after(g),b.remove(),h(g.find("li")[0])},m=function(a,b){for(var c=0;c<a.childNodes.length;c++){var d=a.childNodes[c];/* istanbul ignore next - more complex testing*/
d.tagName&&d.tagName.match(i)&&m(d,b)}/* istanbul ignore next - very rare condition that we do not test*/
if(null===a.parentNode)
// nothing left to do..
return a;var e=angular.element(b);return e[0].innerHTML=a.innerHTML,a.parentNode.insertBefore(e[0],a),a.parentNode.removeChild(a),e};return function(h,n){
// NOTE: here we are dealing with the html directly from the browser and not the html the user sees.
// IF you want to modify the html the user sees, do it when the user does a switchView
return h=c(h),function(o,p,q,r){var s,t,u,v,w,x,y,z,A=angular.element("<"+h+">");try{b.getSelection&&(z=b.getSelection()),y=b.getSelectionElement();
// special checks and fixes when we are selecting the whole container
var B,C;/* istanbul ignore next */
void 0!==y.tagName&&("div"===y.tagName.toLowerCase()&&/taTextElement.+/.test(y.id)&&z&&z.start&&1===z.start.offset&&1===z.end.offset?(
// opps we are actually selecting the whole container!
//console.log('selecting whole container!');
B=y.innerHTML,/<br>/i.test(B)&&(
// Firefox adds <br>'s and so we remove the <br>
B=B.replace(/<br>/i,"&#8203;")),/<br\/>/i.test(B)&&(
// Firefox adds <br/>'s and so we remove the <br/>
B=B.replace(/<br\/>/i,"&#8203;")),
// remove stacked up <span>'s
/<span>(<span>)+/i.test(B)&&(B=__.replace(/<span>(<span>)+/i,"<span>")),
// remove stacked up </span>'s
/<\/span>(<\/span>)+/i.test(B)&&(B=__.replace(/<\/span>(<\/span>)+/i,"</span>")),/<span><\/span>/i.test(B)&&(
// if we end up with a <span></span> here we remove it...
B=B.replace(/<span><\/span>/i,"")),
//console.log('inner whole container', selectedElement.childNodes);
C="<div>"+B+"</div>",y.innerHTML=C,
//console.log('childNodes:', selectedElement.childNodes);
b.setSelectionToElementEnd(y.childNodes[0]),y=b.getSelectionElement()):"span"===y.tagName.toLowerCase()&&z&&z.start&&1===z.start.offset&&1===z.end.offset?(
// just a span -- this is a problem...
//console.log('selecting span!');
B=y.innerHTML,/<br>/i.test(B)&&(
// Firefox adds <br>'s and so we remove the <br>
B=B.replace(/<br>/i,"&#8203;")),/<br\/>/i.test(B)&&(
// Firefox adds <br/>'s and so we remove the <br/>
B=B.replace(/<br\/>/i,"&#8203;")),
// remove stacked up <span>'s
/<span>(<span>)+/i.test(B)&&(B=__.replace(/<span>(<span>)+/i,"<span>")),
// remove stacked up </span>'s
/<\/span>(<\/span>)+/i.test(B)&&(B=__.replace(/<\/span>(<\/span>)+/i,"</span>")),/<span><\/span>/i.test(B)&&(
// if we end up with a <span></span> here we remove it...
B=B.replace(/<span><\/span>/i,"")),
//console.log('inner span', selectedElement.childNodes);
// we wrap this in a <div> because otherwise the browser get confused when we attempt to select the whole node
// and the focus is not set correctly no matter what we do
C="<div>"+B+"</div>",y.innerHTML=C,b.setSelectionToElementEnd(y.childNodes[0]),y=b.getSelectionElement()):"p"===y.tagName.toLowerCase()&&z&&z.start&&1===z.start.offset&&1===z.end.offset?(
//console.log('p special');
// we need to remove the </br> that firefox adds!
B=y.innerHTML,/<br>/i.test(B)&&(
// Firefox adds <br>'s and so we remove the <br>
B=B.replace(/<br>/i,"&#8203;"),// no space-space
y.innerHTML=B,b.setSelectionToElementEnd(y.childNodes[0]),y=b.getSelectionElement())):"li"===y.tagName.toLowerCase()&&z&&z.start&&z.start.offset===z.end.offset&&(
// we need to remove the </br> that firefox adds!
B=y.innerHTML,/<br>/i.test(B)&&(
// Firefox adds <br>'s and so we remove the <br>
B=B.replace(/<br>/i,""),// nothing
y.innerHTML=B,b.setSelectionToElementEnd(y.childNodes[0]),y=b.getSelectionElement())))}catch(a){}
//console.log('************** selectedElement:', selectedElement);
var D=angular.element(y),E=y.tagName&&y.tagName.toLowerCase()||/* istanbul ignore next: */
"";if("insertorderedlist"===o.toLowerCase()||"insertunorderedlist"===o.toLowerCase()){var F=c("insertorderedlist"===o.toLowerCase()?"ol":"ul"),G=b.getOnlySelectedElements();
//console.log('PPPPPPPPPPPPP', tagName, selfTag, selectedElements, tagName.match(BLOCKELEMENTS), $selected.hasClass('ta-bind'), $selected.parent()[0].tagName);
if(G.length>1&&("ol"===E||"ul"===E))return g(D,G,F,F===E,h);if(E===F)
// if all selected then we should remove the list
// grab all li elements and convert to taDefaultWrap tags
//console.log('tagName===selfTag');
// if all selected then we should remove the list
// grab all li elements and convert to taDefaultWrap tags
//console.log('tagName===selfTag');
return D[0].childNodes.length!==G.length&&1===G.length?(D=angular.element(G[0]),f(D.parent(),D,F,!0,h)):e(D,h);if("li"===E&&D.parent()[0].tagName.toLowerCase()===F&&1===D.parent().children().length)
// catch for the previous statement if only one li exists
return e(D.parent(),h);if("li"===E&&D.parent()[0].tagName.toLowerCase()!==F&&1===D.parent().children().length)
// catch for the previous statement if only one li exists
return k(D.parent(),F);if(E.match(i)&&!D.hasClass("ta-bind")){
// if it's one of those block elements we have to change the contents
// if it's a ol/ul we are changing from one to the other
if(G.length&&D[0].childNodes.length!==G.length&&1===G.length)
//console.log('&&&&&&&&&&&&&&& --------- &&&&&&&&&&&&&&&&', selectedElements[0], $selected[0].childNodes);
return D=angular.element(G[0]),f(D.parent(),D,F,F===E,h);if("ol"===E||"ul"===E)
// now if this is a set of selected elements... behave diferently
return k(D,F);var H=!1;return angular.forEach(D.children(),function(a){a.tagName.match(i)&&(H=!0)}),H?l(D.children(),D,F):l([angular.element("<div>"+y.innerHTML+"</div>")[0]],D,F)}if(E.match(i)){
//console.log('_nodes', _nodes, tagName);
if(
// if we get here then the contents of the ta-bind are selected
v=b.getOnlySelectedElements(),0===v.length)
// here is if there is only text in ta-bind ie <div ta-bind>test content</div>
t=angular.element("<"+F+"><li>"+y.innerHTML+"</li></"+F+">"),D.html(""),D.append(t);else{if(1===v.length&&("ol"===v[0].tagName.toLowerCase()||"ul"===v[0].tagName.toLowerCase()))return v[0].tagName.toLowerCase()===F?e(angular.element(v[0]),h):k(angular.element(v[0]),F);u="";var I=[];for(s=0;s<v.length;s++)/* istanbul ignore else: catch for real-world can't make it occur in testing */
if(3!==v[s].nodeType){var J=angular.element(v[s]);/* istanbul ignore if: browser check only, phantomjs doesn't return children nodes but chrome at least does */
if("li"===v[s].tagName.toLowerCase())continue;u+="ol"===v[s].tagName.toLowerCase()||"ul"===v[s].tagName.toLowerCase()?J[0].innerHTML:"span"!==v[s].tagName.toLowerCase()||"ol"!==v[s].childNodes[0].tagName.toLowerCase()&&"ul"!==v[s].childNodes[0].tagName.toLowerCase()?"<"+c("li")+">"+J[0].innerHTML+"</"+c("li")+">":J[0].childNodes[0].innerHTML,I.unshift(J)}
//console.log('$nodes', $nodes);
t=angular.element("<"+F+">"+u+"</"+F+">"),I.pop().replaceWith(t),angular.forEach(I,function(a){a.remove()})}return void b.setSelectionToElementEnd(t[0])}}else{if("formatblock"===o.toLowerCase()){
// find the first blockElement
for(x=q.toLowerCase().replace(/[<>]/gi,""),"default"===x.trim()&&(x=h,q="<"+h+">"),t="li"===E?D.parent():D;!t[0].tagName||!t[0].tagName.match(i)&&!t.parent().attr("contenteditable");)t=t.parent(),/* istanbul ignore next */
E=(t[0].tagName||"").toLowerCase();if(E===x){
// $target is wrap element
v=t.children();var K=!1;for(s=0;s<v.length;s++)K=K||v[s].tagName.match(i);K?(t.after(v),w=t.next(),t.remove(),t=w):(A.append(t[0].childNodes),t.after(A),t.remove(),t=A)}else if(t.parent()[0].tagName.toLowerCase()!==x||t.parent().hasClass("ta-bind"))if(E.match(j))
// wrapping a list element
t.wrap(q);else{
// find the parent block element if any of the nodes are inline or text
for(
// default wrap behaviour
v=b.getOnlySelectedElements(),0===v.length&&(
// no nodes at all....
v=[t[0]]),s=0;s<v.length;s++)if(3===v[s].nodeType||!v[s].tagName.match(i))for(;3===v[s].nodeType||!v[s].tagName||!v[s].tagName.match(i);)v[s]=v[s].parentNode;if(
// remove any duplicates from the array of _nodes!
v=v.filter(function(a,b,c){return c.indexOf(a)===b}),
// remove all whole taTextElement if it is here... unless it is the only element!
v.length>1&&(v=v.filter(function(a,b,c){return!("div"===a.nodeName.toLowerCase()&&/^taTextElement/.test(a.id))})),angular.element(v[0]).hasClass("ta-bind"))t=angular.element(q),t[0].innerHTML=v[0].innerHTML,v[0].innerHTML=t[0].outerHTML;else if("blockquote"===x){for(
// blockquotes wrap other block elements
u="",s=0;s<v.length;s++)u+=v[s].outerHTML;for(t=angular.element(q),t[0].innerHTML=u,v[0].parentNode.insertBefore(t[0],v[0]),s=v.length-1;s>=0;s--)/* istanbul ignore else:  */
v[s].parentNode&&v[s].parentNode.removeChild(v[s])}else/* istanbul ignore next: not tested since identical to blockquote */
if("pre"===x&&b.getStateShiftKey()){for(
//console.log('shift pre', _nodes);
// pre wrap other block elements
u="",s=0;s<v.length;s++)u+=v[s].outerHTML;for(t=angular.element(q),t[0].innerHTML=u,v[0].parentNode.insertBefore(t[0],v[0]),s=v.length-1;s>=0;s--)/* istanbul ignore else:  */
v[s].parentNode&&v[s].parentNode.removeChild(v[s])}else
//console.log(optionsTagName, _nodes);
// regular block elements replace other block elements
for(s=0;s<v.length;s++){var L=m(v[s],q);v[s]===t[0]&&(t=angular.element(L))}}else{
//unwrap logic for parent
var M=t.parent(),N=M.contents();for(s=0;s<N.length;s++)/* istanbul ignore next: can't test - some wierd thing with how phantomjs works */
M.parent().hasClass("ta-bind")&&3===N[s].nodeType&&(A=angular.element("<"+h+">"),A[0].innerHTML=N[s].outerHTML,N[s]=A[0]),M.parent()[0].insertBefore(N[s],M[0]);M.remove()}
// looses focus when we have the whole container selected and no text!
// refocus on the shown display element, this fixes a bug when using firefox
return b.setSelectionToElementEnd(t[0]),void t[0].focus()}if("createlink"===o.toLowerCase()){/* istanbul ignore next: firefox specific fix */
if("a"===E)
// already a link!!! we are just replacing it...
return void(b.getSelectionElement().href=q);var O='<a href="'+q+'" target="'+(r.a.target?r.a.target:"")+'">',P="</a>",Q=b.getSelection();if(Q.collapsed)
// insert text at selection, then select then just let normal exec-command run
b.insertHtml(O+q+P,n);else if(a.getSelection().getRangeAt(0).canSurroundContents()){var R=angular.element(O+P)[0];a.getSelection().getRangeAt(0).surroundContents(R)}return}if("inserthtml"===o.toLowerCase())return void b.insertHtml(q,n)}try{d[0].execCommand(o,p,q)}catch(a){}}}}]).service("taSelection",["$document","taDOM","$log",/* istanbul ignore next: all browser specifics and PhantomJS dosen't seem to support half of it */
function(b,c,d){
// need to dereference the document else the calls don't work correctly
var e,f=b[0],g=function(a,b){/* check if selection is a BR element at the beginning of a container. If so, get
		* the parentNode instead.
		* offset should be zero in this case. Otherwise, return the original
		* element.
		*/
/* check if selection is a BR element at the beginning of a container. If so, get
		* the parentNode instead.
		* offset should be zero in this case. Otherwise, return the original
		* element.
		*/
return a.tagName&&a.tagName.match(/^br$/i)&&0===b&&!a.previousSibling?{element:a.parentNode,offset:0}:{element:a,offset:b}},h={getSelection:function(){var b;try{
// catch any errors from rangy and ignore the issue
b=a.getSelection().getRangeAt(0)}catch(a){
//console.info(e);
return}var c=b.commonAncestorContainer,d={start:g(b.startContainer,b.startOffset),end:g(b.endContainer,b.endOffset),collapsed:b.collapsed};
//console.log('***selection container:', selection.container.nodeName, selection.start.offset, selection.container);
// This has problems under Firefox.
// On Firefox with
// <p>Try me !</p>
// <ul>
// <li>line 1</li>
// <li>line 2</li>
// </ul>
// <p>line 3</p>
// <ul>
// <li>line 4</li>
// <li>line 5</li>
// </ul>
// <p>Hello textAngular</p>
// WITH the cursor after the 3 on line 3, it gets the commonAncestorContainer as:
// <TextNode textContent='line 3'>
// AND Chrome gets the commonAncestorContainer as:
// <p>line 3</p>
//
// Check if the container is a text node and return its parent if so
// unless this is the whole taTextElement.  If so we return the textNode
//console.log('*********taTextElement************');
//console.log('commonAncestorContainer:', container);
return 3===c.nodeType&&("div"===c.parentNode.nodeName.toLowerCase()&&/^taTextElement/.test(c.parentNode.id)||(c=c.parentNode)),"div"===c.nodeName.toLowerCase()&&/^taTextElement/.test(c.id)?(d.start.element=c.childNodes[d.start.offset],d.end.element=c.childNodes[d.end.offset],d.container=c):c.parentNode===d.start.element||c.parentNode===d.end.element?d.container=c.parentNode:d.container=c,d},
// if we use the LEFT_ARROW and we are at the special place <span>&#65279;</span> we move the cursor over by one...
// Chrome and Firefox behave differently so so fix this for Firefox here.  No adjustment needed for Chrome.
updateLeftArrowKey:function(b){var c=a.getSelection().getRangeAt(0);if(c&&c.collapsed){var d=h.getFlattenedDom(c);if(!d.findIndex)return;var e,f,g=c.startContainer,i=d.findIndex(function(a,b){if(a.node===g)return!0;var c=a.parents.indexOf(g);return c!==-1});
//console.log('updateLeftArrowKey', range.startOffset, range.startContainer.textContent);
// this first section handles the case for Chrome browser
// if the first character of the nextNode is a \ufeff we know that we are just before the special span...
// and so we most left by one character
if(
//console.log('indexStartContainer', indexStartContainer, _nodes.length, 'startContainer:', _node, _node === _nodes[indexStartContainer].node);
d.forEach(function(a,b){
//console.log(i, n.node);
a.parents.forEach(function(a,b){})}),i+1<d.length&&(
// we need the node just after this startContainer
// so we can check and see it this is a special place
f=d[i+1].node),f&&f.textContent&&(e=/^\ufeff([^\ufeff]*)$/.exec(f.textContent)))
// we are before the special node with begins with a \ufeff character
//console.log('LEFT ...found it...', 'startOffset:', range.startOffset, m[0].length, m[1].length);
// no need to change anything in this case
return;var j;if(i>0&&(
// we need the node just after this startContainer
// so we can check and see it this is a special place
j=d[i-1].node),0===c.startOffset&&j&&(
//console.log(nextNodeToLeft, range.startOffset, nextNodeToLeft.textContent);
e=/^\ufeff([^\ufeff]*)$/.exec(j.textContent)))
//console.log('LEFT &&&&&&&&&&&&&&&&&&&...found it...&&&&&&&&&&&', nextNodeToLeft, m[0].length, m[1].length);
// move over to the left my one -- Firefox triggers this case
return void h.setSelectionToElementEnd(j)}},
// if we use the RIGHT_ARROW and we are at the special place <span>&#65279;</span> we move the cursor over by one...
updateRightArrowKey:function(a){},getFlattenedDom:function(a){function b(a){if(a.node.childNodes.length){var c=Array.prototype.slice.call(a.node.childNodes);// converts NodeList to Array
c.forEach(function(c){var d=a.parents.slice();d.slice(-1)[0]!==a.node&&d.push(a.node),b({parents:d,node:c})})}else d.push({parents:a.parents,node:a.node})}var c=a.commonAncestorContainer.parentNode;if(!c)return a.commonAncestorContainer.childNodes;var d=Array.prototype.slice.call(c.childNodes),e=d.indexOf(a.startContainer);
// make sure that we have a big enough set of nodes
// now walk the parent
return e+1<d.length&&e>0||c.parentNode&&(c=c.parentNode),d=[],b({parents:[c],node:c}),d},getOnlySelectedElements:function(){var b=a.getSelection().getRangeAt(0),c=b.commonAncestorContainer;
// get the nodes in the range that are ELEMENT_NODE and are children of the container
// in this range...
// Node.TEXT_NODE === 3
// Node.ELEMENT_NODE === 1
// Node.COMMENT_NODE === 8
// Check if the container is a text node and return its parent if so
return c=3===c.nodeType?c.parentNode:c,b.getNodes([1],function(a){return a.parentNode===c})},
// this includes the container element if all children are selected
getAllSelectedElements:function(){var b=a.getSelection().getRangeAt(0),c=b.commonAncestorContainer;
// Node.TEXT_NODE === 3
// Node.ELEMENT_NODE === 1
// Node.COMMENT_NODE === 8
// Check if the container is a text node and return its parent if so
c=3===c.nodeType?c.parentNode:c;
// get the nodes in the range that are ELEMENT_NODE and are children of the container
// in this range...
var d=b.getNodes([1],function(a){return a.parentNode===c}),e=c.innerHTML;
//console.log(innerHtml);
//console.log(range.toHtml());
//console.log(innerHtml === range.toHtml());
if(
// remove the junk that rangy has put down
e=e.replace(/<span id=.selectionBoundary[^>]+>\ufeff?<\/span>/gi,""),e===b.toHtml()&&("div"!==c.nodeName.toLowerCase()||!/^taTextElement/.test(c.id))){for(var f=[],g=d.length;g--;f.unshift(d[g]));d=f,d.push(c)}return d},
// Some basic selection functions
getSelectionElement:function(){var a=h.getSelection();return a?h.getSelection().container:void 0},setSelection:function(b,c,d,e){var f=a.createRange();f.setStart(b,d),f.setEnd(c,e),a.getSelection().setSingleRange(f)},setSelectionBeforeElement:function(b){var c=a.createRange();c.selectNode(b),c.collapse(!0),a.getSelection().setSingleRange(c)},setSelectionAfterElement:function(b){var c=a.createRange();c.selectNode(b),c.collapse(!1),a.getSelection().setSingleRange(c)},setSelectionToElementStart:function(b){var c=a.createRange();c.selectNodeContents(b),c.collapse(!0),a.getSelection().setSingleRange(c)},setSelectionToElementEnd:function(b){var c=a.createRange();c.selectNodeContents(b),c.collapse(!1),b.childNodes&&b.childNodes[b.childNodes.length-1]&&"br"===b.childNodes[b.childNodes.length-1].nodeName&&(c.startOffset=c.endOffset=c.startOffset-1),a.getSelection().setSingleRange(c)},setStateShiftKey:function(a){e=a},getStateShiftKey:function(){return e},
// from http://stackoverflow.com/questions/6690752/insert-html-at-caret-in-a-contenteditable-div
// topNode is the contenteditable normally, all manipulation MUST be inside this.
insertHtml:function(b,d){var e,g,j,l,m,n,o,p=angular.element("<div>"+b+"</div>"),q=a.getSelection().getRangeAt(0),r=f.createDocumentFragment(),s=p[0].childNodes,t=!0;if(s.length>0){for(
// NOTE!! We need to do the following:
// check for blockelements - if they exist then we have to split the current element in half (and all others up to the closest block element) and insert all children in-between.
// If there are no block elements, or there is a mixture we need to create textNodes for the non wrapped text (we don't want them spans messing up the picture).
l=[],j=0;j<s.length;j++){var u=s[j];"p"===u.nodeName.toLowerCase()&&""===u.innerHTML.trim()||(/****************
					 *  allow any text to be inserted...
					if((   _cnode.nodeType === 3 &&
						   _cnode.nodeValue === '\ufeff'[0] &&
						   _cnode.nodeValue.trim() === '') // empty no-space space element
						) {
						// no change to isInline
						nodes.push(_cnode);
						continue;
					}
					if(_cnode.nodeType === 3 &&
						 _cnode.nodeValue.trim() === '') { // empty text node
						continue;
					}
					*****************/
t=t&&!i.test(u.nodeName),l.push(u))}for(var v=0;v<l.length;v++)n=r.appendChild(l[v]);!t&&q.collapsed&&/^(|<br(|\/)>)$/i.test(q.startContainer.innerHTML)&&q.selectNode(q.startContainer)}else t=!0,
// paste text of some sort
n=r=f.createTextNode(b);
// Other Edge case - selected data spans multiple blocks.
if(t)q.deleteContents();else// not inline insert
if(q.collapsed&&q.startContainer!==d)if(q.startContainer.innerHTML&&q.startContainer.innerHTML.match(/^<[^>]*>$/i))
// this log is to catch when innerHTML is something like `<img ...>`
e=q.startContainer,1===q.startOffset?(
// before single tag
q.setStartAfter(e),q.setEndAfter(e)):(
// after single tag
q.setStartBefore(e),q.setEndBefore(e));else{
// split element into 2 and insert block element in middle
if(3===q.startContainer.nodeType&&q.startContainer.parentNode!==d)
// Escape out of the inline tags like b
for(// if text node
e=q.startContainer.parentNode,g=e.cloneNode(),
// split the nodes into two lists - before and after, splitting the node with the selection into 2 text nodes.
c.splitNodes(e.childNodes,e,g,q.startContainer,q.startOffset);!k.test(e.nodeName);){angular.element(e).after(g),e=e.parentNode;var w=g;g=e.cloneNode(),
// split the nodes into two lists - before and after, splitting the node with the selection into 2 text nodes.
c.splitNodes(e.childNodes,e,g,w)}else e=q.startContainer,g=e.cloneNode(),c.splitNodes(e.childNodes,e,g,void 0,void 0,q.startOffset);if(angular.element(e).after(g),
// put cursor to end of inserted content
//console.log('setStartAfter', parent);
q.setStartAfter(e),q.setEndAfter(e),/^(|<br(|\/)>)$/i.test(e.innerHTML.trim())&&(q.setStartBefore(e),q.setEndBefore(e),angular.element(e).remove()),/^(|<br(|\/)>)$/i.test(g.innerHTML.trim())&&angular.element(g).remove(),"li"===e.nodeName.toLowerCase()){for(o=f.createDocumentFragment(),m=0;m<r.childNodes.length;m++)p=angular.element("<li>"),c.transferChildNodes(r.childNodes[m],p[0]),c.transferNodeAttributes(r.childNodes[m],p[0]),o.appendChild(p[0]);r=o,n&&(n=r.childNodes[r.childNodes.length-1],n=n.childNodes[n.childNodes.length-1])}}else q.deleteContents();q.insertNode(r),n&&h.setSelectionToElementEnd(n)}};return h}]).service("taDOM",function(){var a={
// recursive function that returns an array of angular.elements that have the passed attribute set on them
getByAttribute:function(b,c){var d=[],e=b.children();return e.length&&angular.forEach(e,function(b){d=d.concat(a.getByAttribute(angular.element(b),c))}),void 0!==b.attr(c)&&d.push(b),d},transferChildNodes:function(a,b){for(
// clear out target
b.innerHTML="";a.childNodes.length>0;)b.appendChild(a.childNodes[0]);return b},splitNodes:function(b,c,d,e,f,g){if(!e&&isNaN(g))throw new Error("taDOM.splitNodes requires a splitNode or splitIndex");for(var h=document.createDocumentFragment(),i=document.createDocumentFragment(),j=0;b.length>0&&(isNaN(g)||g!==j)&&b[0]!==e;)h.appendChild(b[0]),// this removes from the nodes array (if proper childNodes object.
j++;for(!isNaN(f)&&f>=0&&b[0]&&(h.appendChild(document.createTextNode(b[0].nodeValue.substring(0,f))),b[0].nodeValue=b[0].nodeValue.substring(f));b.length>0;)i.appendChild(b[0]);a.transferChildNodes(h,c),a.transferChildNodes(i,d)},transferNodeAttributes:function(a,b){for(var c=0;c<a.attributes.length;c++)b.setAttribute(a.attributes[c].name,a.attributes[c].value);return b}};return a}),angular.module("textAngular.validators",[]).directive("taMaxText",function(){return{restrict:"A",require:"ngModel",link:function(a,b,c,d){var e=parseInt(a.$eval(c.taMaxText));if(isNaN(e))throw"Max text must be an integer";c.$observe("taMaxText",function(a){if(e=parseInt(a),isNaN(e))throw"Max text must be an integer";d.$dirty&&d.$validate()}),d.$validators.taMaxText=function(a){var b=angular.element("<div/>");return b.html(a),b.text().length<=e}}}}).directive("taMinText",function(){return{restrict:"A",require:"ngModel",link:function(a,b,c,d){var e=parseInt(a.$eval(c.taMinText));if(isNaN(e))throw"Min text must be an integer";c.$observe("taMinText",function(a){if(e=parseInt(a),isNaN(e))throw"Min text must be an integer";d.$dirty&&d.$validate()}),d.$validators.taMinText=function(a){var b=angular.element("<div/>");return b.html(a),!b.text().length||b.text().length>=e}}}}),angular.module("textAngular.taBind",["textAngular.factories","textAngular.DOM"]).service("_taBlankTest",[function(){return function(a){
// we radically restructure this code.
// what was here before was incredibly fragile.
// What we do now is to check that the html is non-blank visually
// which we check by looking at html->text
if(!a)return!0;
// find first non-tag match - ie start of string or after tag that is not whitespace
// var t0 = performance.now();
// Takes a small fraction of a mSec to do this...
var b=d(a);
// var t1 = performance.now();
// console.log('Took', (t1 - t0).toFixed(4), 'milliseconds to generate:');
// var t1 = performance.now();
// console.log('Took', (t1 - t0).toFixed(4), 'milliseconds to generate:');
return""===b&&!/<img[^>]+>/.test(a)}}]).directive("taButton",[function(){return{link:function(a,b,c){b.attr("unselectable","on"),b.on("mousedown",function(a,b){/* istanbul ignore else: this is for catching the jqLite testing*/
// this prevents focusout from firing on the editor when clicking toolbar buttons
return b&&angular.extend(a,b),a.preventDefault(),!1})}}}]).directive("taBind",["taSanitize","$timeout","$document","taFixChrome","taBrowserTag","taSelection","taSelectableElements","taApplyCustomRenderers","taOptions","_taBlankTest","$parse","taDOM","textAngularManager",function(b,c,d,e,f,h,j,l,o,p,q,r,s){
// Uses for this are textarea or input with ng-model and ta-bind='text'
// OR any non-form element with contenteditable="contenteditable" ta-bind="html|text" ng-model
return{priority:2,// So we override validators correctly
require:["ngModel","?ngModelOptions"],link:function(f,u,v,w){function x(a){var b;return V.forEach(function(c){if(c.keyCode===a.keyCode){var d=(a.metaKey?N:0)+(a.ctrlKey?M:0)+(a.shiftKey?P:0)+(a.altKey?O:0);if(c.forbiddenModifiers&d)return;c.mustHaveModifiers.every(function(a){return d&a})&&(b=c.specialKey)}}),b}var y,z,A,B,C=w[0],D=w[1]||{},E=void 0!==u.attr("contenteditable")&&u.attr("contenteditable"),F=E||"textarea"===u[0].tagName.toLowerCase()||"input"===u[0].tagName.toLowerCase(),G=!1,H=!1,I=!1,J=v.taUnsafeSanitizer||o.disableSanitizer,K=/^(9|19|20|27|33|34|35|36|37|38|39|40|45|112|113|114|115|116|117|118|119|120|121|122|123|144|145)$/i,L=/^(8|13|32|46|59|61|107|109|173|186|187|188|189|190|191|192|219|220|221|222)$/i,M=1,N=2,O=4,P=8,Q=13,R=16,S=9,T=37,U=39,V=[
//		ctrl/command + z
{specialKey:"UndoKey",forbiddenModifiers:O+P,mustHaveModifiers:[N+M],keyCode:90},
//		ctrl/command + shift + z
{specialKey:"RedoKey",forbiddenModifiers:O,mustHaveModifiers:[N+M,P],keyCode:90},
//		ctrl/command + y
{specialKey:"RedoKey",forbiddenModifiers:O+P,mustHaveModifiers:[N+M],keyCode:89},
//		TabKey
{specialKey:"TabKey",forbiddenModifiers:N+P+O+M,mustHaveModifiers:[],keyCode:S},
//		shift + TabKey
{specialKey:"ShiftTabKey",forbiddenModifiers:N+O+M,mustHaveModifiers:[P],keyCode:S}];
// set the default to be a paragraph value
void 0===v.taDefaultWrap&&(v.taDefaultWrap="p"),/* istanbul ignore next: ie specific test */
""===v.taDefaultWrap?(A="",B=void 0===g.ie?"<div><br></div>":g.ie>=11?"<p><br></p>":g.ie<=8?"<P>&nbsp;</P>":"<p>&nbsp;</p>"):(A=void 0===g.ie||g.ie>=11?"br"===v.taDefaultWrap.toLowerCase()?"<BR><BR>":"<"+v.taDefaultWrap+"><br></"+v.taDefaultWrap+">":g.ie<=8?"<"+v.taDefaultWrap.toUpperCase()+"></"+v.taDefaultWrap.toUpperCase()+">":"<"+v.taDefaultWrap+"></"+v.taDefaultWrap+">",B=void 0===g.ie||g.ie>=11?"br"===v.taDefaultWrap.toLowerCase()?"<br><br>":"<"+v.taDefaultWrap+"><br></"+v.taDefaultWrap+">":g.ie<=8?"<"+v.taDefaultWrap.toUpperCase()+">&nbsp;</"+v.taDefaultWrap.toUpperCase()+">":"<"+v.taDefaultWrap+">&nbsp;</"+v.taDefaultWrap+">"),/* istanbul ignore else */
D.$options||(D.$options={});// ng-model-options support
var W=function(a){if(p(a))return a;var b=angular.element("<div>"+a+"</div>");
//console.log('domTest.children().length():', domTest.children().length);
//console.log('_ensureContentWrapped', domTest.children());
//console.log(value, attrs.taDefaultWrap);
if(0===b.children().length)
// if we have a <br> and the attrs.taDefaultWrap is a <p> we need to remove the <br>
//value = value.replace(/<br>/i, '');
a="<"+v.taDefaultWrap+">"+a+"</"+v.taDefaultWrap+">";else{var c,d=b[0].childNodes,e=!1;for(c=0;c<d.length&&!(e=d[c].nodeName.toLowerCase().match(i));c++);if(e)for(a="",c=0;c<d.length;c++){var f=d[c],g=f.nodeName.toLowerCase();
//console.log('node#:', i, 'name:', nodeName);
if("#comment"===g)a+="<!--"+f.nodeValue+"-->";else if("#text"===g){
// determine if this is all whitespace, if so, we will leave it as it is.
// otherwise, we will wrap it as it is
var h=f.textContent;
// not pure white space so wrap in <p>...</p> or whatever attrs.taDefaultWrap is set to.
a+=h.trim()?"<"+v.taDefaultWrap+">"+h+"</"+v.taDefaultWrap+">":h}else if(g.match(i))a+=f.outerHTML;else{/* istanbul ignore  next: Doesn't seem to trigger on tests */
var j=f.outerHTML||f.nodeValue;/* istanbul ignore else: Doesn't seem to trigger on tests, is tested though */
a+=""!==j.trim()?"<"+v.taDefaultWrap+">"+j+"</"+v.taDefaultWrap+">":j}}else a="<"+v.taDefaultWrap+">"+a+"</"+v.taDefaultWrap+">"}
//console.log(value);
return a};v.taPaste&&(z=q(v.taPaste)),u.addClass("ta-bind");var X;f["$undoManager"+(v.id||"")]=C.$undoManager={_stack:[],_index:0,_max:1e3,push:function(a){return"undefined"==typeof a||null===a||"undefined"!=typeof this.current()&&null!==this.current()&&a===this.current()?a:(this._index<this._stack.length-1&&(this._stack=this._stack.slice(0,this._index+1)),this._stack.push(a),X&&c.cancel(X),this._stack.length>this._max&&this._stack.shift(),this._index=this._stack.length-1,a)},undo:function(){return this.setToIndex(this._index-1)},redo:function(){return this.setToIndex(this._index+1)},setToIndex:function(a){if(!(a<0||a>this._stack.length-1))return this._index=a,this.current()},current:function(){return this._stack[this._index]}};
// in here we are undoing the converts used elsewhere to prevent the < > and & being displayed when they shouldn't in the code.
var Y,Z=function(){if(E)return u[0].innerHTML;if(F)return u.val();throw"textAngular Error: attempting to update non-editable taBind"},$=function(a){
// emit the element-select event, pass the element
return f.$emit("ta-element-select",this),a.preventDefault(),!1},_=f["reApplyOnSelectorHandlers"+(v.id||"")]=function(){/* istanbul ignore else */
G||angular.forEach(j,function(a){
// check we don't apply the handler twice
u.find(a).off("click",$).on("click",$)})},aa=function(a,b,c){I=c||!1,"undefined"!=typeof b&&null!==b||(b=E),// if not contentEditable then the native undo/redo is fine
"undefined"!=typeof a&&null!==a||(a=Z()),p(a)?(
// this avoids us from tripping the ng-pristine flag if we click in and out with out typing
""!==C.$viewValue&&C.$setViewValue(""),b&&""!==C.$undoManager.current()&&C.$undoManager.push("")):(_(),C.$viewValue!==a&&(C.$setViewValue(a),b&&C.$undoManager.push(a))),C.$render()},ba=function(a){u[0].innerHTML=a},ca=f["$undoTaBind"+(v.id||"")]=function(){/* istanbul ignore else: can't really test it due to all changes being ignored as well in readonly */
if(!G&&E){var a=C.$undoManager.undo();"undefined"!=typeof a&&null!==a&&(ba(a),aa(a,!1),Y&&c.cancel(Y),Y=c(function(){u[0].focus(),h.setSelectionToElementEnd(u[0])},1))}},da=f["$redoTaBind"+(v.id||"")]=function(){/* istanbul ignore else: can't really test it due to all changes being ignored as well in readonly */
if(!G&&E){var a=C.$undoManager.redo();"undefined"!=typeof a&&null!==a&&(ba(a),aa(a,!1),/* istanbul ignore next */
Y&&c.cancel(Y),Y=c(function(){u[0].focus(),h.setSelectionToElementEnd(u[0])},1))}};
//used for updating when inserting wrapped elements
f["updateTaBind"+(v.id||"")]=function(){G||aa(void 0,void 0,!0)};
// catch DOM XSS via taSanitize
// Sanitizing both ways is identical
var ea=function(a){return C.$oldViewValue=b(e(a),C.$oldViewValue,J)};
//this code is used to update the models when data is entered/deleted
if(
// trigger the validation calls
u.attr("required")&&(C.$validators.required=function(a,b){return!p(a||b)}),
// parsers trigger from the above keyup function or any other time that the viewValue is updated and parses it for storage in the ngModel
C.$parsers.push(ea),C.$parsers.unshift(W),
// because textAngular is bi-directional (which is awesome) we need to also sanitize values going in from the server
C.$formatters.push(ea),C.$formatters.unshift(W),C.$formatters.unshift(function(a){return C.$undoManager.push(a||"")}),F)if(f.events={},E){
// all the code specific to contenteditable divs
var fa=!1,ga=function(a){var d=void 0!==a&&a.match(/content=["']*OneNote.File/i);/* istanbul ignore else: don't care if nothing pasted */
//console.log(text);
if(a&&a.trim().length){
// test paste from word/microsoft product
if(a.match(/class=["']*Mso(Normal|List)/i)||a.match(/content=["']*Word.Document/i)||a.match(/content=["']*OneNote.File/i)){var e=a.match(/<!--StartFragment-->([\s\S]*?)<!--EndFragment-->/i);e=e?e[1]:a,e=e.replace(/<o:p>[\s\S]*?<\/o:p>/gi,"").replace(/class=(["']|)MsoNormal(["']|)/gi,"");var g=angular.element("<div>"+e+"</div>"),i=angular.element("<div></div>"),j={element:null,lastIndent:[],lastLi:null,isUl:!1};j.lastIndent.peek=function(){var a=this.length;if(a>0)return this[a-1]};for(var k=function(a){j.isUl=a,j.element=angular.element(a?"<ul>":"<ol>"),j.lastIndent=[],j.lastIndent.peek=function(){var a=this.length;if(a>0)return this[a-1]},j.lastLevelMatch=null},l=0;l<=g[0].childNodes.length;l++)if(g[0].childNodes[l]&&"#text"!==g[0].childNodes[l].nodeName){var m=g[0].childNodes[l].tagName.toLowerCase();if("p"===m||"h1"===m||"h2"===m||"h3"===m||"h4"===m||"h5"===m||"h6"===m){var n=angular.element(g[0].childNodes[l]),o=(n.attr("class")||"").match(/MsoList(Bullet|Number|Paragraph)(CxSp(First|Middle|Last)|)/i);if(o){if(n[0].childNodes.length<2||n[0].childNodes[1].childNodes.length<1)continue;var p="bullet"===o[1].toLowerCase()||"number"!==o[1].toLowerCase()&&!(/^[^0-9a-z<]*[0-9a-z]+[^0-9a-z<>]</i.test(n[0].childNodes[1].innerHTML)||/^[^0-9a-z<]*[0-9a-z]+[^0-9a-z<>]</i.test(n[0].childNodes[1].childNodes[0].innerHTML)),q=(n.attr("style")||"").match(/margin-left:([\-\.0-9]*)/i),s=parseFloat(q?q[1]:0),t=(n.attr("style")||"").match(/mso-list:l([0-9]+) level([0-9]+) lfo[0-9+]($|;)/i);if(
// prefers the mso-list syntax
t&&t[2]&&(s=parseInt(t[2])),t&&(!j.lastLevelMatch||t[1]!==j.lastLevelMatch[1])||!o[3]||"first"===o[3].toLowerCase()||null===j.lastIndent.peek()||j.isUl!==p&&j.lastIndent.peek()===s)k(p),i.append(j.element);else if(null!=j.lastIndent.peek()&&j.lastIndent.peek()<s)j.element=angular.element(p?"<ul>":"<ol>"),j.lastLi.append(j.element);else if(null!=j.lastIndent.peek()&&j.lastIndent.peek()>s){for(;null!=j.lastIndent.peek()&&j.lastIndent.peek()>s;)if("li"!==j.element.parent()[0].tagName.toLowerCase()){if(!/[uo]l/i.test(j.element.parent()[0].tagName.toLowerCase()))// else it's it should be a sibling
break;j.element=j.element.parent(),j.lastIndent.pop()}else j.element=j.element.parent();j.isUl="ul"===j.element[0].tagName.toLowerCase(),p!==j.isUl&&(k(p),i.append(j.element))}j.lastLevelMatch=t,s!==j.lastIndent.peek()&&j.lastIndent.push(s),j.lastLi=angular.element("<li>"),j.element.append(j.lastLi),j.lastLi.html(n.html().replace(/<!(--|)\[if !supportLists\](--|)>[\s\S]*?<!(--|)\[endif\](--|)>/gi,"")),n.remove()}else k(!1),i.append(n)}}var v=function(a){a=angular.element(a);for(var b=a[0].childNodes.length-1;b>=0;b--)a.after(a[0].childNodes[b]);a.remove()};angular.forEach(i.find("span"),function(a){a.removeAttribute("lang"),a.attributes.length<=0&&v(a)}),angular.forEach(i.find("font"),v),a=i.html(),d&&(a=i.html()||g.html()),
// LF characters instead of spaces in some spots and they are replaced by "/n", so we need to just swap them to spaces
a=a.replace(/\n/g," ")}else{if(
// remove unnecessary chrome insert
a=a.replace(/<(|\/)meta[^>]*?>/gi,""),a.match(/<[^>]*?(ta-bind)[^>]*?>/)){
// entire text-angular or ta-bind has been pasted, REMOVE AT ONCE!!
if(a.match(/<[^>]*?(text-angular)[^>]*?>/)){var w=angular.element("<div>"+a+"</div>");w.find("textarea").remove();for(var x=r.getByAttribute(w,"ta-bind"),y=0;y<x.length;y++){for(var A=x[y][0].parentNode.parentNode,B=0;B<x[y][0].childNodes.length;B++)A.parentNode.insertBefore(x[y][0].childNodes[B],A);A.parentNode.removeChild(A)}a=w.html().replace('<br class="Apple-interchange-newline">',"")}}else a.match(/^<span/)&&(
// in case of pasting only a span - chrome paste, remove them. THis is just some wierd formatting
// if we remove the '<span class="Apple-converted-space">Â </span>' here we destroy the spacing
// on paste from even ourselves!
a.match(/<span class=(\"Apple-converted-space\"|\'Apple-converted-space\')>.<\/span>/gi)||(a=a.replace(/<(|\/)span[^>]*?>/gi,"")));
// Webkit on Apple tags
a=a.replace(/<br class="Apple-interchange-newline"[^>]*?>/gi,"").replace(/<span class="Apple-converted-space">( |&nbsp;)<\/span>/gi,"&nbsp;")}/<li(\s.*)?>/i.test(a)&&/(<ul(\s.*)?>|<ol(\s.*)?>).*<li(\s.*)?>/i.test(a)===!1&&(
// insert missing parent of li element
a=a.replace(/<li(\s.*)?>.*<\/li(\s.*)?>/i,"<ul>$&</ul>")),
// parse whitespace from plaintext input, starting with preceding spaces that get stripped on paste
a=a.replace(/^[ |\u00A0]+/gm,function(a){for(var b="",c=0;c<a.length;c++)b+="&nbsp;";return b}).replace(/\n|\r\n|\r/g,"<br />").replace(/\t/g,"&nbsp;&nbsp;&nbsp;&nbsp;"),z&&(a=z(f,{$html:a})||a),a=b(a,"",J),h.insertHtml(a,u[0]),c(function(){C.$setViewValue(Z()),fa=!1,u.removeClass("processing-paste")},0)}else fa=!1,u.removeClass("processing-paste")};u.on("paste",f.events.paste=function(b,e){if(/* istanbul ignore else: this is for catching the jqLite testing*/
e&&angular.extend(b,e),G||fa)return b.stopPropagation(),b.preventDefault(),!1;
// Code adapted from http://stackoverflow.com/questions/2176861/javascript-get-clipboard-data-on-paste-event-cross-browser/6804718#6804718
fa=!0,u.addClass("processing-paste");var f,g=(b.originalEvent||b).clipboardData;if(g&&g.getData&&g.types.length>0){for(var h="",i=0;i<g.types.length;i++)h+=" "+g.types[i];/* istanbul ignore next: browser tests */
return/text\/html/i.test(h)?f=g.getData("text/html"):/text\/plain/i.test(h)&&(f=g.getData("text/plain")),ga(f),b.stopPropagation(),b.preventDefault(),!1}// Everything else - empty editdiv and allow browser to paste content into it, then cleanup
var j=a.saveSelection(),k=angular.element('<div class="ta-hidden-input" contenteditable="true"></div>');d.find("body").append(k),k[0].focus(),c(function(){
// restore selection
a.restoreSelection(j),ga(k[0].innerHTML),u[0].focus(),k.remove()},0)}),u.on("cut",f.events.cut=function(a){
// timeout to next is needed as otherwise the paste/cut event has not finished actually changing the display
G?a.preventDefault():c(function(){C.$setViewValue(Z())},0)}),u.on("keydown",f.events.keydown=function(a,b){/* istanbul ignore else: this is for catching the jqLite testing*/
b&&angular.extend(a,b),a.keyCode===R?h.setStateShiftKey(!0):h.setStateShiftKey(!1),a.specialKey=x(a);var c;/* istanbul ignore else: readonly check */
if(/* istanbul ignore next: difficult to test */
o.keyMappings.forEach(function(b){a.specialKey===b.commandKeyCode&&(
// taOptions has remapped this binding... so
// we disable our own
a.specialKey=void 0),b.testForKey(a)&&(c=b.commandKeyCode),"UndoKey"!==b.commandKeyCode&&"RedoKey"!==b.commandKeyCode||b.enablePropagation||a.preventDefault()}),/* istanbul ignore next: difficult to test */
"undefined"!=typeof c&&(a.specialKey=c),/* istanbul ignore next: difficult to test as can't seem to select */
"undefined"==typeof a.specialKey||"UndoKey"===a.specialKey&&"RedoKey"===a.specialKey||(a.preventDefault(),s.sendKeyCommand(f,a)),!(G||("UndoKey"===a.specialKey&&(ca(),a.preventDefault()),"RedoKey"===a.specialKey&&(da(),a.preventDefault()),a.keyCode!==Q||a.shiftKey||a.ctrlKey||a.metaKey||a.altKey))){var d,e=function(a,b){for(var c=0;c<a.length;c++)if(a[c]===b)return!0;return!1},g=h.getSelectionElement();
// shifted to nodeName here from tagName since it is more widely supported see: http://stackoverflow.com/questions/4878484/difference-between-tagname-and-nodename
if(!g.nodeName.match(k))return;var i=angular.element(A),j=["blockquote","ul","ol"];if(e(j,g.parentNode.tagName.toLowerCase())){if(/^<br(|\/)>$/i.test(g.innerHTML.trim())&&!g.nextSibling){
// if last element is blank, pull element outside.
d=angular.element(g);var l=d.parent();l.after(i),d.remove(),0===l.children().length&&l.remove(),h.setSelectionToElementStart(i[0]),a.preventDefault()}/^<[^>]+><br(|\/)><\/[^>]+>$/i.test(g.innerHTML.trim())&&(d=angular.element(g),d.after(i),d.remove(),h.setSelectionToElementStart(i[0]),a.preventDefault())}}});var ha;u.on("keyup",f.events.keyup=function(a,b){// clear the ShiftKey state
/* istanbul ignore next: FF specific bug fix */
if(/* istanbul ignore else: this is for catching the jqLite testing*/
b&&angular.extend(a,b),h.setStateShiftKey(!1),a.keyCode===S){var d=h.getSelection();return void(d.start.element===u[0]&&u.children().length&&h.setSelectionToElementStart(u.children()[0]))}if(
// we do this here during the 'keyup' so that the browser has already moved the slection by one character...
a.keyCode!==T||a.shiftKey||h.updateLeftArrowKey(u),
// we do this here during the 'keyup' so that the browser has already moved the slection by one character...
a.keyCode!==U||a.shiftKey||h.updateRightArrowKey(u),X&&c.cancel(X),!G&&!K.test(a.keyCode))/* istanbul ignore next: Ignore any _ENTER_KEYCODE that has ctrlKey, metaKey or alKey */
if(a.keyCode===Q&&(a.ctrlKey||a.metaKey||a.altKey));else{
// if enter - insert new taDefaultWrap, if shift+enter insert <br/>
if(!(""===A||"<BR><BR>"===A||a.keyCode!==Q||a.ctrlKey||a.metaKey||a.altKey||a.shiftKey)){
// shifted to nodeName here from tagName since it is more widely supported see: http://stackoverflow.com/questions/4878484/difference-between-tagname-and-nodename
for(
// new paragraph, br should be caught correctly
var e=h.getSelectionElement();!e.nodeName.match(k)&&e!==u[0];)e=e.parentNode;if(e.tagName.toLowerCase()!==v.taDefaultWrap&&"li"!==e.tagName.toLowerCase()&&(""===e.innerHTML.trim()||"<br>"===e.innerHTML.trim())){
// Chrome starts with a <div><br></div> after an EnterKey
// so we replace this with the _defaultVal
var f=angular.element(A);angular.element(e).replaceWith(f),h.setSelectionToElementStart(f[0])}}var g=Z();""===A||""!==g.trim()&&"<br>"!==g.trim()?"<"!==g.substring(0,1)&&""!==v.taDefaultWrap:(ba(A),h.setSelectionToElementStart(u.children()[0]));var i=y!==a.keyCode&&L.test(a.keyCode);ha&&c.cancel(ha),ha=c(function(){aa(g,i,!0)},D.$options.debounce||400),i||(X=c(function(){C.$undoManager.push(g)},250)),y=a.keyCode}});
// when there is a change from a spelling correction in the browser, the only
// change that is seen is a 'input' and the $watch('html') sees nothing... So
// we added this element.on('input') to catch this change and call the _setViewValue()
// so the ngModel is updated and all works as it should.
var ia;
// Placeholders not supported on ie 8 and below
if(u.on("input",function(){Z()!==C.$viewValue&&(
// we wait a time now to allow the natural $watch('html') to handle this change
// and then after a 1 second delay, if there is still a difference we will do the
// _setViewValue() call.
/* istanbul ignore if: can't test */
ia&&c.cancel(ia),/* istanbul ignore next: cant' test? */
ia=c(function(){var a=Z();a!==C.$viewValue&&
//console.log('_setViewValue');
//console.log('old:', ngModel.$viewValue);
//console.log('new:', _val);
aa(a,!0)},1e3))}),u.on("blur",f.events.blur=function(){H=!1,/* istanbul ignore else: if readonly don't update model */
G?(I=!0,// don't redo the whole thing, just check the placeholder logic
C.$render()):aa(void 0,void 0,!0)}),v.placeholder&&(g.ie>8||void 0===g.ie)){var ja;if(!v.id)throw"textAngular Error: An unique ID is required for placeholders to work";ja=m("#"+v.id+".placeholder-text:before",'content: "'+v.placeholder+'"'),f.$on("$destroy",function(){n(ja)})}u.on("focus",f.events.focus=function(){H=!0,u.removeClass("placeholder-text"),_()}),u.on("mouseup",f.events.mouseup=function(){var a=h.getSelection();a&&a.start.element===u[0]&&u.children().length&&h.setSelectionToElementStart(u.children()[0])}),
// prevent propagation on mousedown in editor, see #206
u.on("mousedown",f.events.mousedown=function(a,b){/* istanbul ignore else: this is for catching the jqLite testing*/
b&&angular.extend(a,b),a.stopPropagation()})}else{
// if a textarea or input just add in change and blur handlers, everything else is done by angulars input directive
u.on("change blur",f.events.change=f.events.blur=function(){G||C.$setViewValue(Z())}),u.on("keydown",f.events.keydown=function(a,b){
// Reference to http://stackoverflow.com/questions/6140632/how-to-handle-tab-in-textarea
/* istanbul ignore else: otherwise normal functionality */
if(/* istanbul ignore else: this is for catching the jqLite testing*/
b&&angular.extend(a,b),a.keyCode===S){// tab was pressed
// get caret position/selection
var c=this.selectionStart,d=this.selectionEnd,e=u.val();if(a.shiftKey){
// find \t
var f=e.lastIndexOf("\n",c),g=e.lastIndexOf("\t",c);g!==-1&&g>=f&&(
// set textarea value to: text before caret + tab + text after caret
u.val(e.substring(0,g)+e.substring(g+1)),
// put caret at right position again (add one for the tab)
this.selectionStart=this.selectionEnd=c-1)}else
// set textarea value to: text before caret + tab + text after caret
u.val(e.substring(0,c)+"\t"+e.substring(d)),
// put caret at right position again (add one for the tab)
this.selectionStart=this.selectionEnd=c+1;
// prevent the focus lose
a.preventDefault()}});var ka=function(a,b){for(var c="",d=0;d<b;d++)c+=a;return c},la=function(a,b,c){for(var d=0;d<a.length;d++)b.call(c,d,a[d])},ma=function(a,b){var c="",d=a.childNodes;
// tab out and add the <ul> or <ol> html piece
// now add on the </ol> or </ul> piece
return b++,c+=ka("\t",b-1)+a.outerHTML.substring(0,4),la(d,function(a,d){/* istanbul ignore next: browser catch */
var e=d.nodeName.toLowerCase();/* istanbul ignore next: not tested, and this was original code -- so not wanting to possibly cause an issue, leaving it... */
return"#comment"===e?void(c+="<!--"+d.nodeValue+"-->"):"#text"===e?void(c+=d.textContent):void(d.outerHTML&&(c+="ul"===e||"ol"===e?"\n"+ma(d,b):"\n"+ka("\t",b)+d.outerHTML))}),c+="\n"+ka("\t",b-1)+a.outerHTML.substring(a.outerHTML.lastIndexOf("<"))};
// handle formating of something like:
// <ol><!--First comment-->
//  <li>Test Line 1<!--comment test list 1--></li>
//    <ul><!--comment ul-->
//      <li>Nested Line 1</li>
//        <!--comment between nested lines--><li>Nested Line 2</li>
//    </ul>
//  <li>Test Line 3</li>
// </ol>
C.$formatters.unshift(function(a){
// tabulate the HTML so it looks nicer
//
// first get a list of the nodes...
// we do this by using the element parser...
//
// doing this -- which is simpiler -- breaks our tests...
//var _nodes=angular.element(htmlValue);
var b=angular.element("<div>"+a+"</div>")[0].childNodes;
// do the reformatting of the layout...
return b.length>0&&(a="",la(b,function(b,c){var d=c.nodeName.toLowerCase();/* istanbul ignore next: not tested, and this was original code -- so not wanting to possibly cause an issue, leaving it... */
// we aready have some content, so drop to a new line
// okay a set of list stuff we want to reformat in a nested way
return"#comment"===d?void(a+="<!--"+c.nodeValue+"-->"):"#text"===d?void(a+=c.textContent):void(c.outerHTML&&(a.length>0&&(a+="\n"),a+="ul"===d||"ol"===d?""+ma(c,0):""+c.outerHTML))})),a})}var na,oa=function(a,b){
// emit the drop event, pass the element, preventing should be done elsewhere
if(/* istanbul ignore else: this is for catching the jqLite testing*/
b&&angular.extend(a,b),!t&&!G){t=!0;var d;d=a.originalEvent?a.originalEvent.dataTransfer:a.dataTransfer,f.$emit("ta-drop-event",this,a,d),c(function(){t=!1,aa(void 0,void 0,!0)},100)}},pa=!1;
// changes to the model variable from outside the html/text inputs
C.$render=function(){/* istanbul ignore if: Catches rogue renders, hard to replicate in tests */
if(!pa){pa=!0;
// catch model being null or undefined
var a=C.$viewValue||"";
// if the editor isn't focused it needs to be updated, otherwise it's receiving user input
I||(/* istanbul ignore else: in other cases we don't care */
E&&H&&(
// update while focussed
u.removeClass("placeholder-text"),/* istanbul ignore next: don't know how to test this */
na&&c.cancel(na),na=c(function(){/* istanbul ignore if: Can't be bothered testing this... */
H||(u[0].focus(),h.setSelectionToElementEnd(u.children()[u.children().length-1])),na=void 0},1)),E?(
// blank
ba(
// WYSIWYG Mode
v.placeholder?""===a?A:a:""===a?A:a),
// if in WYSIWYG and readOnly we kill the use of links by clicking
G?u.off("drop",oa):(_(),u.on("drop",oa))):"textarea"!==u[0].tagName.toLowerCase()&&"input"!==u[0].tagName.toLowerCase()?
// make sure the end user can SEE the html code as a display. This is a read-only display element
ba(l(a)):
// only for input and textarea inputs
u.val(a)),E&&v.placeholder&&(""===a?H?u.removeClass("placeholder-text"):u.addClass("placeholder-text"):u.removeClass("placeholder-text")),pa=I=!1}},v.taReadonly&&(
//set initial value
G=f.$eval(v.taReadonly),G?(u.addClass("ta-readonly"),
// we changed to readOnly mode (taReadonly='true')
"textarea"!==u[0].tagName.toLowerCase()&&"input"!==u[0].tagName.toLowerCase()||u.attr("disabled","disabled"),void 0!==u.attr("contenteditable")&&u.attr("contenteditable")&&u.removeAttr("contenteditable")):(u.removeClass("ta-readonly"),
// we changed to NOT readOnly mode (taReadonly='false')
"textarea"===u[0].tagName.toLowerCase()||"input"===u[0].tagName.toLowerCase()?u.removeAttr("disabled"):E&&u.attr("contenteditable","true")),
// taReadonly only has an effect if the taBind element is an input or textarea or has contenteditable='true' on it.
// Otherwise it is readonly by default
f.$watch(v.taReadonly,function(a,b){b!==a&&(a?(u.addClass("ta-readonly"),
// we changed to readOnly mode (taReadonly='true')
"textarea"!==u[0].tagName.toLowerCase()&&"input"!==u[0].tagName.toLowerCase()||u.attr("disabled","disabled"),void 0!==u.attr("contenteditable")&&u.attr("contenteditable")&&u.removeAttr("contenteditable"),
// turn ON selector click handlers
angular.forEach(j,function(a){u.find(a).on("click",$)}),u.off("drop",oa)):(u.removeClass("ta-readonly"),
// we changed to NOT readOnly mode (taReadonly='false')
"textarea"===u[0].tagName.toLowerCase()||"input"===u[0].tagName.toLowerCase()?u.removeAttr("disabled"):E&&u.attr("contenteditable","true"),
// remove the selector click handlers
angular.forEach(j,function(a){u.find(a).off("click",$)}),u.on("drop",oa)),G=a)})),
// Initialise the selectableElements
// if in WYSIWYG and readOnly we kill the use of links by clicking
E&&!G&&(angular.forEach(j,function(a){u.find(a).on("click",$)}),u.on("drop",oa))}}}]);
// this global var is used to prevent multiple fires of the drop event. Needs to be global to the textAngular file.
var t=!1,u=angular.module("textAngular",["ngSanitize","textAngularSetup","textAngular.factories","textAngular.DOM","textAngular.validators","textAngular.taBind"]);//This makes ngSanitize required
return u.config([function(){
// clear taTools variable. Just catches testing and any other time that this config may run multiple times...
angular.forEach(e,function(a,b){delete e[b]})}]),u.directive("textAngular",["$compile","$timeout","taOptions","taSelection","taExecCommand","textAngularManager","$document","$animate","$log","$q","$parse",function(b,c,d,e,f,g,h,i,j,k,l){return{require:"?ngModel",scope:{},restrict:"EA",priority:2,// So we override validators correctly
link:function(m,n,o,p){
// all these vars should not be accessable outside this directive
var q,r,s,t,u,v,w,x,y,z,A,B,C,D=o.serial?o.serial:Math.floor(1e16*Math.random());m._name=o.name?o.name:"textAngularEditor"+D;var E=function(a,b,d){c(function(){
// shim the .one till fixed
var c=function(){a.off(b,c),d.apply(this,arguments)};a.on(b,c)},100)};if(y=f(o.taDefaultWrap),
// get the settings from the defaults and add our specific functions that need to be on the scope
angular.extend(m,angular.copy(d),{
// wraps the selection in the provided tag / execCommand function. Should only be called in WYSIWYG mode.
wrapSelection:function(a,b,c){
// we restore the saved selection that was saved when focus was lost
/* NOT FUNCTIONAL YET */
/* textAngularManager.restoreFocusSelection(scope._name, scope); */
"undo"===a.toLowerCase()?m["$undoTaBindtaTextElement"+D]():"redo"===a.toLowerCase()?m["$redoTaBindtaTextElement"+D]():(
// catch errors like FF erroring when you try to force an undo with nothing done
y(a,!1,b,m.defaultTagAttributes),c&&
// re-apply the selectable tool events
m["reApplyOnSelectorHandlerstaTextElement"+D](),
// refocus on the shown display element, this fixes a display bug when using :focus styles to outline the box.
// You still have focus on the text/html input it just doesn't show up
m.displayElements.text[0].focus())},showHtml:m.$eval(o.taShowHtml)||!1}),
// setup the options from the optional attributes
o.taFocussedClass&&(m.classes.focussed=o.taFocussedClass),o.taTextEditorClass&&(m.classes.textEditor=o.taTextEditorClass),o.taHtmlEditorClass&&(m.classes.htmlEditor=o.taHtmlEditorClass),o.taDefaultTagAttributes)try{
//	TODO: This should use angular.merge to enhance functionality once angular 1.4 is required
angular.extend(m.defaultTagAttributes,angular.fromJson(o.taDefaultTagAttributes))}catch(a){j.error(a)}
// optional setup functions
o.taTextEditorSetup&&(m.setup.textEditorSetup=m.$parent.$eval(o.taTextEditorSetup)),o.taHtmlEditorSetup&&(m.setup.htmlEditorSetup=m.$parent.$eval(o.taHtmlEditorSetup)),
// optional fileDropHandler function
o.taFileDrop?m.fileDropHandler=m.$parent.$eval(o.taFileDrop):m.fileDropHandler=m.defaultFileDropHandler,w=n[0].innerHTML,
// clear the original content
n[0].innerHTML="",
// Setup the HTML elements as variable references for use later
m.displayElements={
// we still need the hidden input even with a textarea as the textarea may have invalid/old input in it,
// wheras the input will ALLWAYS have the correct value.
forminput:angular.element("<input type='hidden' tabindex='-1' style='display: none;'>"),html:angular.element("<textarea></textarea>"),text:angular.element("<div></div>"),
// other toolbased elements
scrollWindow:angular.element("<div class='ta-scroll-window'></div>"),popover:angular.element('<div class="popover fade bottom" style="max-width: none; width: 305px;"></div>'),popoverArrow:angular.element('<div class="arrow"></div>'),popoverContainer:angular.element('<div class="popover-content"></div>'),resize:{overlay:angular.element('<div class="ta-resizer-handle-overlay"></div>'),background:angular.element('<div class="ta-resizer-handle-background"></div>'),anchors:[angular.element('<div class="ta-resizer-handle-corner ta-resizer-handle-corner-tl"></div>'),angular.element('<div class="ta-resizer-handle-corner ta-resizer-handle-corner-tr"></div>'),angular.element('<div class="ta-resizer-handle-corner ta-resizer-handle-corner-bl"></div>'),angular.element('<div class="ta-resizer-handle-corner ta-resizer-handle-corner-br"></div>')],info:angular.element('<div class="ta-resizer-handle-info"></div>')}},
// Setup the popover
m.displayElements.popover.append(m.displayElements.popoverArrow),m.displayElements.popover.append(m.displayElements.popoverContainer),m.displayElements.scrollWindow.append(m.displayElements.popover),m.displayElements.popover.on("mousedown",function(a,b){/* istanbul ignore else: this is for catching the jqLite testing*/
// this prevents focusout from firing on the editor when clicking anything in the popover
return b&&angular.extend(a,b),a.preventDefault(),!1}),/* istanbul ignore next: popover resize and scroll events handled */
m.handlePopoverEvents=function(){"block"===m.displayElements.popover.css("display")&&(B&&c.cancel(B),B=c(function(){
//console.log('resize', scope.displayElements.popover.css('display'));
m.reflowPopover(C),m.reflowResizeOverlay(C)},100))},/* istanbul ignore next: browser resize check */
angular.element(window).on("resize",function(a,b){m.handlePopoverEvents()}),/* istanbul ignore next: browser scroll check */
angular.element(window).on("scroll",function(a,b){m.handlePopoverEvents()});
// we want to know if a given node has a scrollbar!
// credit to lotif on http://stackoverflow.com/questions/4880381/check-whether-html-element-has-scrollbars
var F=function(a){var b,c={vertical:!1,horizontal:!1};try{if(b=window.getComputedStyle(a),null===b)return c}catch(a){/* istanbul ignore next: error handler */
return c}var d=b["overflow-y"],e=b["overflow-x"];return{vertical:("scroll"===d||"auto"===d)&&/* istanbul ignore next: not tested */
a.scrollHeight>a.clientHeight,horizontal:("scroll"===e||"auto"===e)&&/* istanbul ignore next: not tested */
a.scrollWidth>a.clientWidth}};
// getScrollTop
//
// we structure this so that it can climb the parents of the _el and when it finds
// one with scrollbars, it adds an EventListener, so that no matter how the
// DOM is structured in the user APP, if there is a scrollbar not as part of the
// ta-scroll-window, we will still capture the 'scroll' events...
// and handle the scroll event properly and do the resize, etc.
//
m.getScrollTop=function(a,b){var c=a.scrollTop;/* istanbul ignore next: triggered only if has scrollbar and scrolled */
/* istanbul ignore next: triggered only if has scrollbar */
// remove element eventListener
/* istanbul ignore next: triggered only if has scrollbar and scrolled */
/* istanbul ignore else: catches only if no scroll */
return"undefined"==typeof c&&(c=0),b&&F(a).vertical&&(a.removeEventListener("scroll",m._scrollListener,!1),a.addEventListener("scroll",m._scrollListener,!1)),0!==c?{node:a.nodeName,top:c}:a.parentNode?m.getScrollTop(a.parentNode,b):{node:"<none>",top:0}},
// define the popover show and hide functions
m.showPopover=function(a){m.getScrollTop(m.displayElements.scrollWindow[0],!0),m.displayElements.popover.css("display","block"),C=a,m.reflowPopover(a),i.addClass(m.displayElements.popover,"in"),E(h.find("body"),"click keyup",function(){m.hidePopover()})},/* istanbul ignore next: browser scroll event handler */
m._scrollListener=function(a,b){m.handlePopoverEvents()},m.reflowPopover=function(a){var b=m.getScrollTop(m.displayElements.scrollWindow[0],!1),c=a[0].offsetTop-b.top;
//var spaceBelowImage = scope.displayElements.text[0].offsetHeight - _el[0].offsetHeight - spaceAboveImage;
//console.log(spaceAboveImage, spaceBelowImage);
/* istanbul ignore if: catches only if near bottom of editor */
c<51?(m.displayElements.popover.css("top",a[0].offsetTop+a[0].offsetHeight+m.displayElements.scrollWindow[0].scrollTop+"px"),m.displayElements.popover.removeClass("top").addClass("bottom")):(m.displayElements.popover.css("top",a[0].offsetTop-54+m.displayElements.scrollWindow[0].scrollTop+"px"),m.displayElements.popover.removeClass("bottom").addClass("top"));var d=m.displayElements.text[0].offsetWidth-m.displayElements.popover[0].offsetWidth,e=a[0].offsetLeft+a[0].offsetWidth/2-m.displayElements.popover[0].offsetWidth/2,f=Math.max(0,Math.min(d,e)),g=Math.min(e,Math.max(0,e-d))-11;f+=window.scrollX,g-=window.scrollX,m.displayElements.popover.css("left",f+"px"),m.displayElements.popoverArrow.css("margin-left",g+"px")},m.hidePopover=function(){m.displayElements.popover.css("display","none"),m.displayElements.popoverContainer.attr("style",""),m.displayElements.popoverContainer.attr("class","popover-content"),m.displayElements.popover.removeClass("in")},
// setup the resize overlay
m.displayElements.resize.overlay.append(m.displayElements.resize.background),angular.forEach(m.displayElements.resize.anchors,function(a){m.displayElements.resize.overlay.append(a)}),m.displayElements.resize.overlay.append(m.displayElements.resize.info),m.displayElements.scrollWindow.append(m.displayElements.resize.overlay),
// A click event on the resize.background will now shift the focus to the editor
/* istanbul ignore next: click on the resize.background to focus back to editor */
m.displayElements.resize.background.on("click",function(a){m.displayElements.text[0].focus()}),
// define the show and hide events
m.reflowResizeOverlay=function(a){a=angular.element(a)[0],m.displayElements.resize.overlay.css({display:"block",left:a.offsetLeft-5+"px",top:a.offsetTop-5+"px",width:a.offsetWidth+10+"px",height:a.offsetHeight+10+"px"}),m.displayElements.resize.info.text(a.offsetWidth+" x "+a.offsetHeight)},/* istanbul ignore next: pretty sure phantomjs won't test this */
m.showResizeOverlay=function(a){var b=h.find("body");z=function(c){var d={width:parseInt(a.attr("width")),height:parseInt(a.attr("height")),x:c.clientX,y:c.clientY};(void 0===d.width||isNaN(d.width))&&(d.width=a[0].offsetWidth),(void 0===d.height||isNaN(d.height))&&(d.height=a[0].offsetHeight),m.hidePopover();var e=d.height/d.width,f=function(b){function c(a){return Math.round(Math.max(0,a))}
// calculate new size
var f={x:Math.max(0,d.width+(b.clientX-d.x)),y:Math.max(0,d.height+(b.clientY-d.y))},g=void 0!==o.taResizeForceAspectRatio,h=o.taResizeMaintainAspectRatio,i=g||h&&!b.shiftKey;if(i){var j=f.y/f.x;f.x=e>j?f.x:f.y/e,f.y=e>j?f.x*e:f.y}var k=angular.element(a);k.css("height",c(f.y)+"px"),k.css("width",c(f.x)+"px"),
// reflow the popover tooltip
m.reflowResizeOverlay(a)};b.on("mousemove",f),E(b,"mouseup",function(a){a.preventDefault(),a.stopPropagation(),b.off("mousemove",f),
// at this point, we need to force the model to update! since the css has changed!
// this fixes bug: #862 - we now hide the popover -- as this seems more consitent.
// there are still issues under firefox, the window does not repaint. -- not sure
// how best to resolve this, but clicking anywhere works.
m.$apply(function(){m.hidePopover(),m.updateTaBindtaTextElement()},100)}),c.stopPropagation(),c.preventDefault()},m.displayElements.resize.anchors[3].off("mousedown"),m.displayElements.resize.anchors[3].on("mousedown",z),m.reflowResizeOverlay(a),E(b,"click",function(){m.hideResizeOverlay()})},/* istanbul ignore next: pretty sure phantomjs won't test this */
m.hideResizeOverlay=function(){m.displayElements.resize.anchors[3].off("mousedown",z),m.displayElements.resize.overlay.css("display","none")},
// allow for insertion of custom directives on the textarea and div
m.setup.htmlEditorSetup(m.displayElements.html),m.setup.textEditorSetup(m.displayElements.text),m.displayElements.html.attr({id:"taHtmlElement"+D,"ng-show":"showHtml","ta-bind":"ta-bind","ng-model":"html","ng-model-options":n.attr("ng-model-options")}),m.displayElements.text.attr({id:"taTextElement"+D,contentEditable:"true","ta-bind":"ta-bind","ng-model":"html","ng-model-options":n.attr("ng-model-options")}),m.displayElements.scrollWindow.attr({"ng-hide":"showHtml"}),o.taDefaultWrap&&
// taDefaultWrap is only applied to the text and not the html view
m.displayElements.text.attr("ta-default-wrap",o.taDefaultWrap),o.taUnsafeSanitizer&&(m.displayElements.text.attr("ta-unsafe-sanitizer",o.taUnsafeSanitizer),m.displayElements.html.attr("ta-unsafe-sanitizer",o.taUnsafeSanitizer)),
// add the main elements to the origional element
m.displayElements.scrollWindow.append(m.displayElements.text),n.append(m.displayElements.scrollWindow),n.append(m.displayElements.html),m.displayElements.forminput.attr("name",m._name),n.append(m.displayElements.forminput),o.tabindex&&(n.removeAttr("tabindex"),m.displayElements.text.attr("tabindex",o.tabindex),m.displayElements.html.attr("tabindex",o.tabindex)),o.placeholder&&(m.displayElements.text.attr("placeholder",o.placeholder),m.displayElements.html.attr("placeholder",o.placeholder)),o.taDisabled&&(m.displayElements.text.attr("ta-readonly","disabled"),m.displayElements.html.attr("ta-readonly","disabled"),m.disabled=m.$parent.$eval(o.taDisabled),m.$parent.$watch(o.taDisabled,function(a){m.disabled=a,m.disabled?n.addClass(m.classes.disabled):n.removeClass(m.classes.disabled)})),o.taPaste&&(m._pasteHandler=function(a){return l(o.taPaste)(m.$parent,{$html:a})},m.displayElements.text.attr("ta-paste","_pasteHandler($html)")),
// compile the scope with the text and html elements only - if we do this with the main element it causes a compile loop
b(m.displayElements.scrollWindow)(m),b(m.displayElements.html)(m),m.updateTaBindtaTextElement=m["updateTaBindtaTextElement"+D],m.updateTaBindtaHtmlElement=m["updateTaBindtaHtmlElement"+D],
// add the classes manually last
n.addClass("ta-root"),m.displayElements.scrollWindow.addClass("ta-text ta-editor "+m.classes.textEditor),m.displayElements.html.addClass("ta-html ta-editor "+m.classes.htmlEditor);var G=function(a,b){/* istanbul ignore next: this is only here because of a bug in rangy where rangy.saveSelection() has cleared the state */
b!==h[0].queryCommandState(a)&&h[0].execCommand(a,!1,null)};
// used in the toolbar actions
m._actionRunning=!1;var H=!1;
// changes to the model variable from outside the html/text inputs
// if no ngModel, then the only input is from inside text-angular
if(m.startAction=function(){var b=!1,c=!1,d=!1,e=!1;
//console.log('B', $document[0].queryCommandState('bold'), 'I', $document[0].queryCommandState('italic'), '_', $document[0].queryCommandState('underline'), 'S', $document[0].queryCommandState('strikeThrough') );
//console.log('B', _beforeStateBold, 'I', _beforeStateItalic, '_', _beforeStateUnderline, 'S', _beforeStateStrikethough);
// if rangy library is loaded return a function to reload the current selection
// rangy.saveSelection() clear the state of bold, italic, underline, strikethrough
// so we reset them here....!!!
// this fixes bugs #423, #1129, #1105, #693 which are actually rangy bugs!
return m._actionRunning=!0,b=h[0].queryCommandState("bold"),c=h[0].queryCommandState("italic"),d=h[0].queryCommandState("underline"),e=h[0].queryCommandState("strikeThrough"),H=a.saveSelection(),G("bold",b),G("italic",c),G("underline",d),G("strikeThrough",e),function(){H&&a.restoreSelection(H)}},m.endAction=function(){m._actionRunning=!1,H&&(m.showHtml?m.displayElements.html[0].focus():m.displayElements.text[0].focus(),
// rangy.restoreSelection(_savedSelection);
a.removeMarkers(H)),H=!1,m.updateSelectedStyles(),
// only update if in text or WYSIWYG mode
m.showHtml||m["updateTaBindtaTextElement"+D]()},
// note that focusout > focusin is called everytime we click a button - except bad support: http://www.quirksmode.org/dom/events/blurfocus.html
// cascades to displayElements.text and displayElements.html automatically.
u=function(a){m.focussed=!0,n.addClass(m.classes.focussed),/*******  NOT FUNCTIONAL YET
					if (e.target.id === 'taTextElement' + _serial) {
						console.log('_focusin taTextElement');
						// we only do this if NOT focussed
						textAngularManager.restoreFocusSelection(scope._name);
					}
*******/
x.focus(),n.triggerHandler("focus"),
// we call editorScope.updateSelectedStyles() here because we want the toolbar to be focussed
// as soon as we have focus.  Otherwise this only happens on mousedown or keydown etc...
/* istanbul ignore else: don't run if already running */
m.updateSelectedStyles&&!m._bUpdateSelectedStyles&&
// we don't set editorScope._bUpdateSelectedStyles here, because we do not want the
// updateSelectedStyles() to run twice which it will do after 200 msec if we have
// set editorScope._bUpdateSelectedStyles
//
// WOW, normally I would do a scope.$apply here, but this causes ERRORs when doing tests!
c(function(){m.updateSelectedStyles()},0)},m.displayElements.html.on("focus",u),m.displayElements.text.on("focus",u),v=function(a){/****************** NOT FUNCTIONAL YET
					try {
						var _s = rangy.getSelection();
						if (_s) {
							// we save the selection when we loose focus so that if do a wrapSelection, the
							// apropriate selection in the editor is restored before action.
							var _savedFocusRange = rangy.saveRange(_s.getRangeAt(0));
							textAngularManager.saveFocusSelection(scope._name, _savedFocusRange);
						}
					} catch(error) { }
					*****************/
// if we are NOT runnig an action and have NOT focussed again on the text etc then fire the blur events
// to prevent multiple apply error defer to next seems to work.
return m._actionRunning||h[0].activeElement===m.displayElements.html[0]||h[0].activeElement===m.displayElements.text[0]||(n.removeClass(m.classes.focussed),x.unfocus(),c(function(){m._bUpdateSelectedStyles=!1,n.triggerHandler("blur"),m.focussed=!1},0)),a.preventDefault(),!1},m.displayElements.html.on("blur",v),m.displayElements.text.on("blur",v),m.displayElements.text.on("paste",function(a){n.triggerHandler("paste",a)}),
// Setup the default toolbar tools, this way allows the user to add new tools like plugins.
// This is on the editor for future proofing if we find a better way to do this.
m.queryFormatBlockState=function(a){
// $document[0].queryCommandValue('formatBlock') errors in Firefox if we call this when focussed on the textarea
return!m.showHtml&&a.toLowerCase()===h[0].queryCommandValue("formatBlock").toLowerCase()},m.queryCommandState=function(a){
// $document[0].queryCommandValue('formatBlock') errors in Firefox if we call this when focussed on the textarea
return m.showHtml?"":h[0].queryCommandState(a)},m.switchView=function(){m.showHtml=!m.showHtml,i.enabled(!1,m.displayElements.html),i.enabled(!1,m.displayElements.text),
//Show the HTML view
/* istanbul ignore next: ngModel exists check */
/* THIS is not the correct thing to do, here....
   The ngModel is correct, but it is not formatted as the user as done it...
					var _model;
					if (ngModel) {
						_model = ngModel.$viewValue;
					} else {
						_model = scope.html;
					}
					var _html = scope.displayElements.html[0].value;
					if (getDomFromHtml(_html).childElementCount !== getDomFromHtml(_model).childElementCount) {
						// the model and the html do not agree
						// they can get out of sync and when they do, we correct that here...
						scope.displayElements.html.val(_model);
					}
*/
m.showHtml?
//defer until the element is visible
c(function(){
// [0] dereferences the DOM object from the angular.element
return i.enabled(!0,m.displayElements.html),i.enabled(!0,m.displayElements.text),m.displayElements.html[0].focus()},100):
//Show the WYSIWYG view
//defer until the element is visible
c(function(){
// [0] dereferences the DOM object from the angular.element
return i.enabled(!0,m.displayElements.html),i.enabled(!0,m.displayElements.text),m.displayElements.text[0].focus()},100)},o.ngModel){var I=!0;p.$render=function(){if(I){
// we need this firstRun to set the originalContents otherwise it gets overrided by the setting of ngModel to undefined from NaN
I=!1;
// if view value is null or undefined initially and there was original content, set to the original content
var a=m.$parent.$eval(o.ngModel);void 0!==a&&null!==a||!w||""===w||
// on passing through to taBind it will be sanitised
p.$setViewValue(w)}m.displayElements.forminput.val(p.$viewValue),
// if the editors aren't focused they need to be updated, otherwise they are doing the updating
m.html=p.$viewValue||""},
// trigger the validation calls
n.attr("required")&&(p.$validators.required=function(a,b){var c=a||b;return!(!c||""===c.trim())})}else
// if no ngModel then update from the contents of the origional html.
m.displayElements.forminput.val(w),m.html=w;if(
// changes from taBind back up to here
m.$watch("html",function(a,b){a!==b&&(o.ngModel&&p.$viewValue!==a&&p.$setViewValue(a),m.displayElements.forminput.val(a))}),o.taTargetToolbars)x=g.registerEditor(m._name,m,o.taTargetToolbars.split(","));else{var J=angular.element('<div text-angular-toolbar name="textAngularToolbar'+D+'">');
// passthrough init of toolbar options
o.taToolbar&&J.attr("ta-toolbar",o.taToolbar),o.taToolbarClass&&J.attr("ta-toolbar-class",o.taToolbarClass),o.taToolbarGroupClass&&J.attr("ta-toolbar-group-class",o.taToolbarGroupClass),o.taToolbarButtonClass&&J.attr("ta-toolbar-button-class",o.taToolbarButtonClass),o.taToolbarActiveButtonClass&&J.attr("ta-toolbar-active-button-class",o.taToolbarActiveButtonClass),o.taFocussedClass&&J.attr("ta-focussed-class",o.taFocussedClass),n.prepend(J),b(J)(m.$parent),x=g.registerEditor(m._name,m,["textAngularToolbar"+D])}m.$on("$destroy",function(){g.unregisterEditor(m._name),angular.element(window).off("blur")}),
// catch element select event and pass to toolbar tools
m.$on("ta-element-select",function(a,b){x.triggerElementSelect(a,b)&&m["reApplyOnSelectorHandlerstaTextElement"+D]()}),m.$on("ta-drop-event",function(a,b,d,e){e&&e.files&&e.files.length>0?(m.displayElements.text[0].focus(),angular.forEach(e.files,function(a){
// taking advantage of boolean execution, if the fileDropHandler returns true, nothing else after it is executed
// If it is false then execute the defaultFileDropHandler if the fileDropHandler is NOT the default one
// Once one of these has been executed wrap the result as a promise, if undefined or variable update the taBind, else we should wait for the promise
try{k.when(m.fileDropHandler(a,m.wrapSelection)||m.fileDropHandler!==m.defaultFileDropHandler&&k.when(m.defaultFileDropHandler(a,m.wrapSelection))).then(function(){m["updateTaBindtaTextElement"+D]()})}catch(a){j.error(a)}}),d.preventDefault(),d.stopPropagation()):c(function(){m["updateTaBindtaTextElement"+D]()},0)}),
// the following is for applying the active states to the tools that support it
m._bUpdateSelectedStyles=!1,/* istanbul ignore next: browser window/tab leave check */
angular.element(window).on("blur",function(){m._bUpdateSelectedStyles=!1,m.focussed=!1}),
// loop through all the tools polling their activeState function if it exists
m.updateSelectedStyles=function(){var a;/* istanbul ignore next: This check is to ensure multiple timeouts don't exist */
A&&c.cancel(A),
// test if the common element ISN'T the root ta-text node
void 0!==(a=e.getSelectionElement())&&a.parentNode!==m.displayElements.text[0]?x.updateSelectedStyles(angular.element(a)):x.updateSelectedStyles(),
// used to update the active state when a key is held down, ie the left arrow
/* istanbul ignore else: browser only check */
m._bUpdateSelectedStyles&&(A=c(m.updateSelectedStyles,200))},
// start updating on keydown
q=function(){/* istanbul ignore next: ie catch */
/* istanbul ignore next: ie catch */
/* istanbul ignore else: don't run if already running */
return m.focussed?void(m._bUpdateSelectedStyles||(m._bUpdateSelectedStyles=!0,m.$apply(function(){m.updateSelectedStyles()}))):void(m._bUpdateSelectedStyles=!1)},m.displayElements.html.on("keydown",q),m.displayElements.text.on("keydown",q),
// stop updating on key up and update the display/model
r=function(){m._bUpdateSelectedStyles=!1},m.displayElements.html.on("keyup",r),m.displayElements.text.on("keyup",r),
// stop updating on key up and update the display/model
s=function(a,b){
// bug fix for Firefox.  If we are selecting a <a> already, any characters will
// be added within the <a> which is bad!
/* istanbul ignore next: don't see how to test this... */
if(e.getSelection){var c=e.getSelection();
// in a weird case (can't reproduce) taSelection.getSelectionElement() can be undefined!!
// this comes from range.commonAncestorContainer;
// so I check for this here which fixes the error case
e.getSelectionElement()&&"a"===e.getSelectionElement().nodeName.toLowerCase()&&(
// check and see if we are at the edge of the <a>
3===c.start.element.nodeType&&c.start.element.textContent.length===c.end.offset&&
// we are at the end of the <a>!!!
// so move the selection to after the <a>!!
e.setSelectionAfterElement(e.getSelectionElement()),3===c.start.element.nodeType&&0===c.start.offset&&
// we are at the start of the <a>!!!
// so move the selection before the <a>!!
e.setSelectionBeforeElement(e.getSelectionElement()))}/* istanbul ignore else: this is for catching the jqLite testing*/
b&&angular.extend(a,b),m.$apply(function(){if(x.sendKeyCommand(a))/* istanbul ignore else: don't run if already running */
return m._bUpdateSelectedStyles||m.updateSelectedStyles(),a.preventDefault(),!1})},m.displayElements.html.on("keypress",s),m.displayElements.text.on("keypress",s),
// update the toolbar active states when we click somewhere in the text/html boxed
t=function(){
// ensure only one execution of updateSelectedStyles()
m._bUpdateSelectedStyles=!1,
// for some reason, unless we do a $timeout here, after a _mouseup when the line is
// highlighted, and instead use a scope.$apply(function(){ scope.updateSelectedStyles(); });
// doesn't work properly, so we replaced this with:
/* istanbul ignore next: not tested  */
c(function(){m.updateSelectedStyles()},0)},m.displayElements.html.on("mouseup",t),m.displayElements.text.on("mouseup",t)}}}]),u.service("textAngularManager",["taToolExecuteAction","taTools","taRegisterTool","$interval","$rootScope","$log",function(a,b,c,d,e,g){
// this service is used to manage all textAngular editors and toolbars.
// All publicly published functions that modify/need to access the toolbar or editor scopes should be in here
// these contain references to all the editors and toolbars that have been initialised in this app
var h,i={},j={},k=0,l=function(a){angular.forEach(j,function(b){b.editorFunctions.updateSelectedStyles(a)})},m=50,n=function(){k=Date.now(),/* istanbul ignore next: setup a one time updateStyles() */
h=d(function(){l(),h=void 0},m,1)};/* istanbul ignore next: make sure clean up on destroy */
e.$on("destroy",function(){h&&(d.cancel(h),h=void 0)});var o=function(){Math.abs(Date.now()-k)>m&&
// we have already triggered the updateStyles a long time back... so setup it again...
n()};
// when we focus into a toolbar, we need to set the TOOLBAR's $parent to be the toolbars it's linked to.
// We also need to set the tools to be updated to be the toolbars...
return{
// register an editor and the toolbars that it is affected by
registerEditor:function(c,d,e){
// NOTE: name === editorScope._name
// targetToolbars is an [] of 'toolbar name's
// targetToolbars are optional, we don't require a toolbar to function
if(!c||""===c)throw"textAngular Error: An editor requires a name";if(!d)throw"textAngular Error: An editor requires a scope";if(j[c])throw'textAngular Error: An Editor with name "'+c+'" already exists';return j[c]={scope:d,toolbars:e,
// toolbarScopes used by this editor
toolbarScopes:[],_registerToolbarScope:function(a){
// add to the list late
this.toolbars.indexOf(a.name)>=0&&
// if this toolbarScope is being used by this editor we add it as one of the scopes
this.toolbarScopes.push(a)},
// this is a suite of functions the editor should use to update all it's linked toolbars
editorFunctions:{disable:function(){
// disable all linked toolbars
angular.forEach(j[c].toolbarScopes,function(a){a.disabled=!0})},enable:function(){
// enable all linked toolbars
angular.forEach(j[c].toolbarScopes,function(a){a.disabled=!1})},focus:function(){
// this should be called when the editor is focussed
angular.forEach(j[c].toolbarScopes,function(a){a._parent=d,a.disabled=!1,a.focussed=!0}),d.focussed=!0},unfocus:function(){
// this should be called when the editor becomes unfocussed
angular.forEach(j[c].toolbarScopes,function(a){a.disabled=!0,a.focussed=!1}),d.focussed=!1},updateSelectedStyles:function(a){
// update the active state of all buttons on liked toolbars
angular.forEach(j[c].toolbarScopes,function(b){angular.forEach(b.tools,function(c){c.activeState&&(b._parent=d,
// selectedElement may be undefined if nothing selected
c.active=c.activeState(a))})})},sendKeyCommand:function(e){
// we return true if we applied an action, false otherwise
var f=!1;return(e.ctrlKey||e.metaKey||e.specialKey)&&angular.forEach(b,function(b,g){if(b.commandKeyCode&&(b.commandKeyCode===e.which||b.commandKeyCode===e.specialKey))for(var h=0;h<j[c].toolbarScopes.length;h++)if(void 0!==j[c].toolbarScopes[h].tools[g]){a.call(j[c].toolbarScopes[h].tools[g],d),f=!0;break}}),f},triggerElementSelect:function(a,e){
// search through the taTools to see if a match for the tag is made.
// if there is, see if the tool is on a registered toolbar and not disabled.
// NOTE: This can trigger on MULTIPLE tools simultaneously.
var f=function(a,b){for(var c=!0,d=0;d<b.length;d++)c=c&&a.attr(b[d]);return c},g=[],h={},i=!1;e=angular.element(e);
// get all valid tools by element name, keep track if one matches the
var k=!1;
// Run the actions on the first visible filtered tool only
if(angular.forEach(b,function(a,b){a.onElementSelect&&a.onElementSelect.element&&a.onElementSelect.element.toLowerCase()===e[0].tagName.toLowerCase()&&(!a.onElementSelect.filter||a.onElementSelect.filter(e))&&(
// this should only end up true if the element matches the only attributes
k=k||angular.isArray(a.onElementSelect.onlyWithAttrs)&&f(e,a.onElementSelect.onlyWithAttrs),a.onElementSelect.onlyWithAttrs&&!f(e,a.onElementSelect.onlyWithAttrs)||(h[b]=a))}),
// if we matched attributes to filter on, then filter, else continue
k?(angular.forEach(h,function(a,b){a.onElementSelect.onlyWithAttrs&&f(e,a.onElementSelect.onlyWithAttrs)&&g.push({name:b,tool:a})}),
// sort most specific (most attrs to find) first
g.sort(function(a,b){return b.tool.onElementSelect.onlyWithAttrs.length-a.tool.onElementSelect.onlyWithAttrs.length})):angular.forEach(h,function(a,b){g.push({name:b,tool:a})}),g.length>0)for(var l=0;l<g.length;l++){for(var m=g[l].tool,n=g[l].name,o=0;o<j[c].toolbarScopes.length;o++)if(void 0!==j[c].toolbarScopes[o].tools[n]){m.onElementSelect.action.call(j[c].toolbarScopes[o].tools[n],a,e,d),i=!0;break}if(i)break}return i}}},angular.forEach(e,function(a){i[a]&&j[c].toolbarScopes.push(i[a])}),o(),j[c].editorFunctions},
// retrieve editor by name, largely used by testing suites only
retrieveEditor:function(a){return j[a]},unregisterEditor:function(a){delete j[a],o()},
// registers a toolbar such that it can be linked to editors
registerToolbar:function(a){if(!a)throw"textAngular Error: A toolbar requires a scope";if(!a.name||""===a.name)throw"textAngular Error: A toolbar requires a name";if(i[a.name])throw'textAngular Error: A toolbar with name "'+a.name+'" already exists';i[a.name]=a,
// walk all the editors and connect this toolbarScope to the editors.... if we need to.  This way, it does
// not matter if we register the editors after the toolbars or not
// Note the editor will ignore this toolbarScope if it is not connected to it...
angular.forEach(j,function(b){b._registerToolbarScope(a)}),o()},
// retrieve toolbar by name, largely used by testing suites only
retrieveToolbar:function(a){return i[a]},
// retrieve toolbars by editor name, largely used by testing suites only
retrieveToolbarsViaEditor:function(a){var b=[],c=this;return angular.forEach(this.retrieveEditor(a).toolbars,function(a){b.push(c.retrieveToolbar(a))}),b},unregisterToolbar:function(a){delete i[a],o()},
// functions for updating the toolbar buttons display
updateToolsDisplay:function(a){
// pass a partial struct of the taTools, this allows us to update the tools on the fly, will not change the defaults.
var b=this;angular.forEach(a,function(a,c){b.updateToolDisplay(c,a)})},
// this function resets all toolbars to their default tool definitions
resetToolsDisplay:function(){var a=this;angular.forEach(b,function(b,c){a.resetToolDisplay(c)}),o()},
// update a tool on all toolbars
updateToolDisplay:function(a,b){var c=this;angular.forEach(i,function(d,e){c.updateToolbarToolDisplay(e,a,b)}),o()},
// resets a tool to the default/starting state on all toolbars
resetToolDisplay:function(a){var b=this;angular.forEach(i,function(c,d){b.resetToolbarToolDisplay(d,a)}),o()},
// update a tool on a specific toolbar
updateToolbarToolDisplay:function(a,b,c){if(!i[a])throw'textAngular Error: No Toolbar with name "'+a+'" exists';i[a].updateToolDisplay(b,c)},
// reset a tool on a specific toolbar to it's default starting value
resetToolbarToolDisplay:function(a,c){if(!i[a])throw'textAngular Error: No Toolbar with name "'+a+'" exists';i[a].updateToolDisplay(c,b[c],!0)},
// removes a tool from all toolbars and it's definition
removeTool:function(a){delete b[a],angular.forEach(i,function(b){delete b.tools[a];for(var c=0;c<b.toolbar.length;c++){for(var d,e=0;e<b.toolbar[c].length;e++){if(b.toolbar[c][e]===a){d={group:c,index:e};break}if(void 0!==d)break}void 0!==d&&(b.toolbar[d.group].slice(d.index,1),b._$element.children().eq(d.group).children().eq(d.index).remove())}}),o()},
// toolkey, toolDefinition are required. If group is not specified will pick the last group, if index isnt defined will append to group
addTool:function(a,b,d,e){c(a,b),angular.forEach(i,function(c){c.addTool(a,b,d,e)}),o()},
// adds a Tool but only to one toolbar not all
addToolToToolbar:function(a,b,d,e,f){c(a,b),i[d].addTool(a,b,e,f),o()},
// this is used when externally the html of an editor has been changed and textAngular needs to be notified to update the model.
// this will call a $digest if not already happening
refreshEditor:function(a){if(!j[a])throw'textAngular Error: No Editor with name "'+a+'" exists';j[a].scope.updateTaBindtaTextElement(),/* istanbul ignore else: phase catch */
j[a].scope.$$phase||j[a].scope.$digest(),o()},
// this is used by taBind to send a key command in response to a special key event
sendKeyCommand:function(a,b){var c=j[a._name];/* istanbul ignore else: if nothing to do, do nothing */
if(c&&c.editorFunctions.sendKeyCommand(b))/* istanbul ignore else: don't run if already running */
return a._bUpdateSelectedStyles||a.updateSelectedStyles(),b.preventDefault(),!1},
//
// When a toolbar and tools are created, it isn't until there is a key event or mouse event
// that the updateSelectedStyles() is called behind the scenes.
// This function forces an update through the existing editors to help the application make sure
// the inital state is correct.
//
updateStyles:l,
// return the current version of textAngular in use to the user
getVersion:function(){return f},
// for testing
getToolbarScopes:function(){var a=[];return angular.forEach(j,function(b){a=a.concat(b.toolbarScopes)}),a}}}]),u.directive("textAngularToolbar",["$compile","textAngularManager","taOptions","taTools","taToolExecuteAction","$window",function(a,b,c,d,e,f){return{scope:{name:"@"},restrict:"EA",link:function(g,h,i){if(!g.name||""===g.name)throw"textAngular Error: A toolbar requires a name";angular.extend(g,angular.copy(c)),i.taToolbar&&(g.toolbar=g.$parent.$eval(i.taToolbar)),i.taToolbarClass&&(g.classes.toolbar=i.taToolbarClass),i.taToolbarGroupClass&&(g.classes.toolbarGroup=i.taToolbarGroupClass),i.taToolbarButtonClass&&(g.classes.toolbarButton=i.taToolbarButtonClass),i.taToolbarActiveButtonClass&&(g.classes.toolbarButtonActive=i.taToolbarActiveButtonClass),i.taFocussedClass&&(g.classes.focussed=i.taFocussedClass),g.disabled=!0,g.focussed=!1,g._$element=h,h[0].innerHTML="",h.addClass("ta-toolbar "+g.classes.toolbar),g.$watch("focussed",function(){g.focussed?h.addClass(g.classes.focussed):h.removeClass(g.classes.focussed)});var j=function(b,c){var d;if(d=b&&b.display?angular.element(b.display):angular.element("<button type='button'>"),b&&b.class?d.addClass(b.class):d.addClass(g.classes.toolbarButton),d.attr("name",c.name),
// important to not take focus from the main text/html entry
d.attr("ta-button","ta-button"),d.attr("ng-disabled","isDisabled()"),d.attr("tabindex","-1"),d.attr("ng-click","executeAction()"),d.attr("ng-class","displayActiveToolClass(active)"),b&&b.tooltiptext&&d.attr("title",b.tooltiptext),b&&!b.display&&!c._display&&(
// first clear out the current contents if any
d[0].innerHTML="",
// add the buttonText
b.buttontext&&(d[0].innerHTML=b.buttontext),b.iconclass)){var e=angular.element("<i>"),f=d[0].innerHTML;e.addClass(b.iconclass),d[0].innerHTML="",d.append(e),f&&""!==f&&d.append("&nbsp;"+f)}return c._lastToolDefinition=angular.copy(b),a(d)(c)};
// Keep a reference for updating the active states later
g.tools={},
// create the tools in the toolbar
// default functions and values to prevent errors in testing and on init
g._parent={disabled:!0,showHtml:!1,queryFormatBlockState:function(){return!1},queryCommandState:function(){return!1}};var k={$window:f,$editor:function(){
// dynamically gets the editor as it is set
return g._parent},isDisabled:function(){
// view selection button is always enabled since it doesn not depend on a selction!
// view selection button is always enabled since it doesn not depend on a selction!
// this bracket is important as without it it just returns the first bracket and ignores the rest
// when the button's disabled function/value evaluates to true
// all buttons except the HTML Switch button should be disabled in the showHtml (RAW html) mode
// if the toolbar is disabled
// if the current editor is disabled
return("html"!==this.name||!g._parent.startAction)&&("function"!=typeof this.$eval("disabled")&&this.$eval("disabled")||this.$eval("disabled()")||"html"!==this.name&&this.$editor().showHtml||this.$parent.disabled||this.$editor().disabled)},displayActiveToolClass:function(a){return a?g.classes.toolbarButtonActive:""},executeAction:e};angular.forEach(g.toolbar,function(a){
// setup the toolbar group
var b=angular.element("<div>");b.addClass(g.classes.toolbarGroup),angular.forEach(a,function(a){
// init and add the tools to the group
// a tool name (key name from taTools struct)
//creates a child scope of the main angularText scope and then extends the childScope with the functions of this particular tool
// reference to the scope and element kept
g.tools[a]=angular.extend(g.$new(!0),d[a],k,{name:a}),g.tools[a].$element=j(d[a],g.tools[a]),
// append the tool compiled with the childScope to the group element
b.append(g.tools[a].$element)}),
// append the group to the toolbar
h.append(b)}),
// update a tool
// if a value is set to null, remove from the display
// when forceNew is set to true it will ignore all previous settings, used to reset to taTools definition
// to reset to defaults pass in taTools[key] as _newTool and forceNew as true, ie `updateToolDisplay(key, taTools[key], true);`
g.updateToolDisplay=function(a,b,c){var d=g.tools[a];if(d){if(
// get the last toolDefinition, then override with the new definition
d._lastToolDefinition&&!c&&(b=angular.extend({},d._lastToolDefinition,b)),null===b.buttontext&&null===b.iconclass&&null===b.display)throw'textAngular Error: Tool Definition for updating "'+a+'" does not have a valid display/iconclass/buttontext value';
// if tool is defined on this toolbar, update/redo the tool
null===b.buttontext&&delete b.buttontext,null===b.iconclass&&delete b.iconclass,null===b.display&&delete b.display;var e=j(b,d);d.$element.replaceWith(e),d.$element=e}},
// we assume here that all values passed are valid and correct
g.addTool=function(a,b,c,e){g.tools[a]=angular.extend(g.$new(!0),d[a],k,{name:a}),g.tools[a].$element=j(d[a],g.tools[a]);var f;void 0===c&&(c=g.toolbar.length-1),f=angular.element(h.children()[c]),void 0===e?(f.append(g.tools[a].$element),g.toolbar[c][g.toolbar[c].length-1]=a):(f.children().eq(e).after(g.tools[a].$element),g.toolbar[c][e]=a)},b.registerToolbar(g),g.$on("$destroy",function(){b.unregisterToolbar(g.name)})}}}]),u.directive("textAngularVersion",["textAngularManager",function(a){var b=a.getVersion();return{restrict:"EA",link:function(a,c,d){c.html(b)}}}]),u.name});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwic291cmNlcyI6WyJ0ZXh0QW5ndWxhci5taW4uanMiXSwic291cmNlc0NvbnRlbnQiOlsiIWZ1bmN0aW9uKGEsYil7XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP1xyXG4vLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUgdW5sZXNzIGFtZE1vZHVsZUlkIGlzIHNldFxyXG5kZWZpbmUoXCJ0ZXh0QW5ndWxhclwiLFtcInJhbmd5XCIsXCJyYW5neS9saWIvcmFuZ3ktc2VsZWN0aW9uc2F2ZXJlc3RvcmVcIl0sZnVuY3Rpb24oYyxkKXtyZXR1cm4gYVtcInRleHRBbmd1bGFyLm5hbWVcIl09YihjLGQpfSk6XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHM/XHJcbi8vIE5vZGUuIERvZXMgbm90IHdvcmsgd2l0aCBzdHJpY3QgQ29tbW9uSlMsIGJ1dFxyXG4vLyBvbmx5IENvbW1vbkpTLWxpa2UgZW52aXJvbm1lbnRzIHRoYXQgc3VwcG9ydCBtb2R1bGUuZXhwb3J0cyxcclxuLy8gbGlrZSBOb2RlLlxyXG5tb2R1bGUuZXhwb3J0cz1iKHJlcXVpcmUoXCJyYW5neVwiKSxyZXF1aXJlKFwicmFuZ3kvbGliL3Jhbmd5LXNlbGVjdGlvbnNhdmVyZXN0b3JlXCIpKTphLnRleHRBbmd1bGFyPWIocmFuZ3kpfSh0aGlzLGZ1bmN0aW9uKGEpe1xyXG4vLyB0ZXN0cyBhZ2FpbnN0IHRoZSBjdXJyZW50IGpxTGl0ZS9qcXVlcnkgaW1wbGVtZW50YXRpb24gaWYgdGhpcyBjYW4gYmUgYW4gZWxlbWVudFxyXG5mdW5jdGlvbiBiKGEpe3RyeXtyZXR1cm4gMCE9PWFuZ3VsYXIuZWxlbWVudChhKS5sZW5ndGh9Y2F0Y2goYSl7cmV0dXJuITF9fS8qXHJcblx0QSB0b29sIGRlZmluaXRpb24gaXMgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBrZXkvdmFsdWUgcGFyYW1ldGVyczpcclxuXHRcdGFjdGlvbjogW2Z1bmN0aW9uKGRlZmVycmVkLCByZXN0b3JlU2VsZWN0aW9uKV1cclxuXHRcdFx0XHRhIGZ1bmN0aW9uIHRoYXQgaXMgZXhlY3V0ZWQgb24gY2xpY2tpbmcgb24gdGhlIGJ1dHRvbiAtIHRoaXMgd2lsbCBhbGx3YXlzIGJlIGV4ZWN1dGVkIHVzaW5nIG5nLWNsaWNrIGFuZCB3aWxsXHJcblx0XHRcdFx0b3ZlcndyaXRlIGFueSBuZy1jbGljayB2YWx1ZSBpbiB0aGUgZGlzcGxheSBhdHRyaWJ1dGUuXHJcblx0XHRcdFx0VGhlIGZ1bmN0aW9uIGlzIHBhc3NlZCBhIGRlZmVycmVkIG9iamVjdCAoJHEuZGVmZXIoKSksIGlmIHRoaXMgaXMgd2FudGVkIHRvIGJlIHVzZWQgYHJldHVybiBmYWxzZTtgIGZyb20gdGhlIGFjdGlvbiBhbmRcclxuXHRcdFx0XHRtYW51YWxseSBjYWxsIGBkZWZlcnJlZC5yZXNvbHZlKCk7YCBlbHNld2hlcmUgdG8gbm90aWZ5IHRoZSBlZGl0b3IgdGhhdCB0aGUgYWN0aW9uIGhhcyBmaW5pc2hlZC5cclxuXHRcdFx0XHRyZXN0b3JlU2VsZWN0aW9uIGlzIG9ubHkgZGVmaW5lZCBpZiB0aGUgcmFuZ3kgbGlicmFyeSBpcyBpbmNsdWRlZCBhbmQgaXQgY2FuIGJlIGNhbGxlZCBhcyBgcmVzdG9yZVNlbGVjdGlvbigpYCB0byByZXN0b3JlIHRoZSB1c2Vyc1xyXG5cdFx0XHRcdHNlbGVjdGlvbiBpbiB0aGUgV1lTSVdZRyBlZGl0b3IuXHJcblx0XHRkaXNwbGF5OiBbc3RyaW5nXT9cclxuXHRcdFx0XHRPcHRpb25hbCwgYW4gSFRNTCBlbGVtZW50IHRvIGJlIGRpc3BsYXllZCBhcyB0aGUgYnV0dG9uLiBUaGUgYHNjb3BlYCBvZiB0aGUgYnV0dG9uIGlzIHRoZSB0b29sIGRlZmluaXRpb24gb2JqZWN0IHdpdGggc29tZSBhZGRpdGlvbmFsIGZ1bmN0aW9uc1xyXG5cdFx0XHRcdElmIHNldCB0aGlzIHdpbGwgY2F1c2UgYnV0dG9udGV4dCBhbmQgaWNvbmNsYXNzIHRvIGJlIGlnbm9yZWRcclxuXHRcdGNsYXNzOiBbc3RyaW5nXT9cclxuXHRcdFx0XHRPcHRpb25hbCwgaWYgc2V0IHdpbGwgb3ZlcnJpZGUgdGhlIHRhT3B0aW9ucy5jbGFzc2VzLnRvb2xiYXJCdXR0b24gY2xhc3MuXHJcblx0XHRidXR0b250ZXh0OiBbc3RyaW5nXT9cclxuXHRcdFx0XHRpZiB0aGlzIGlzIGRlZmluZWQgaXQgd2lsbCByZXBsYWNlIHRoZSBjb250ZW50cyBvZiB0aGUgZWxlbWVudCBjb250YWluZWQgaW4gdGhlIGBkaXNwbGF5YCBlbGVtZW50XHJcblx0XHRpY29uY2xhc3M6IFtzdHJpbmddP1xyXG5cdFx0XHRcdGlmIHRoaXMgaXMgZGVmaW5lZCBhbiBpY29uICg8aT4pIHdpbGwgYmUgYXBwZW5kZWQgdG8gdGhlIGBkaXNwbGF5YCBlbGVtZW50IHdpdGggdGhpcyBzdHJpbmcgYXMgaXQncyBjbGFzc1xyXG5cdFx0dG9vbHRpcHRleHQ6IFtzdHJpbmddP1xyXG5cdFx0XHRcdE9wdGlvbmFsLCBhIHBsYWluIHRleHQgZGVzY3JpcHRpb24gb2YgdGhlIGFjdGlvbiwgdXNlZCBmb3IgdGhlIHRpdGxlIGF0dHJpYnV0ZSBvZiB0aGUgYWN0aW9uIGJ1dHRvbiBpbiB0aGUgdG9vbGJhciBieSBkZWZhdWx0LlxyXG5cdFx0YWN0aXZlc3RhdGU6IFtmdW5jdGlvbihjb21tb25FbGVtZW50KV0/XHJcblx0XHRcdFx0dGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgb24gZXZlcnkgY2FyZXQgbW92ZW1lbnQsIGlmIGl0IHJldHVybnMgdHJ1ZSB0aGVuIHRoZSBjbGFzcyB0YU9wdGlvbnMuY2xhc3Nlcy50b29sYmFyQnV0dG9uQWN0aXZlXHJcblx0XHRcdFx0d2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBgZGlzcGxheWAgZWxlbWVudCwgZWxzZSB0aGUgY2xhc3Mgd2lsbCBiZSByZW1vdmVkXHJcblx0XHRkaXNhYmxlZDogW2Z1bmN0aW9uKCldP1xyXG5cdFx0XHRcdGlmIHRoaXMgZnVuY3Rpb24gcmV0dXJucyB0cnVlIHRoZW4gdGhlIHRvb2wgd2lsbCBoYXZlIHRoZSBjbGFzcyB0YU9wdGlvbnMuY2xhc3Nlcy5kaXNhYmxlZCBhcHBsaWVkIHRvIGl0LCBlbHNlIGl0IHdpbGwgYmUgcmVtb3ZlZFxyXG5cdE90aGVyIGZ1bmN0aW9ucyBhdmFpbGFibGUgb24gdGhlIHNjb3BlIGFyZTpcclxuXHRcdG5hbWU6IFtzdHJpbmddXHJcblx0XHRcdFx0dGhlIG5hbWUgb2YgdGhlIHRvb2wsIHRoaXMgaXMgdGhlIGZpcnN0IHBhcmFtZXRlciBwYXNzZWQgaW50byB0YVJlZ2lzdGVyVG9vbFxyXG5cdFx0aXNEaXNhYmxlZDogW2Z1bmN0aW9uKCldXHJcblx0XHRcdFx0cmV0dXJucyB0cnVlIGlmIHRoZSB0b29sIGlzIGRpc2FibGVkLCBmYWxzZSBpZiBpdCBpc24ndFxyXG5cdFx0ZGlzcGxheUFjdGl2ZVRvb2xDbGFzczogW2Z1bmN0aW9uKGJvb2xlYW4pXVxyXG5cdFx0XHRcdHJldHVybnMgdHJ1ZSBpZiB0aGUgdG9vbCBpcyAnYWN0aXZlJyBpbiB0aGUgY3VycmVudGx5IGZvY3Vzc2VkIHRvb2xiYXJcclxuXHRcdG9uRWxlbWVudFNlbGVjdDogW09iamVjdF1cclxuXHRcdFx0XHRUaGlzIG9iamVjdCBjb250YWlucyB0aGUgZm9sbG93aW5nIGtleS92YWx1ZSBwYWlycyBhbmQgaXMgdXNlZCB0byB0cmlnZ2VyIHRoZSB0YS1lbGVtZW50LXNlbGVjdCBldmVudFxyXG5cdFx0XHRcdGVsZW1lbnQ6IFtTdHJpbmddXHJcblx0XHRcdFx0XHRhbiBlbGVtZW50IG5hbWUsIHdpbGwgb25seSB0cmlnZ2VyIHRoZSBvbkVsZW1lbnRTZWxlY3QgYWN0aW9uIGlmIHRoZSB0YWdOYW1lIG9mIHRoZSBlbGVtZW50IG1hdGNoZXMgdGhpcyBzdHJpbmdcclxuXHRcdFx0XHRmaWx0ZXI6IFtmdW5jdGlvbihlbGVtZW50KV0/XHJcblx0XHRcdFx0XHRhbiBvcHRpb25hbCBmaWx0ZXIgdGhhdCByZXR1cm5zIGEgYm9vbGVhbiwgaWYgdHJ1ZSBpdCB3aWxsIHRyaWdnZXIgdGhlIG9uRWxlbWVudFNlbGVjdC5cclxuXHRcdFx0XHRhY3Rpb246IFtmdW5jdGlvbihldmVudCwgZWxlbWVudCwgZWRpdG9yU2NvcGUpXVxyXG5cdFx0XHRcdFx0dGhlIGFjdGlvbiB0aGF0IHNob3VsZCBiZSBleGVjdXRlZCBpZiB0aGUgb25FbGVtZW50U2VsZWN0IGZ1bmN0aW9uIHJ1bnNcclxuKi9cclxuLy8gbmFtZSBhbmQgdG9vbERlZmluaXRpb24gdG8gYWRkIGludG8gdGhlIHRvb2xzIGF2YWlsYWJsZSB0byBiZSBhZGRlZCBvbiB0aGUgdG9vbGJhclxyXG5mdW5jdGlvbiBjKGEsYyl7aWYoIWF8fFwiXCI9PT1hfHxlLmhhc093blByb3BlcnR5KGEpKXRocm93XCJ0ZXh0QW5ndWxhciBFcnJvcjogQSB1bmlxdWUgbmFtZSBpcyByZXF1aXJlZCBmb3IgYSBUb29sIERlZmluaXRpb25cIjtpZihjLmRpc3BsYXkmJihcIlwiPT09Yy5kaXNwbGF5fHwhYihjLmRpc3BsYXkpKXx8IWMuZGlzcGxheSYmIWMuYnV0dG9udGV4dCYmIWMuaWNvbmNsYXNzKXRocm93J3RleHRBbmd1bGFyIEVycm9yOiBUb29sIERlZmluaXRpb24gZm9yIFwiJythKydcIiBkb2VzIG5vdCBoYXZlIGEgdmFsaWQgZGlzcGxheS9pY29uY2xhc3MvYnV0dG9udGV4dCB2YWx1ZSc7ZVthXT1jfVxyXG4vLyB1c2FnZSBpczpcclxuLy8gdmFyIHQwID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcbi8vIGRvU29tZXRoaW5nKCk7XHJcbi8vIHZhciB0MSA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4vLyBjb25zb2xlLmxvZygnVG9vaycsICh0MSAtIHQwKS50b0ZpeGVkKDQpLCAnbWlsbGlzZWNvbmRzIHRvIGRvIHNvbWV0aGluZyEnKTtcclxuLy9cclxuLy8gdHVybiBodG1sIGludG8gcHVyZSB0ZXh0IHRoYXQgc2hvd3MgdmlzaWJsaXR5XHJcbmZ1bmN0aW9uIGQoYSl7dmFyIGI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIkRJVlwiKTtiLmlubmVySFRNTD1hO3ZhciBjPWIudGV4dENvbnRlbnR8fGIuaW5uZXJUZXh0fHxcIlwiOy8vIHplcm8gd2lkdGggc3BhY2VcclxucmV0dXJuIGMucmVwbGFjZShcIuKAi1wiLFwiXCIpLGM9Yy50cmltKCl9XHJcbi8vIHNldHVwIHRoZSBnbG9iYWwgY29udHN0YW50IGZ1bmN0aW9ucyBmb3Igc2V0dGluZyB1cCB0aGUgdG9vbGJhclxyXG4vLyBhbGwgdG9vbCBkZWZpbml0aW9uc1xyXG52YXIgZT17fTthbmd1bGFyLm1vZHVsZShcInRleHRBbmd1bGFyU2V0dXBcIixbXSkuY29uc3RhbnQoXCJ0YVJlZ2lzdGVyVG9vbFwiLGMpLnZhbHVlKFwidGFUb29sc1wiLGUpLnZhbHVlKFwidGFPcHRpb25zXCIse1xyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4vLyBmb3JjZVRleHRBbmd1bGFyU2FuaXRpemVcclxuLy8gc2V0IGZhbHNlIHRvIGFsbG93IHRoZSB0ZXh0QW5ndWxhci1zYW5pdGl6ZSBwcm92aWRlciB0byBiZSByZXBsYWNlZFxyXG4vLyB3aXRoIGFuZ3VsYXItc2FuaXRpemUgb3IgYSBjdXN0b20gcHJvdmlkZXIuXHJcbmZvcmNlVGV4dEFuZ3VsYXJTYW5pdGl6ZTohMCxcclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbi8vIGtleU1hcHBpbmdzXHJcbi8vIGFsbG93IGN1c3RvbWl6YWJsZSBrZXlNYXBwaW5ncyBmb3Igc3BlY2lhbGl6ZWQga2V5IGJvYXJkcyBvciBsYW5ndWFnZXNcclxuLy9cclxuLy8ga2V5TWFwcGluZ3MgcHJvdmlkZXMga2V5IG1hcHBpbmdzIHRoYXQgYXJlIGF0dGFjaGVkIHRvIGEgZ2l2ZW4gY29tbWFuZEtleUNvZGUuXHJcbi8vIFRvIG1vZGlmeSBhIHNwZWNpZmljIGtleWJvYXJkIGJpbmRpbmcsIHNpbXBseSBwcm92aWRlIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgdHJ1ZVxyXG4vLyBmb3IgdGhlIGV2ZW50IHlvdSB3aXNoIHRvIG1hcCB0by5cclxuLy8gT3IgdG8gZGlzYWJsZSBhIHNwZWNpZmljIGtleWJvYXJkIGJpbmRpbmcsIHByb3ZpZGUgYSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGZhbHNlLlxyXG4vLyBOb3RlOiAnUmVkb0tleScgYW5kICdVbmRvS2V5JyBhcmUgaW50ZXJuYWxseSBib3VuZCB0byB0aGUgcmVkbyBhbmQgdW5kbyBmdW5jdGlvbmFsaXR5LlxyXG4vLyBBdCBwcmVzZW50LCB0aGUgZm9sbG93aW5nIGNvbW1hbmRLZXlDb2RlcyBhcmUgaW4gdXNlOlxyXG4vLyA5OCwgJ1RhYktleScsICdTaGlmdFRhYktleScsIDEwNSwgMTE3LCAnVW5kb0tleScsICdSZWRvS2V5J1xyXG4vL1xyXG4vLyBUbyBtYXAgdG8gYW4gbmV3IGNvbW1hbmRLZXlDb2RlLCBhZGQgYSBuZXcga2V5IG1hcHBpbmcgc3VjaCBhczpcclxuLy8ge2NvbW1hbmRLZXlDb2RlOiAnQ3VzdG9tS2V5JywgdGVzdEZvcktleTogZnVuY3Rpb24gKGV2ZW50KSB7XHJcbi8vICBpZiAoZXZlbnQua2V5Q29kZT01NyAmJiBldmVudC5jdHJsS2V5ICYmICFldmVudC5zaGlmdEtleSAmJiAhZXZlbnQuYWx0S2V5KSByZXR1cm4gdHJ1ZTtcclxuLy8gfSB9XHJcbi8vIHRvIHRoZSBrZXlNYXBwaW5ncy4gVGhpcyBleGFtcGxlIG1hcHMgY3RybCs5IHRvICdDdXN0b21LZXknXHJcbi8vIFRoZW4gd2hlcmUgdGFSZWdpc3RlclRvb2woLi4uKSBpcyBjYWxsZWQsIGFkZCBhIGNvbW1hbmRLZXlDb2RlOiAnQ3VzdG9tS2V5JyBhbmQgeW91clxyXG4vLyB0b29sIHdpbGwgYmUgYm91bmQgdG8gY3RybCs5LlxyXG4vL1xyXG4vLyBUbyBkaXNibGUgb25lIG9mIHRoZSBhbHJlYWR5IGJvdW5kIGNvbW1hbmRLZXlDb2RlcyBzdWNoIGFzICdSZWRvS2V5JyBvciAnVW5kb0tleScgYWRkOlxyXG4vLyB7Y29tbWFuZEtleUNvZGU6ICdSZWRvS2V5JywgdGVzdEZvcktleTogZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiBmYWxzZTsgfSB9LFxyXG4vLyB7Y29tbWFuZEtleUNvZGU6ICdVbmRvS2V5JywgdGVzdEZvcktleTogZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiBmYWxzZTsgfSB9LFxyXG4vLyB0byBkaXNhYmxlIHRoZW0uXHJcbi8vXHJcbmtleU1hcHBpbmdzOltdLHRvb2xiYXI6W1tcImgxXCIsXCJoMlwiLFwiaDNcIixcImg0XCIsXCJoNVwiLFwiaDZcIixcInBcIixcInByZVwiLFwicXVvdGVcIl0sW1wiYm9sZFwiLFwiaXRhbGljc1wiLFwidW5kZXJsaW5lXCIsXCJzdHJpa2VUaHJvdWdoXCIsXCJ1bFwiLFwib2xcIixcInJlZG9cIixcInVuZG9cIixcImNsZWFyXCJdLFtcImp1c3RpZnlMZWZ0XCIsXCJqdXN0aWZ5Q2VudGVyXCIsXCJqdXN0aWZ5UmlnaHRcIixcImp1c3RpZnlGdWxsXCIsXCJpbmRlbnRcIixcIm91dGRlbnRcIl0sW1wiaHRtbFwiLFwiaW5zZXJ0SW1hZ2VcIixcImluc2VydExpbmtcIixcImluc2VydFZpZGVvXCIsXCJ3b3JkY291bnRcIixcImNoYXJjb3VudFwiXV0sY2xhc3Nlczp7Zm9jdXNzZWQ6XCJmb2N1c3NlZFwiLHRvb2xiYXI6XCJidG4tdG9vbGJhclwiLHRvb2xiYXJHcm91cDpcImJ0bi1ncm91cFwiLHRvb2xiYXJCdXR0b246XCJidG4gYnRuLWRlZmF1bHRcIix0b29sYmFyQnV0dG9uQWN0aXZlOlwiYWN0aXZlXCIsZGlzYWJsZWQ6XCJkaXNhYmxlZFwiLHRleHRFZGl0b3I6XCJmb3JtLWNvbnRyb2xcIixodG1sRWRpdG9yOlwiZm9ybS1jb250cm9sXCJ9LGRlZmF1bHRUYWdBdHRyaWJ1dGVzOnthOnt0YXJnZXQ6XCJcIn19LHNldHVwOntcclxuLy8gd3lzaXd5ZyBtb2RlXHJcbnRleHRFZGl0b3JTZXR1cDpmdW5jdGlvbihhKXt9LFxyXG4vLyByYXcgaHRtbFxyXG5odG1sRWRpdG9yU2V0dXA6ZnVuY3Rpb24oYSl7fX0sZGVmYXVsdEZpbGVEcm9wSGFuZGxlcjovKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogdW50ZXN0YWJsZSBpbWFnZSBwcm9jZXNzaW5nICovXHJcbmZ1bmN0aW9uKGEsYil7dmFyIGM9bmV3IEZpbGVSZWFkZXI7cmV0dXJuXCJpbWFnZVwiPT09YS50eXBlLnN1YnN0cmluZygwLDUpJiYoYy5vbmxvYWQ9ZnVuY3Rpb24oKXtcIlwiIT09Yy5yZXN1bHQmJmIoXCJpbnNlcnRJbWFnZVwiLGMucmVzdWx0LCEwKX0sYy5yZWFkQXNEYXRhVVJMKGEpLCEwKX19KS52YWx1ZShcInRhU2VsZWN0YWJsZUVsZW1lbnRzXCIsW1wiYVwiLFwiaW1nXCJdKS52YWx1ZShcInRhQ3VzdG9tUmVuZGVyZXJzXCIsW3tcclxuLy8gUGFyc2UgYmFjayBvdXQ6ICc8ZGl2IGNsYXNzPVwidGEtaW5zZXJ0LXZpZGVvXCIgdGEtaW5zZXJ0LXZpZGVvIHNyYz1cIicgKyB1cmxMaW5rICsgJ1wiIGFsbG93ZnVsbHNjcmVlbj1cInRydWVcIiB3aWR0aD1cIjMwMFwiIGZyYW1lYm9yZGVyPVwiMFwiIGhlaWdodD1cIjI1MFwiPjwvZGl2PidcclxuLy8gVG8gY29ycmVjdCB2aWRlbyBlbGVtZW50LiBGb3Igbm93IG9ubHkgc3VwcG9ydCB5b3V0dWJlXHJcbnNlbGVjdG9yOlwiaW1nXCIsY3VzdG9tQXR0cmlidXRlOlwidGEtaW5zZXJ0LXZpZGVvXCIscmVuZGVyTG9naWM6ZnVuY3Rpb24oYSl7dmFyIGI9YW5ndWxhci5lbGVtZW50KFwiPGlmcmFtZT48L2lmcmFtZT5cIiksYz1hLnByb3AoXCJhdHRyaWJ1dGVzXCIpO1xyXG4vLyBsb29wIHRocm91Z2ggZWxlbWVudCBhdHRyaWJ1dGVzIGFuZCBhcHBseSB0aGVtIG9uIGlmcmFtZVxyXG5hbmd1bGFyLmZvckVhY2goYyxmdW5jdGlvbihhKXtiLmF0dHIoYS5uYW1lLGEudmFsdWUpfSksYi5hdHRyKFwic3JjXCIsYi5hdHRyKFwidGEtaW5zZXJ0LXZpZGVvXCIpKSxhLnJlcGxhY2VXaXRoKGIpfX1dKS52YWx1ZShcInRhVHJhbnNsYXRpb25zXCIse1xyXG4vLyBtb3ZlZCB0byBzdWItZWxlbWVudHNcclxuLy90b2dnbGVIVE1MOiBcIlRvZ2dsZSBIVE1MXCIsXHJcbi8vaW5zZXJ0SW1hZ2U6IFwiUGxlYXNlIGVudGVyIGEgaW1hZ2UgVVJMIHRvIGluc2VydFwiLFxyXG4vL2luc2VydExpbms6IFwiUGxlYXNlIGVudGVyIGEgVVJMIHRvIGluc2VydFwiLFxyXG4vL2luc2VydFZpZGVvOiBcIlBsZWFzZSBlbnRlciBhIHlvdXR1YmUgVVJMIHRvIGVtYmVkXCIsXHJcbmh0bWw6e3Rvb2x0aXA6XCJUb2dnbGUgaHRtbCAvIFJpY2ggVGV4dFwifSxcclxuLy8gdG9vbHRpcCBmb3IgaGVhZGluZyAtIG1pZ2h0IGJlIHdvcnRoIHNwbGl0dGluZ1xyXG5oZWFkaW5nOnt0b29sdGlwOlwiSGVhZGluZyBcIn0scDp7dG9vbHRpcDpcIlBhcmFncmFwaFwifSxwcmU6e3Rvb2x0aXA6XCJQcmVmb3JtYXR0ZWQgdGV4dFwifSx1bDp7dG9vbHRpcDpcIlVub3JkZXJlZCBMaXN0XCJ9LG9sOnt0b29sdGlwOlwiT3JkZXJlZCBMaXN0XCJ9LHF1b3RlOnt0b29sdGlwOlwiUXVvdGUvdW5xdW90ZSBzZWxlY3Rpb24gb3IgcGFyYWdyYXBoXCJ9LHVuZG86e3Rvb2x0aXA6XCJVbmRvXCJ9LHJlZG86e3Rvb2x0aXA6XCJSZWRvXCJ9LGJvbGQ6e3Rvb2x0aXA6XCJCb2xkXCJ9LGl0YWxpYzp7dG9vbHRpcDpcIkl0YWxpY1wifSx1bmRlcmxpbmU6e3Rvb2x0aXA6XCJVbmRlcmxpbmVcIn0sc3RyaWtlVGhyb3VnaDp7dG9vbHRpcDpcIlN0cmlrZXRocm91Z2hcIn0sanVzdGlmeUxlZnQ6e3Rvb2x0aXA6XCJBbGlnbiB0ZXh0IGxlZnRcIn0sanVzdGlmeVJpZ2h0Ont0b29sdGlwOlwiQWxpZ24gdGV4dCByaWdodFwifSxqdXN0aWZ5RnVsbDp7dG9vbHRpcDpcIkp1c3RpZnkgdGV4dFwifSxqdXN0aWZ5Q2VudGVyOnt0b29sdGlwOlwiQ2VudGVyXCJ9LGluZGVudDp7dG9vbHRpcDpcIkluY3JlYXNlIGluZGVudFwifSxvdXRkZW50Ont0b29sdGlwOlwiRGVjcmVhc2UgaW5kZW50XCJ9LGNsZWFyOnt0b29sdGlwOlwiQ2xlYXIgZm9ybWF0dGluZ1wifSxpbnNlcnRJbWFnZTp7ZGlhbG9nUHJvbXB0OlwiUGxlYXNlIGVudGVyIGFuIGltYWdlIFVSTCB0byBpbnNlcnRcIix0b29sdGlwOlwiSW5zZXJ0IGltYWdlXCIsaG90a2V5OlwidGhlIC0gcG9zc2libHkgbGFuZ3VhZ2UgZGVwZW5kZW50IGhvdGtleSAuLi4gZm9yIHNvbWUgZnV0dXJlIGltcGxlbWVudGF0aW9uXCJ9LGluc2VydFZpZGVvOnt0b29sdGlwOlwiSW5zZXJ0IHZpZGVvXCIsZGlhbG9nUHJvbXB0OlwiUGxlYXNlIGVudGVyIGEgeW91dHViZSBVUkwgdG8gZW1iZWRcIn0saW5zZXJ0TGluazp7dG9vbHRpcDpcIkluc2VydCAvIGVkaXQgbGlua1wiLGRpYWxvZ1Byb21wdDpcIlBsZWFzZSBlbnRlciBhIFVSTCB0byBpbnNlcnRcIn0sZWRpdExpbms6e3JlTGlua0J1dHRvbjp7dG9vbHRpcDpcIlJlbGlua1wifSx1bkxpbmtCdXR0b246e3Rvb2x0aXA6XCJVbmxpbmtcIn0sdGFyZ2V0VG9nZ2xlOntidXR0b250ZXh0OlwiT3BlbiBpbiBOZXcgV2luZG93XCJ9fSx3b3JkY291bnQ6e3Rvb2x0aXA6XCJEaXNwbGF5IHdvcmRzIENvdW50XCJ9LGNoYXJjb3VudDp7dG9vbHRpcDpcIkRpc3BsYXkgY2hhcmFjdGVycyBDb3VudFwifX0pLmZhY3RvcnkoXCJ0YVRvb2xGdW5jdGlvbnNcIixbXCIkd2luZG93XCIsXCJ0YVRyYW5zbGF0aW9uc1wiLGZ1bmN0aW9uKGEsYil7cmV0dXJue2ltZ09uU2VsZWN0QWN0aW9uOmZ1bmN0aW9uKGEsYixjKXtcclxuLy8gc2V0dXAgdGhlIGVkaXRvciB0b29sYmFyXHJcbi8vIENyZWRpdCB0byB0aGUgd29yayBhdCBodHRwOi8vaGFja2Vyd2lucy5naXRodWIuaW8vc3VtbWVybm90ZS8gZm9yIHRoaXMgZWRpdGJhciBsb2dpYy9kaXNwbGF5XHJcbnZhciBkPWZ1bmN0aW9uKCl7Yy51cGRhdGVUYUJpbmR0YVRleHRFbGVtZW50KCksYy5oaWRlUG9wb3ZlcigpfTthLnByZXZlbnREZWZhdWx0KCksYy5kaXNwbGF5RWxlbWVudHMucG9wb3Zlci5jc3MoXCJ3aWR0aFwiLFwiMzc1cHhcIik7dmFyIGU9Yy5kaXNwbGF5RWxlbWVudHMucG9wb3ZlckNvbnRhaW5lcjtlLmVtcHR5KCk7dmFyIGY9YW5ndWxhci5lbGVtZW50KCc8ZGl2IGNsYXNzPVwiYnRuLWdyb3VwXCIgc3R5bGU9XCJwYWRkaW5nLXJpZ2h0OiA2cHg7XCI+JyksZz1hbmd1bGFyLmVsZW1lbnQoJzxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1kZWZhdWx0IGJ0bi1zbSBidG4tc21hbGxcIiB1bnNlbGVjdGFibGU9XCJvblwiIHRhYmluZGV4PVwiLTFcIj4xMDAlIDwvYnV0dG9uPicpO2cub24oXCJjbGlja1wiLGZ1bmN0aW9uKGEpe2EucHJldmVudERlZmF1bHQoKSxiLmNzcyh7d2lkdGg6XCIxMDAlXCIsaGVpZ2h0OlwiXCJ9KSxkKCl9KTt2YXIgaD1hbmd1bGFyLmVsZW1lbnQoJzxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1kZWZhdWx0IGJ0bi1zbSBidG4tc21hbGxcIiB1bnNlbGVjdGFibGU9XCJvblwiIHRhYmluZGV4PVwiLTFcIj41MCUgPC9idXR0b24+Jyk7aC5vbihcImNsaWNrXCIsZnVuY3Rpb24oYSl7YS5wcmV2ZW50RGVmYXVsdCgpLGIuY3NzKHt3aWR0aDpcIjUwJVwiLGhlaWdodDpcIlwifSksZCgpfSk7dmFyIGk9YW5ndWxhci5lbGVtZW50KCc8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tZGVmYXVsdCBidG4tc20gYnRuLXNtYWxsXCIgdW5zZWxlY3RhYmxlPVwib25cIiB0YWJpbmRleD1cIi0xXCI+MjUlIDwvYnV0dG9uPicpO2kub24oXCJjbGlja1wiLGZ1bmN0aW9uKGEpe2EucHJldmVudERlZmF1bHQoKSxiLmNzcyh7d2lkdGg6XCIyNSVcIixoZWlnaHQ6XCJcIn0pLGQoKX0pO3ZhciBqPWFuZ3VsYXIuZWxlbWVudCgnPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLWRlZmF1bHQgYnRuLXNtIGJ0bi1zbWFsbFwiIHVuc2VsZWN0YWJsZT1cIm9uXCIgdGFiaW5kZXg9XCItMVwiPlJlc2V0PC9idXR0b24+Jyk7ai5vbihcImNsaWNrXCIsZnVuY3Rpb24oYSl7YS5wcmV2ZW50RGVmYXVsdCgpLGIuY3NzKHt3aWR0aDpcIlwiLGhlaWdodDpcIlwifSksZCgpfSksZi5hcHBlbmQoZyksZi5hcHBlbmQoaCksZi5hcHBlbmQoaSksZi5hcHBlbmQoaiksZS5hcHBlbmQoZiksZj1hbmd1bGFyLmVsZW1lbnQoJzxkaXYgY2xhc3M9XCJidG4tZ3JvdXBcIiBzdHlsZT1cInBhZGRpbmctcmlnaHQ6IDZweDtcIj4nKTt2YXIgaz1hbmd1bGFyLmVsZW1lbnQoJzxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1kZWZhdWx0IGJ0bi1zbSBidG4tc21hbGxcIiB1bnNlbGVjdGFibGU9XCJvblwiIHRhYmluZGV4PVwiLTFcIj48aSBjbGFzcz1cImZhIGZhLWFsaWduLWxlZnRcIj48L2k+PC9idXR0b24+Jyk7ay5vbihcImNsaWNrXCIsZnVuY3Rpb24oYSl7YS5wcmV2ZW50RGVmYXVsdCgpLFxyXG4vLyB3ZWJraXRcclxuYi5jc3MoXCJmbG9hdFwiLFwibGVmdFwiKSxcclxuLy8gZmlyZWZveFxyXG5iLmNzcyhcImNzc0Zsb2F0XCIsXCJsZWZ0XCIpLFxyXG4vLyBJRSA8IDhcclxuYi5jc3MoXCJzdHlsZUZsb2F0XCIsXCJsZWZ0XCIpLGQoKX0pO3ZhciBsPWFuZ3VsYXIuZWxlbWVudCgnPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLWRlZmF1bHQgYnRuLXNtIGJ0bi1zbWFsbFwiIHVuc2VsZWN0YWJsZT1cIm9uXCIgdGFiaW5kZXg9XCItMVwiPjxpIGNsYXNzPVwiZmEgZmEtYWxpZ24tcmlnaHRcIj48L2k+PC9idXR0b24+Jyk7bC5vbihcImNsaWNrXCIsZnVuY3Rpb24oYSl7YS5wcmV2ZW50RGVmYXVsdCgpLFxyXG4vLyB3ZWJraXRcclxuYi5jc3MoXCJmbG9hdFwiLFwicmlnaHRcIiksXHJcbi8vIGZpcmVmb3hcclxuYi5jc3MoXCJjc3NGbG9hdFwiLFwicmlnaHRcIiksXHJcbi8vIElFIDwgOFxyXG5iLmNzcyhcInN0eWxlRmxvYXRcIixcInJpZ2h0XCIpLGQoKX0pO3ZhciBtPWFuZ3VsYXIuZWxlbWVudCgnPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLWRlZmF1bHQgYnRuLXNtIGJ0bi1zbWFsbFwiIHVuc2VsZWN0YWJsZT1cIm9uXCIgdGFiaW5kZXg9XCItMVwiPjxpIGNsYXNzPVwiZmEgZmEtYWxpZ24tanVzdGlmeVwiPjwvaT48L2J1dHRvbj4nKTttLm9uKFwiY2xpY2tcIixmdW5jdGlvbihhKXthLnByZXZlbnREZWZhdWx0KCksXHJcbi8vIHdlYmtpdFxyXG5iLmNzcyhcImZsb2F0XCIsXCJcIiksXHJcbi8vIGZpcmVmb3hcclxuYi5jc3MoXCJjc3NGbG9hdFwiLFwiXCIpLFxyXG4vLyBJRSA8IDhcclxuYi5jc3MoXCJzdHlsZUZsb2F0XCIsXCJcIiksZCgpfSksZi5hcHBlbmQoayksZi5hcHBlbmQobSksZi5hcHBlbmQobCksZS5hcHBlbmQoZiksZj1hbmd1bGFyLmVsZW1lbnQoJzxkaXYgY2xhc3M9XCJidG4tZ3JvdXBcIj4nKTt2YXIgbj1hbmd1bGFyLmVsZW1lbnQoJzxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1kZWZhdWx0IGJ0bi1zbSBidG4tc21hbGxcIiB1bnNlbGVjdGFibGU9XCJvblwiIHRhYmluZGV4PVwiLTFcIj48aSBjbGFzcz1cImZhIGZhLXRyYXNoLW9cIj48L2k+PC9idXR0b24+Jyk7bi5vbihcImNsaWNrXCIsZnVuY3Rpb24oYSl7YS5wcmV2ZW50RGVmYXVsdCgpLGIucmVtb3ZlKCksZCgpfSksZi5hcHBlbmQobiksZS5hcHBlbmQoZiksYy5zaG93UG9wb3ZlcihiKSxjLnNob3dSZXNpemVPdmVybGF5KGIpfSxhT25TZWxlY3RBY3Rpb246ZnVuY3Rpb24oYyxkLGUpe1xyXG4vLyBzZXR1cCB0aGUgZWRpdG9yIHRvb2xiYXJcclxuLy8gQ3JlZGl0IHRvIHRoZSB3b3JrIGF0IGh0dHA6Ly9oYWNrZXJ3aW5zLmdpdGh1Yi5pby9zdW1tZXJub3RlLyBmb3IgdGhpcyBlZGl0YmFyIGxvZ2ljXHJcbmMucHJldmVudERlZmF1bHQoKSxlLmRpc3BsYXlFbGVtZW50cy5wb3BvdmVyLmNzcyhcIndpZHRoXCIsXCI0MzZweFwiKTt2YXIgZj1lLmRpc3BsYXlFbGVtZW50cy5wb3BvdmVyQ29udGFpbmVyO2YuZW1wdHkoKSxmLmNzcyhcImxpbmUtaGVpZ2h0XCIsXCIyOHB4XCIpO3ZhciBnPWFuZ3VsYXIuZWxlbWVudCgnPGEgaHJlZj1cIicrZC5hdHRyKFwiaHJlZlwiKSsnXCIgdGFyZ2V0PVwiX2JsYW5rXCI+JytkLmF0dHIoXCJocmVmXCIpK1wiPC9hPlwiKTtnLmNzcyh7ZGlzcGxheTpcImlubGluZS1ibG9ja1wiLFwibWF4LXdpZHRoXCI6XCIyMDBweFwiLG92ZXJmbG93OlwiaGlkZGVuXCIsXCJ0ZXh0LW92ZXJmbG93XCI6XCJlbGxpcHNpc1wiLFwid2hpdGUtc3BhY2VcIjpcIm5vd3JhcFwiLFwidmVydGljYWwtYWxpZ25cIjpcIm1pZGRsZVwifSksZi5hcHBlbmQoZyk7dmFyIGg9YW5ndWxhci5lbGVtZW50KCc8ZGl2IGNsYXNzPVwiYnRuLWdyb3VwIHB1bGwtcmlnaHRcIj4nKSxpPWFuZ3VsYXIuZWxlbWVudCgnPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLWRlZmF1bHQgYnRuLXNtIGJ0bi1zbWFsbFwiIHRhYmluZGV4PVwiLTFcIiB1bnNlbGVjdGFibGU9XCJvblwiIHRpdGxlPVwiJytiLmVkaXRMaW5rLnJlTGlua0J1dHRvbi50b29sdGlwKydcIj48aSBjbGFzcz1cImZhIGZhLWVkaXQgaWNvbi1lZGl0XCI+PC9pPjwvYnV0dG9uPicpO2kub24oXCJjbGlja1wiLGZ1bmN0aW9uKGMpe2MucHJldmVudERlZmF1bHQoKTt2YXIgZj1hLnByb21wdChiLmluc2VydExpbmsuZGlhbG9nUHJvbXB0LGQuYXR0cihcImhyZWZcIikpO2YmJlwiXCIhPT1mJiZcImh0dHA6Ly9cIiE9PWYmJihkLmF0dHIoXCJocmVmXCIsZiksZS51cGRhdGVUYUJpbmR0YVRleHRFbGVtZW50KCkpLGUuaGlkZVBvcG92ZXIoKX0pLGguYXBwZW5kKGkpO3ZhciBqPWFuZ3VsYXIuZWxlbWVudCgnPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLWRlZmF1bHQgYnRuLXNtIGJ0bi1zbWFsbFwiIHRhYmluZGV4PVwiLTFcIiB1bnNlbGVjdGFibGU9XCJvblwiIHRpdGxlPVwiJytiLmVkaXRMaW5rLnVuTGlua0J1dHRvbi50b29sdGlwKydcIj48aSBjbGFzcz1cImZhIGZhLXVubGluayBpY29uLXVubGlua1wiPjwvaT48L2J1dHRvbj4nKTtcclxuLy8gZGlyZWN0bHkgYmVmb3JlIHRoaXMgY2xpY2sgZXZlbnQgaXMgZmlyZWQgYSBkaWdlc3QgaXMgZmlyZWQgb2ZmIHdoZXJlYnkgdGhlIHJlZmVyZW5jZSB0byAkZWxlbWVudCBpcyBvcnBoYW5lZCBvZmZcclxuai5vbihcImNsaWNrXCIsZnVuY3Rpb24oYSl7YS5wcmV2ZW50RGVmYXVsdCgpLGQucmVwbGFjZVdpdGgoZC5jb250ZW50cygpKSxlLnVwZGF0ZVRhQmluZHRhVGV4dEVsZW1lbnQoKSxlLmhpZGVQb3BvdmVyKCl9KSxoLmFwcGVuZChqKTt2YXIgaz1hbmd1bGFyLmVsZW1lbnQoJzxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1kZWZhdWx0IGJ0bi1zbSBidG4tc21hbGxcIiB0YWJpbmRleD1cIi0xXCIgdW5zZWxlY3RhYmxlPVwib25cIj4nK2IuZWRpdExpbmsudGFyZ2V0VG9nZ2xlLmJ1dHRvbnRleHQrXCI8L2J1dHRvbj5cIik7XCJfYmxhbmtcIj09PWQuYXR0cihcInRhcmdldFwiKSYmay5hZGRDbGFzcyhcImFjdGl2ZVwiKSxrLm9uKFwiY2xpY2tcIixmdW5jdGlvbihhKXthLnByZXZlbnREZWZhdWx0KCksZC5hdHRyKFwidGFyZ2V0XCIsXCJfYmxhbmtcIj09PWQuYXR0cihcInRhcmdldFwiKT9cIlwiOlwiX2JsYW5rXCIpLGsudG9nZ2xlQ2xhc3MoXCJhY3RpdmVcIiksZS51cGRhdGVUYUJpbmR0YVRleHRFbGVtZW50KCl9KSxoLmFwcGVuZChrKSxmLmFwcGVuZChoKSxlLnNob3dQb3BvdmVyKGQpfSxleHRyYWN0WW91dHViZVZpZGVvSWQ6ZnVuY3Rpb24oYSl7dmFyIGI9Lyg/OnlvdXR1YmUoPzotbm9jb29raWUpP1xcLmNvbVxcLyg/OlteXFwvXFxuXFxzXStcXC9cXFMrXFwvfCg/OnZ8ZSg/Om1iZWQpPylcXC98XFxTKj9bPyZddj0pfHlvdXR1XFwuYmVcXC8pKFthLXpBLVowLTlfLV17MTF9KS9pLGM9YS5tYXRjaChiKTtyZXR1cm4gYyYmY1sxXXx8bnVsbH19fV0pLnJ1bihbXCJ0YVJlZ2lzdGVyVG9vbFwiLFwiJHdpbmRvd1wiLFwidGFUcmFuc2xhdGlvbnNcIixcInRhU2VsZWN0aW9uXCIsXCJ0YVRvb2xGdW5jdGlvbnNcIixcIiRzYW5pdGl6ZVwiLFwidGFPcHRpb25zXCIsXCIkbG9nXCIsZnVuY3Rpb24oYSxiLGMsZCxlLGYsZyxoKXtcclxuLy8gdGVzdCBmb3IgdGhlIHZlcnNpb24gb2YgJHNhbml0aXplIHRoYXQgaXMgaW4gdXNlXHJcbi8vIFlvdSBjYW4gZGlzYWJsZSB0aGlzIGNoZWNrIGJ5IHNldHRpbmcgdGFPcHRpb25zLnRleHRBbmd1bGFyU2FuaXRpemUgPT0gZmFsc2VcclxudmFyIGk9e307LyogaXN0YW5idWwgaWdub3JlIG5leHQsIHRocm93cyBlcnJvciAqL1xyXG5pZihmKFwiXCIsaSksZy5mb3JjZVRleHRBbmd1bGFyU2FuaXRpemU9PT0hMCYmXCJ0YVNhbml0aXplXCIhPT1pLnZlcnNpb24pdGhyb3cgYW5ndWxhci4kJG1pbkVycihcInRleHRBbmd1bGFyXCIpKFwidGV4dEFuZ3VsYXJTZXR1cFwiLFwiVGhlIHRleHRBbmd1bGFyLXNhbml0aXplIHByb3ZpZGVyIGhhcyBiZWVuIHJlcGxhY2VkIGJ5IGFub3RoZXIgLS0gaGF2ZSB5b3UgaW5jbHVkZWQgYW5ndWxhci1zYW5pdGl6ZSBieSBtaXN0YWtlP1wiKTthKFwiaHRtbFwiLHtpY29uY2xhc3M6XCJmYSBmYS1jb2RlXCIsdG9vbHRpcHRleHQ6Yy5odG1sLnRvb2x0aXAsYWN0aW9uOmZ1bmN0aW9uKCl7dGhpcy4kZWRpdG9yKCkuc3dpdGNoVmlldygpfSxhY3RpdmVTdGF0ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLiRlZGl0b3IoKS5zaG93SHRtbH19KTtcclxuLy8gYWRkIHRoZSBIZWFkZXIgdG9vbHNcclxuLy8gY29udmVuaWVuY2UgZnVuY3Rpb25zIHNvIHRoYXQgdGhlIGxvb3Agd29ya3MgY29ycmVjdGx5XHJcbnZhciBqPWZ1bmN0aW9uKGEpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiB0aGlzLiRlZGl0b3IoKS5xdWVyeUZvcm1hdEJsb2NrU3RhdGUoYSl9fSxrPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuJGVkaXRvcigpLndyYXBTZWxlY3Rpb24oXCJmb3JtYXRCbG9ja1wiLFwiPFwiK3RoaXMubmFtZS50b1VwcGVyQ2FzZSgpK1wiPlwiKX07YW5ndWxhci5mb3JFYWNoKFtcImgxXCIsXCJoMlwiLFwiaDNcIixcImg0XCIsXCJoNVwiLFwiaDZcIl0sZnVuY3Rpb24oYil7YShiLnRvTG93ZXJDYXNlKCkse2J1dHRvbnRleHQ6Yi50b1VwcGVyQ2FzZSgpLHRvb2x0aXB0ZXh0OmMuaGVhZGluZy50b29sdGlwK2IuY2hhckF0KDEpLGFjdGlvbjprLGFjdGl2ZVN0YXRlOmooYi50b0xvd2VyQ2FzZSgpKX0pfSksYShcInBcIix7YnV0dG9udGV4dDpcIlBcIix0b29sdGlwdGV4dDpjLnAudG9vbHRpcCxhY3Rpb246ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy4kZWRpdG9yKCkud3JhcFNlbGVjdGlvbihcImZvcm1hdEJsb2NrXCIsXCI8UD5cIil9LGFjdGl2ZVN0YXRlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuJGVkaXRvcigpLnF1ZXJ5Rm9ybWF0QmxvY2tTdGF0ZShcInBcIil9fSksXHJcbi8vIGtleTogcHJlIC0+IHRhVHJhbnNsYXRpb25zW2tleV0udG9vbHRpcCwgdGFUcmFuc2xhdGlvbnNba2V5XS5idXR0b250ZXh0XHJcbmEoXCJwcmVcIix7YnV0dG9udGV4dDpcInByZVwiLHRvb2x0aXB0ZXh0OmMucHJlLnRvb2x0aXAsYWN0aW9uOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuJGVkaXRvcigpLndyYXBTZWxlY3Rpb24oXCJmb3JtYXRCbG9ja1wiLFwiPFBSRT5cIil9LGFjdGl2ZVN0YXRlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuJGVkaXRvcigpLnF1ZXJ5Rm9ybWF0QmxvY2tTdGF0ZShcInByZVwiKX19KSxhKFwidWxcIix7aWNvbmNsYXNzOlwiZmEgZmEtbGlzdC11bFwiLHRvb2x0aXB0ZXh0OmMudWwudG9vbHRpcCxhY3Rpb246ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy4kZWRpdG9yKCkud3JhcFNlbGVjdGlvbihcImluc2VydFVub3JkZXJlZExpc3RcIixudWxsKX0sYWN0aXZlU3RhdGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy4kZWRpdG9yKCkucXVlcnlDb21tYW5kU3RhdGUoXCJpbnNlcnRVbm9yZGVyZWRMaXN0XCIpfX0pLGEoXCJvbFwiLHtpY29uY2xhc3M6XCJmYSBmYS1saXN0LW9sXCIsdG9vbHRpcHRleHQ6Yy5vbC50b29sdGlwLGFjdGlvbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLiRlZGl0b3IoKS53cmFwU2VsZWN0aW9uKFwiaW5zZXJ0T3JkZXJlZExpc3RcIixudWxsKX0sYWN0aXZlU3RhdGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy4kZWRpdG9yKCkucXVlcnlDb21tYW5kU3RhdGUoXCJpbnNlcnRPcmRlcmVkTGlzdFwiKX19KSxhKFwicXVvdGVcIix7aWNvbmNsYXNzOlwiZmEgZmEtcXVvdGUtcmlnaHRcIix0b29sdGlwdGV4dDpjLnF1b3RlLnRvb2x0aXAsYWN0aW9uOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuJGVkaXRvcigpLndyYXBTZWxlY3Rpb24oXCJmb3JtYXRCbG9ja1wiLFwiPEJMT0NLUVVPVEU+XCIpfSxhY3RpdmVTdGF0ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLiRlZGl0b3IoKS5xdWVyeUZvcm1hdEJsb2NrU3RhdGUoXCJibG9ja3F1b3RlXCIpfX0pLGEoXCJ1bmRvXCIse2ljb25jbGFzczpcImZhIGZhLXVuZG9cIix0b29sdGlwdGV4dDpjLnVuZG8udG9vbHRpcCxhY3Rpb246ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy4kZWRpdG9yKCkud3JhcFNlbGVjdGlvbihcInVuZG9cIixudWxsKX19KSxhKFwicmVkb1wiLHtpY29uY2xhc3M6XCJmYSBmYS1yZXBlYXRcIix0b29sdGlwdGV4dDpjLnJlZG8udG9vbHRpcCxhY3Rpb246ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy4kZWRpdG9yKCkud3JhcFNlbGVjdGlvbihcInJlZG9cIixudWxsKX19KSxhKFwiYm9sZFwiLHtpY29uY2xhc3M6XCJmYSBmYS1ib2xkXCIsdG9vbHRpcHRleHQ6Yy5ib2xkLnRvb2x0aXAsYWN0aW9uOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuJGVkaXRvcigpLndyYXBTZWxlY3Rpb24oXCJib2xkXCIsbnVsbCl9LGFjdGl2ZVN0YXRlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuJGVkaXRvcigpLnF1ZXJ5Q29tbWFuZFN0YXRlKFwiYm9sZFwiKX0sY29tbWFuZEtleUNvZGU6OTh9KSxhKFwianVzdGlmeUxlZnRcIix7aWNvbmNsYXNzOlwiZmEgZmEtYWxpZ24tbGVmdFwiLHRvb2x0aXB0ZXh0OmMuanVzdGlmeUxlZnQudG9vbHRpcCxhY3Rpb246ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy4kZWRpdG9yKCkud3JhcFNlbGVjdGlvbihcImp1c3RpZnlMZWZ0XCIsbnVsbCl9LGFjdGl2ZVN0YXRlOmZ1bmN0aW9uKGEpey8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiAqL1xyXG5pZihhJiZcIiNkb2N1bWVudFwiPT09YS5ub2RlTmFtZSlyZXR1cm4hMTt2YXIgYj0hMTtyZXR1cm4gYSYmKGI9XCJsZWZ0XCI9PT1hLmNzcyhcInRleHQtYWxpZ25cIil8fFwibGVmdFwiPT09YS5hdHRyKFwiYWxpZ25cIil8fFwicmlnaHRcIiE9PWEuY3NzKFwidGV4dC1hbGlnblwiKSYmXCJjZW50ZXJcIiE9PWEuY3NzKFwidGV4dC1hbGlnblwiKSYmXCJqdXN0aWZ5XCIhPT1hLmNzcyhcInRleHQtYWxpZ25cIikmJiF0aGlzLiRlZGl0b3IoKS5xdWVyeUNvbW1hbmRTdGF0ZShcImp1c3RpZnlSaWdodFwiKSYmIXRoaXMuJGVkaXRvcigpLnF1ZXJ5Q29tbWFuZFN0YXRlKFwianVzdGlmeUNlbnRlclwiKSYmIXRoaXMuJGVkaXRvcigpLnF1ZXJ5Q29tbWFuZFN0YXRlKFwianVzdGlmeUZ1bGxcIikpLGI9Ynx8dGhpcy4kZWRpdG9yKCkucXVlcnlDb21tYW5kU3RhdGUoXCJqdXN0aWZ5TGVmdFwiKX19KSxhKFwianVzdGlmeVJpZ2h0XCIse2ljb25jbGFzczpcImZhIGZhLWFsaWduLXJpZ2h0XCIsdG9vbHRpcHRleHQ6Yy5qdXN0aWZ5UmlnaHQudG9vbHRpcCxhY3Rpb246ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy4kZWRpdG9yKCkud3JhcFNlbGVjdGlvbihcImp1c3RpZnlSaWdodFwiLG51bGwpfSxhY3RpdmVTdGF0ZTpmdW5jdGlvbihhKXsvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogKi9cclxuaWYoYSYmXCIjZG9jdW1lbnRcIj09PWEubm9kZU5hbWUpcmV0dXJuITE7dmFyIGI9ITE7cmV0dXJuIGEmJihiPVwicmlnaHRcIj09PWEuY3NzKFwidGV4dC1hbGlnblwiKSksYj1ifHx0aGlzLiRlZGl0b3IoKS5xdWVyeUNvbW1hbmRTdGF0ZShcImp1c3RpZnlSaWdodFwiKX19KSxhKFwianVzdGlmeUZ1bGxcIix7aWNvbmNsYXNzOlwiZmEgZmEtYWxpZ24tanVzdGlmeVwiLHRvb2x0aXB0ZXh0OmMuanVzdGlmeUZ1bGwudG9vbHRpcCxhY3Rpb246ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy4kZWRpdG9yKCkud3JhcFNlbGVjdGlvbihcImp1c3RpZnlGdWxsXCIsbnVsbCl9LGFjdGl2ZVN0YXRlOmZ1bmN0aW9uKGEpe3ZhciBiPSExO3JldHVybiBhJiYoYj1cImp1c3RpZnlcIj09PWEuY3NzKFwidGV4dC1hbGlnblwiKSksYj1ifHx0aGlzLiRlZGl0b3IoKS5xdWVyeUNvbW1hbmRTdGF0ZShcImp1c3RpZnlGdWxsXCIpfX0pLGEoXCJqdXN0aWZ5Q2VudGVyXCIse2ljb25jbGFzczpcImZhIGZhLWFsaWduLWNlbnRlclwiLHRvb2x0aXB0ZXh0OmMuanVzdGlmeUNlbnRlci50b29sdGlwLGFjdGlvbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLiRlZGl0b3IoKS53cmFwU2VsZWN0aW9uKFwianVzdGlmeUNlbnRlclwiLG51bGwpfSxhY3RpdmVTdGF0ZTpmdW5jdGlvbihhKXsvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogKi9cclxuaWYoYSYmXCIjZG9jdW1lbnRcIj09PWEubm9kZU5hbWUpcmV0dXJuITE7dmFyIGI9ITE7cmV0dXJuIGEmJihiPVwiY2VudGVyXCI9PT1hLmNzcyhcInRleHQtYWxpZ25cIikpLGI9Ynx8dGhpcy4kZWRpdG9yKCkucXVlcnlDb21tYW5kU3RhdGUoXCJqdXN0aWZ5Q2VudGVyXCIpfX0pLGEoXCJpbmRlbnRcIix7aWNvbmNsYXNzOlwiZmEgZmEtaW5kZW50XCIsdG9vbHRpcHRleHQ6Yy5pbmRlbnQudG9vbHRpcCxhY3Rpb246ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy4kZWRpdG9yKCkud3JhcFNlbGVjdGlvbihcImluZGVudFwiLG51bGwpfSxhY3RpdmVTdGF0ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLiRlZGl0b3IoKS5xdWVyeUZvcm1hdEJsb2NrU3RhdGUoXCJibG9ja3F1b3RlXCIpfSxjb21tYW5kS2V5Q29kZTpcIlRhYktleVwifSksYShcIm91dGRlbnRcIix7aWNvbmNsYXNzOlwiZmEgZmEtb3V0ZGVudFwiLHRvb2x0aXB0ZXh0OmMub3V0ZGVudC50b29sdGlwLGFjdGlvbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLiRlZGl0b3IoKS53cmFwU2VsZWN0aW9uKFwib3V0ZGVudFwiLG51bGwpfSxhY3RpdmVTdGF0ZTpmdW5jdGlvbigpe3JldHVybiExfSxjb21tYW5kS2V5Q29kZTpcIlNoaWZ0VGFiS2V5XCJ9KSxhKFwiaXRhbGljc1wiLHtpY29uY2xhc3M6XCJmYSBmYS1pdGFsaWNcIix0b29sdGlwdGV4dDpjLml0YWxpYy50b29sdGlwLGFjdGlvbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLiRlZGl0b3IoKS53cmFwU2VsZWN0aW9uKFwiaXRhbGljXCIsbnVsbCl9LGFjdGl2ZVN0YXRlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuJGVkaXRvcigpLnF1ZXJ5Q29tbWFuZFN0YXRlKFwiaXRhbGljXCIpfSxjb21tYW5kS2V5Q29kZToxMDV9KSxhKFwidW5kZXJsaW5lXCIse2ljb25jbGFzczpcImZhIGZhLXVuZGVybGluZVwiLHRvb2x0aXB0ZXh0OmMudW5kZXJsaW5lLnRvb2x0aXAsYWN0aW9uOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuJGVkaXRvcigpLndyYXBTZWxlY3Rpb24oXCJ1bmRlcmxpbmVcIixudWxsKX0sYWN0aXZlU3RhdGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy4kZWRpdG9yKCkucXVlcnlDb21tYW5kU3RhdGUoXCJ1bmRlcmxpbmVcIil9LGNvbW1hbmRLZXlDb2RlOjExN30pLGEoXCJzdHJpa2VUaHJvdWdoXCIse2ljb25jbGFzczpcImZhIGZhLXN0cmlrZXRocm91Z2hcIix0b29sdGlwdGV4dDpjLnN0cmlrZVRocm91Z2gudG9vbHRpcCxhY3Rpb246ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy4kZWRpdG9yKCkud3JhcFNlbGVjdGlvbihcInN0cmlrZVRocm91Z2hcIixudWxsKX0sYWN0aXZlU3RhdGU6ZnVuY3Rpb24oKXtyZXR1cm4gZG9jdW1lbnQucXVlcnlDb21tYW5kU3RhdGUoXCJzdHJpa2VUaHJvdWdoXCIpfX0pLGEoXCJjbGVhclwiLHtpY29uY2xhc3M6XCJmYSBmYS1iYW5cIix0b29sdGlwdGV4dDpjLmNsZWFyLnRvb2x0aXAsYWN0aW9uOmZ1bmN0aW9uKGEsYil7dmFyIGM7dGhpcy4kZWRpdG9yKCkud3JhcFNlbGVjdGlvbihcInJlbW92ZUZvcm1hdFwiLG51bGwpO3ZhciBlPWFuZ3VsYXIuZWxlbWVudChkLmdldFNlbGVjdGlvbkVsZW1lbnQoKSk7Yz1kLmdldEFsbFNlbGVjdGVkRWxlbWVudHMoKTtcclxuLy8kbG9nLmxvZygnc2VsZWN0ZWRFbGVtZW50czonLCBzZWxlY3RlZEVsZW1lbnRzKTtcclxuLy8gcmVtb3ZlIGxpc3RzXHJcbnZhciBmPWZ1bmN0aW9uKGEsYil7YT1hbmd1bGFyLmVsZW1lbnQoYSk7dmFyIGM9YjtyZXR1cm4gYnx8KGM9YSksYW5ndWxhci5mb3JFYWNoKGEuY2hpbGRyZW4oKSxmdW5jdGlvbihhKXtpZihcInVsXCI9PT1hLnRhZ05hbWUudG9Mb3dlckNhc2UoKXx8XCJvbFwiPT09YS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpYz1mKGEsYyk7ZWxzZXt2YXIgYj1hbmd1bGFyLmVsZW1lbnQoXCI8cD48L3A+XCIpO2IuaHRtbChhbmd1bGFyLmVsZW1lbnQoYSkuaHRtbCgpKSxjLmFmdGVyKGIpLGM9Yn19KSxhLnJlbW92ZSgpLGN9O2FuZ3VsYXIuZm9yRWFjaChjLGZ1bmN0aW9uKGEpe1widWxcIiE9PWEubm9kZU5hbWUudG9Mb3dlckNhc2UoKSYmXCJvbFwiIT09YS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpfHxcclxuLy9jb25zb2xlLmxvZygncmVtb3ZlTGlzdEVsZW1lbnRzJywgZWxlbWVudCk7XHJcbmYoYSl9KSxhbmd1bGFyLmZvckVhY2goZS5maW5kKFwidWxcIiksZiksYW5ndWxhci5mb3JFYWNoKGUuZmluZChcIm9sXCIpLGYpO1xyXG4vLyBjbGVhciBvdXQgYWxsIGNsYXNzIGF0dHJpYnV0ZXMuIFRoZXNlIGRvIG5vdCBzZWVtIHRvIGJlIGNsZWFyZWQgdmlhIHJlbW92ZUZvcm1hdFxyXG52YXIgZz10aGlzLiRlZGl0b3IoKSxoPWZ1bmN0aW9uKGEpe2E9YW5ndWxhci5lbGVtZW50KGEpLC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiB0aGlzIGlzIG5vdCB0cmlnZ2VyZWQgaW4gdGVzdHMgYW55IGxvbmdlciBzaW5jZSB3ZSBub3cgbmV2ZXIgc2VsZWN0IHRoZSB3aG9sZSBkaXNwbGF5RUxlbWVudCAqL1xyXG5hWzBdIT09Zy5kaXNwbGF5RWxlbWVudHMudGV4dFswXSYmYS5yZW1vdmVBdHRyKFwiY2xhc3NcIiksYW5ndWxhci5mb3JFYWNoKGEuY2hpbGRyZW4oKSxoKX07YW5ndWxhci5mb3JFYWNoKGUsaCksXHJcbi8vIGNoZWNrIGlmIGluIGxpc3QuIElmIG5vdCBpbiBsaXN0IHRoZW4gdXNlIGZvcm1hdEJsb2NrIG9wdGlvblxyXG5lWzBdJiZcImxpXCIhPT1lWzBdLnRhZ05hbWUudG9Mb3dlckNhc2UoKSYmXCJvbFwiIT09ZVswXS50YWdOYW1lLnRvTG93ZXJDYXNlKCkmJlwidWxcIiE9PWVbMF0udGFnTmFtZS50b0xvd2VyQ2FzZSgpJiZ0aGlzLiRlZGl0b3IoKS53cmFwU2VsZWN0aW9uKFwiZm9ybWF0QmxvY2tcIixcImRlZmF1bHRcIiksYigpfX0pOy8qIGpzaGludCAtVzA5OSAqL1xyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5cdCAvLyAgd2UgZG9uJ3QgdXNlIHRoaXMgY29kZSAtIHNpbmNlIHRoZSBwcmV2aW91cyB3YXkgQ0xFQVIgaXMgZXhwZWN0ZWQgdG8gd29yayBkb2VzIG5vdCBjbGVhciBwYXJ0aWFsbHkgc2VsZWN0ZWQgPGxpPlxyXG5cclxuXHQgdmFyIHJlbW92ZUxpc3RFbGVtZW50ID0gZnVuY3Rpb24obGlzdEUpe1xyXG5cdFx0XHRcdGNvbnNvbGUubG9nKGxpc3RFKTtcclxuXHRcdFx0XHR2YXIgX2xpc3QgPSBsaXN0RS5wYXJlbnROb2RlLmNoaWxkTm9kZXM7XHJcblx0XHRcdFx0Y29uc29sZS5sb2coJ19saXN0JywgX2xpc3QpO1xyXG5cdFx0XHRcdHZhciBfcHJlTGlzID0gW10sIF9wb3N0TGlzID0gW10sIF9mb3VuZCA9IGZhbHNlO1xyXG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBfbGlzdC5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0aWYgKF9saXN0W2ldID09PSBsaXN0RSkge1xyXG5cdFx0XHRcdFx0XHRfZm91bmQgPSB0cnVlO1xyXG5cdFx0XHRcdFx0fSBlbHNlIGlmICghX2ZvdW5kKSBfcHJlTGlzLnB1c2goX2xpc3RbaV0pO1xyXG5cdFx0XHRcdFx0ZWxzZSBfcG9zdExpcy5wdXNoKF9saXN0W2ldKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dmFyIF9wYXJlbnQgPSBhbmd1bGFyLmVsZW1lbnQobGlzdEUucGFyZW50Tm9kZSk7XHJcblx0XHRcdFx0dmFyIG5ld0VsZW0gPSBhbmd1bGFyLmVsZW1lbnQoJzxwPjwvcD4nKTtcclxuXHRcdFx0XHRuZXdFbGVtLmh0bWwoYW5ndWxhci5lbGVtZW50KGxpc3RFKS5odG1sKCkpO1xyXG5cdFx0XHRcdGlmIChfcHJlTGlzLmxlbmd0aCA9PT0gMCB8fCBfcG9zdExpcy5sZW5ndGggPT09IDApIHtcclxuXHRcdFx0XHRcdGlmIChfcG9zdExpcy5sZW5ndGggPT09IDApIF9wYXJlbnQuYWZ0ZXIobmV3RWxlbSk7XHJcblx0XHRcdFx0XHRlbHNlIF9wYXJlbnRbMF0ucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3RWxlbVswXSwgX3BhcmVudFswXSk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKF9wcmVMaXMubGVuZ3RoID09PSAwICYmIF9wb3N0TGlzLmxlbmd0aCA9PT0gMCkgX3BhcmVudC5yZW1vdmUoKTtcclxuXHRcdFx0XHRcdGVsc2UgYW5ndWxhci5lbGVtZW50KGxpc3RFKS5yZW1vdmUoKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dmFyIF9maXJzdExpc3QgPSBhbmd1bGFyLmVsZW1lbnQoJzwnICsgX3BhcmVudFswXS50YWdOYW1lICsgJz48LycgKyBfcGFyZW50WzBdLnRhZ05hbWUgKyAnPicpO1xyXG5cdFx0XHRcdFx0dmFyIF9zZWNvbmRMaXN0ID0gYW5ndWxhci5lbGVtZW50KCc8JyArIF9wYXJlbnRbMF0udGFnTmFtZSArICc+PC8nICsgX3BhcmVudFswXS50YWdOYW1lICsgJz4nKTtcclxuXHRcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBfcHJlTGlzLmxlbmd0aDsgaSsrKSBfZmlyc3RMaXN0LmFwcGVuZChhbmd1bGFyLmVsZW1lbnQoX3ByZUxpc1tpXSkpO1xyXG5cdFx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IF9wb3N0TGlzLmxlbmd0aDsgaSsrKSBfc2Vjb25kTGlzdC5hcHBlbmQoYW5ndWxhci5lbGVtZW50KF9wb3N0TGlzW2ldKSk7XHJcblx0XHRcdFx0XHRfcGFyZW50LmFmdGVyKF9zZWNvbmRMaXN0KTtcclxuXHRcdFx0XHRcdF9wYXJlbnQuYWZ0ZXIobmV3RWxlbSk7XHJcblx0XHRcdFx0XHRfcGFyZW50LmFmdGVyKF9maXJzdExpc3QpO1xyXG5cdFx0XHRcdFx0X3BhcmVudC5yZW1vdmUoKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dGFTZWxlY3Rpb24uc2V0U2VsZWN0aW9uVG9FbGVtZW50RW5kKG5ld0VsZW1bMF0pO1xyXG5cdFx0XHR9O1xyXG5cclxuXHQgZWxlbWVudHNTZWVuID0gW107XHJcblx0IGlmIChzZWxlY3RlZEVsZW1lbnRzLmxlbmd0aCAhPT0wKSBjb25zb2xlLmxvZyhzZWxlY3RlZEVsZW1lbnRzKTtcclxuXHQgYW5ndWxhci5mb3JFYWNoKHNlbGVjdGVkRWxlbWVudHMsIGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcblx0XHRcdFx0aWYgKGVsZW1lbnRzU2Vlbi5pbmRleE9mKGVsZW1lbnQpICE9PSAtMSB8fCBlbGVtZW50c1NlZW4uaW5kZXhPZihlbGVtZW50LnBhcmVudEVsZW1lbnQpICE9PSAtMSkge1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbGVtZW50c1NlZW4ucHVzaChlbGVtZW50KTtcclxuXHRcdFx0XHRpZiAoZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnbGknKSB7XHJcblx0XHRcdFx0XHRjb25zb2xlLmxvZygncmVtb3ZlTGlzdEVsZW1lbnQnLCBlbGVtZW50KTtcclxuXHRcdFx0XHRcdHJlbW92ZUxpc3RFbGVtZW50KGVsZW1lbnQpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNlIGlmIChlbGVtZW50LnBhcmVudEVsZW1lbnQgJiYgZWxlbWVudC5wYXJlbnRFbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdsaScpIHtcclxuXHRcdFx0XHRcdGNvbnNvbGUubG9nKCdyZW1vdmVMaXN0RWxlbWVudCcsIGVsZW1lbnQucGFyZW50RWxlbWVudCk7XHJcblx0XHRcdFx0XHRlbGVtZW50c1NlZW4ucHVzaChlbGVtZW50LnBhcmVudEVsZW1lbnQpO1xyXG5cdFx0XHRcdFx0cmVtb3ZlTGlzdEVsZW1lbnQoZWxlbWVudC5wYXJlbnRFbGVtZW50KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cdCAqKioqKioqKioqKioqKioqKioqKioqL1xyXG4vKioqKioqKioqKioqKioqKioqKioqKlxyXG5cdCBpZihwb3NzaWJsZU5vZGVzWzBdLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2xpJyl7XHJcblx0XHRcdFx0dmFyIF9saXN0ID0gcG9zc2libGVOb2Rlc1swXS5wYXJlbnROb2RlLmNoaWxkTm9kZXM7XHJcblx0XHRcdFx0dmFyIF9wcmVMaXMgPSBbXSwgX3Bvc3RMaXMgPSBbXSwgX2ZvdW5kID0gZmFsc2U7XHJcblx0XHRcdFx0Zm9yKGkgPSAwOyBpIDwgX2xpc3QubGVuZ3RoOyBpKyspe1xyXG5cdFx0XHRcdFx0aWYoX2xpc3RbaV0gPT09IHBvc3NpYmxlTm9kZXNbMF0pe1xyXG5cdFx0XHRcdFx0XHRfZm91bmQgPSB0cnVlO1xyXG5cdFx0XHRcdFx0fWVsc2UgaWYoIV9mb3VuZCkgX3ByZUxpcy5wdXNoKF9saXN0W2ldKTtcclxuXHRcdFx0XHRcdGVsc2UgX3Bvc3RMaXMucHVzaChfbGlzdFtpXSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHZhciBfcGFyZW50ID0gYW5ndWxhci5lbGVtZW50KHBvc3NpYmxlTm9kZXNbMF0ucGFyZW50Tm9kZSk7XHJcblx0XHRcdFx0dmFyIG5ld0VsZW0gPSBhbmd1bGFyLmVsZW1lbnQoJzxwPjwvcD4nKTtcclxuXHRcdFx0XHRuZXdFbGVtLmh0bWwoYW5ndWxhci5lbGVtZW50KHBvc3NpYmxlTm9kZXNbMF0pLmh0bWwoKSk7XHJcblx0XHRcdFx0aWYoX3ByZUxpcy5sZW5ndGggPT09IDAgfHwgX3Bvc3RMaXMubGVuZ3RoID09PSAwKXtcclxuXHRcdFx0XHRcdGlmKF9wb3N0TGlzLmxlbmd0aCA9PT0gMCkgX3BhcmVudC5hZnRlcihuZXdFbGVtKTtcclxuXHRcdFx0XHRcdGVsc2UgX3BhcmVudFswXS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShuZXdFbGVtWzBdLCBfcGFyZW50WzBdKTtcclxuXHJcblx0XHRcdFx0XHRpZihfcHJlTGlzLmxlbmd0aCA9PT0gMCAmJiBfcG9zdExpcy5sZW5ndGggPT09IDApIF9wYXJlbnQucmVtb3ZlKCk7XHJcblx0XHRcdFx0XHRlbHNlIGFuZ3VsYXIuZWxlbWVudChwb3NzaWJsZU5vZGVzWzBdKS5yZW1vdmUoKTtcclxuXHRcdFx0XHR9ZWxzZXtcclxuXHRcdFx0XHRcdHZhciBfZmlyc3RMaXN0ID0gYW5ndWxhci5lbGVtZW50KCc8JytfcGFyZW50WzBdLnRhZ05hbWUrJz48LycrX3BhcmVudFswXS50YWdOYW1lKyc+Jyk7XHJcblx0XHRcdFx0XHR2YXIgX3NlY29uZExpc3QgPSBhbmd1bGFyLmVsZW1lbnQoJzwnK19wYXJlbnRbMF0udGFnTmFtZSsnPjwvJytfcGFyZW50WzBdLnRhZ05hbWUrJz4nKTtcclxuXHRcdFx0XHRcdGZvcihpID0gMDsgaSA8IF9wcmVMaXMubGVuZ3RoOyBpKyspIF9maXJzdExpc3QuYXBwZW5kKGFuZ3VsYXIuZWxlbWVudChfcHJlTGlzW2ldKSk7XHJcblx0XHRcdFx0XHRmb3IoaSA9IDA7IGkgPCBfcG9zdExpcy5sZW5ndGg7IGkrKykgX3NlY29uZExpc3QuYXBwZW5kKGFuZ3VsYXIuZWxlbWVudChfcG9zdExpc1tpXSkpO1xyXG5cdFx0XHRcdFx0X3BhcmVudC5hZnRlcihfc2Vjb25kTGlzdCk7XHJcblx0XHRcdFx0XHRfcGFyZW50LmFmdGVyKG5ld0VsZW0pO1xyXG5cdFx0XHRcdFx0X3BhcmVudC5hZnRlcihfZmlyc3RMaXN0KTtcclxuXHRcdFx0XHRcdF9wYXJlbnQucmVtb3ZlKCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHRhU2VsZWN0aW9uLnNldFNlbGVjdGlvblRvRWxlbWVudEVuZChuZXdFbGVtWzBdKTtcclxuXHRcdFx0fVxyXG5cdCAqKioqKioqKioqKioqKioqKioqL1xyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogaWYgaXQncyBqYXZhc2NyaXB0IGRvbid0IHdvcnJ5IC0gdGhvdWdoIHByb2JhYmx5IHNob3VsZCBzaG93IHNvbWUga2luZCBvZiBlcnJvciBtZXNzYWdlICovXHJcbnZhciBsPWZ1bmN0aW9uKGEpe3JldHVybiBhLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihcImphdmFzY3JpcHRcIikhPT0tMX07YShcImluc2VydEltYWdlXCIse2ljb25jbGFzczpcImZhIGZhLXBpY3R1cmUtb1wiLHRvb2x0aXB0ZXh0OmMuaW5zZXJ0SW1hZ2UudG9vbHRpcCxhY3Rpb246ZnVuY3Rpb24oKXt2YXIgYTtpZihhPWIucHJvbXB0KGMuaW5zZXJ0SW1hZ2UuZGlhbG9nUHJvbXB0LFwiaHR0cDovL1wiKSxhJiZcIlwiIT09YSYmXCJodHRwOi8vXCIhPT1hJiYhbChhKSl7ZC5nZXRTZWxlY3Rpb25FbGVtZW50KCkudGFnTmFtZSYmXCJhXCI9PT1kLmdldFNlbGVjdGlvbkVsZW1lbnQoKS50YWdOYW1lLnRvTG93ZXJDYXNlKCkmJlxyXG4vLyBkdWUgdG8gZGlmZmVyZW5jZXMgaW4gaW1wbGVtZW50YXRpb24gYmV0d2VlbiBGaXJlRm94IGFuZCBDaHJvbWUsIHdlIG11c3QgbW92ZSB0aGVcclxuLy8gaW5zZXJ0aW9uIHBvaW50IHBhc3QgdGhlIDxhPiBlbGVtZW50LCBvdGhlcndpc2UgRmlyZUZveCBpbnNlcnRzIGluc2lkZSB0aGUgPGE+XHJcbi8vIFdpdGggdGhpcyBjaGFuZ2UsIGJvdGggRmlyZUZveCBhbmQgQ2hyb21lIGJlaGF2ZSB0aGUgc2FtZSB3YXkhXHJcbmQuc2V0U2VsZWN0aW9uQWZ0ZXJFbGVtZW50KGQuZ2V0U2VsZWN0aW9uRWxlbWVudCgpKTtcclxuLy8gSW4gdGhlIHBhc3Qgd2UgdXNlZCB0aGUgc2ltcGxlIHN0YXRlbWVudDpcclxuLy9yZXR1cm4gdGhpcy4kZWRpdG9yKCkud3JhcFNlbGVjdGlvbignaW5zZXJ0SW1hZ2UnLCBpbWFnZUxpbmssIHRydWUpO1xyXG4vL1xyXG4vLyBIb3dldmVyIG9uIEZpcmVmb3ggb25seSwgd2hlbiB0aGUgY29udGVudCBpcyBlbXB0eSB0aGlzIGlzIGEgcHJvYmxlbVxyXG4vLyBTZWUgSXNzdWUgIzEyMDFcclxuLy8gSW52ZXN0aWdhdGlvbiByZXZlYWxzIHRoYXQgRmlyZWZveCBvbmx5IGluc2VydHMgYSA8cD4gb25seSEhISFcclxuLy8gU28gbm93IHdlIHVzZSBpbnNlcnRIVE1MIGhlcmUgYW5kIGFsbCBpcyBmaW5lLlxyXG4vLyBOT1RFOiB0aGlzIGlzIHdoYXQgJ2luc2VydEltYWdlJyBpcyBzdXBwb3NlZCB0byBkbyBhbnl3YXkhXHJcbnZhciBlPSc8aW1nIHNyYz1cIicrYSsnXCI+JztyZXR1cm4gdGhpcy4kZWRpdG9yKCkud3JhcFNlbGVjdGlvbihcImluc2VydEhUTUxcIixlLCEwKX19LG9uRWxlbWVudFNlbGVjdDp7ZWxlbWVudDpcImltZ1wiLGFjdGlvbjplLmltZ09uU2VsZWN0QWN0aW9ufX0pLGEoXCJpbnNlcnRWaWRlb1wiLHtpY29uY2xhc3M6XCJmYSBmYS15b3V0dWJlLXBsYXlcIix0b29sdGlwdGV4dDpjLmluc2VydFZpZGVvLnRvb2x0aXAsYWN0aW9uOmZ1bmN0aW9uKCl7dmFyIGE7XHJcbi8vIGJsb2NrIGphdmFzY3JpcHQgaGVyZVxyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZTogaWYgaXQncyBqYXZhc2NyaXB0IGRvbid0IHdvcnJ5IC0gdGhvdWdoIHByb2JhYmx5IHNob3VsZCBzaG93IHNvbWUga2luZCBvZiBlcnJvciBtZXNzYWdlICovXHJcbmlmKGE9Yi5wcm9tcHQoYy5pbnNlcnRWaWRlby5kaWFsb2dQcm9tcHQsXCJodHRwczovL1wiKSwhbChhKSYmYSYmXCJcIiE9PWEmJlwiaHR0cHM6Ly9cIiE9PWEmJih2aWRlb0lkPWUuZXh0cmFjdFlvdXR1YmVWaWRlb0lkKGEpLHZpZGVvSWQpKXtcclxuLy8gY3JlYXRlIHRoZSBlbWJlZCBsaW5rXHJcbnZhciBmPVwiaHR0cHM6Ly93d3cueW91dHViZS5jb20vZW1iZWQvXCIrdmlkZW9JZCxnPSc8aW1nIGNsYXNzPVwidGEtaW5zZXJ0LXZpZGVvXCIgc3JjPVwiaHR0cHM6Ly9pbWcueW91dHViZS5jb20vdmkvJyt2aWRlb0lkKycvaHFkZWZhdWx0LmpwZ1wiIHRhLWluc2VydC12aWRlbz1cIicrZisnXCIgY29udGVudGVkaXRhYmxlPVwiZmFsc2VcIiBhbGxvd2Z1bGxzY3JlZW49XCJ0cnVlXCIgZnJhbWVib3JkZXI9XCIwXCIgLz4nO1xyXG4vLyBpbnNlcnRcclxuLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IGRvbid0IGtub3cgaG93IHRvIHRlc3QgdGhpcy4uLiBzaW5jZSBpdCBuZWVkcyBhIGRpYWxvZ1Byb21wdCAqL1xyXG4vLyBkdWUgdG8gZGlmZmVyZW5jZXMgaW4gaW1wbGVtZW50YXRpb24gYmV0d2VlbiBGaXJlRm94IGFuZCBDaHJvbWUsIHdlIG11c3QgbW92ZSB0aGVcclxuLy8gaW5zZXJ0aW9uIHBvaW50IHBhc3QgdGhlIDxhPiBlbGVtZW50LCBvdGhlcndpc2UgRmlyZUZveCBpbnNlcnRzIGluc2lkZSB0aGUgPGE+XHJcbi8vIFdpdGggdGhpcyBjaGFuZ2UsIGJvdGggRmlyZUZveCBhbmQgQ2hyb21lIGJlaGF2ZSB0aGUgc2FtZSB3YXkhXHJcbnJldHVybiBkLmdldFNlbGVjdGlvbkVsZW1lbnQoKS50YWdOYW1lJiZcImFcIj09PWQuZ2V0U2VsZWN0aW9uRWxlbWVudCgpLnRhZ05hbWUudG9Mb3dlckNhc2UoKSYmZC5zZXRTZWxlY3Rpb25BZnRlckVsZW1lbnQoZC5nZXRTZWxlY3Rpb25FbGVtZW50KCkpLHRoaXMuJGVkaXRvcigpLndyYXBTZWxlY3Rpb24oXCJpbnNlcnRIVE1MXCIsZywhMCl9fSxvbkVsZW1lbnRTZWxlY3Q6e2VsZW1lbnQ6XCJpbWdcIixvbmx5V2l0aEF0dHJzOltcInRhLWluc2VydC12aWRlb1wiXSxhY3Rpb246ZS5pbWdPblNlbGVjdEFjdGlvbn19KSxhKFwiaW5zZXJ0TGlua1wiLHt0b29sdGlwdGV4dDpjLmluc2VydExpbmsudG9vbHRpcCxpY29uY2xhc3M6XCJmYSBmYS1saW5rXCIsYWN0aW9uOmZ1bmN0aW9uKCl7dmFyIGE7aWYoXHJcbi8vIGlmIHRoaXMgbGluayBoYXMgYWxyZWFkeSBiZWVuIHNldCwgd2UgbmVlZCB0byBqdXN0IGVkaXQgdGhlIGV4aXN0aW5nIGxpbmtcclxuLyogaXN0YW5idWwgaWdub3JlIGlmOiB3ZSBkbyBub3QgdGVzdCB0aGlzICovXHJcbmE9ZC5nZXRTZWxlY3Rpb25FbGVtZW50KCkudGFnTmFtZSYmXCJhXCI9PT1kLmdldFNlbGVjdGlvbkVsZW1lbnQoKS50YWdOYW1lLnRvTG93ZXJDYXNlKCk/Yi5wcm9tcHQoYy5pbnNlcnRMaW5rLmRpYWxvZ1Byb21wdCxkLmdldFNlbGVjdGlvbkVsZW1lbnQoKS5ocmVmKTpiLnByb21wdChjLmluc2VydExpbmsuZGlhbG9nUHJvbXB0LFwiaHR0cDovL1wiKSxhJiZcIlwiIT09YSYmXCJodHRwOi8vXCIhPT1hJiYhbChhKSlyZXR1cm4gdGhpcy4kZWRpdG9yKCkud3JhcFNlbGVjdGlvbihcImNyZWF0ZUxpbmtcIixhLCEwKX0sYWN0aXZlU3RhdGU6ZnVuY3Rpb24oYSl7cmV0dXJuISFhJiZcIkFcIj09PWFbMF0udGFnTmFtZX0sb25FbGVtZW50U2VsZWN0OntlbGVtZW50OlwiYVwiLGFjdGlvbjplLmFPblNlbGVjdEFjdGlvbn19KSxhKFwid29yZGNvdW50XCIse2Rpc3BsYXk6JzxkaXYgaWQ9XCJ0b29sYmFyV0NcIiBzdHlsZT1cImRpc3BsYXk6YmxvY2s7IG1pbi13aWR0aDoxMDBweDtcIj5Xb3JkczogPHNwYW4gbmctYmluZD1cIndvcmRjb3VudFwiPjwvc3Bhbj48L2Rpdj4nLGRpc2FibGVkOiEwLHdvcmRjb3VudDowLGFjdGl2ZVN0YXRlOmZ1bmN0aW9uKCl7Ly8gdGhpcyBmaXJlcyBvbiBrZXl1cFxyXG52YXIgYT10aGlzLiRlZGl0b3IoKS5kaXNwbGF5RWxlbWVudHMudGV4dCxiPWFbMF0uaW5uZXJIVE1MfHxcIlwiLGM9MDsvKiBpc3RhbmJ1bCBpZ25vcmUgaWY6IHdpbGwgZGVmYXVsdCB0byAnJyB3aGVuIHVuZGVmaW5lZCAqL1xyXG4vL1NldCBjdXJyZW50IHNjb3BlXHJcbi8vU2V0IGVkaXRvciBzY29wZVxyXG5yZXR1cm5cIlwiIT09Yi5yZXBsYWNlKC9cXHMqPFtePl0qPz5cXHMqL2csXCJcIikmJlwiXCIhPT1iLnRyaW0oKSYmKGM9Yi5yZXBsYWNlKC88XFwvPyhifGl8ZW18c3Ryb25nfHNwYW58dXxzdHJpa2V0aHJvdWdofGF8aW1nfHNtYWxsfHN1YnxzdXB8bGFiZWwpKCBbXj4qP10pPz4vZ2ksXCJcIikucmVwbGFjZSgvKDxbXj5dKj8+XFxzKjxbXj5dKj8+KS9naSxcIiBcIikucmVwbGFjZSgvKDxbXj5dKj8+KS9naSxcIlwiKS5yZXBsYWNlKC9cXHMrL2dpLFwiIFwiKS5tYXRjaCgvXFxTKy9nKS5sZW5ndGgpLHRoaXMud29yZGNvdW50PWMsdGhpcy4kZWRpdG9yKCkud29yZGNvdW50PWMsITF9fSksYShcImNoYXJjb3VudFwiLHtkaXNwbGF5Oic8ZGl2IGlkPVwidG9vbGJhckNDXCIgc3R5bGU9XCJkaXNwbGF5OmJsb2NrOyBtaW4td2lkdGg6MTIwcHg7XCI+Q2hhcmFjdGVyczogPHNwYW4gbmctYmluZD1cImNoYXJjb3VudFwiPjwvc3Bhbj48L2Rpdj4nLGRpc2FibGVkOiEwLGNoYXJjb3VudDowLGFjdGl2ZVN0YXRlOmZ1bmN0aW9uKCl7Ly8gdGhpcyBmaXJlcyBvbiBrZXl1cFxyXG52YXIgYT10aGlzLiRlZGl0b3IoKS5kaXNwbGF5RWxlbWVudHMudGV4dCxiPWFbMF0uaW5uZXJUZXh0fHxhWzBdLnRleHRDb250ZW50LGM9Yi5yZXBsYWNlKC8oXFxyXFxufFxcbnxcXHIpL2dtLFwiXCIpLnJlcGxhY2UoL15cXHMrL2csXCIgXCIpLnJlcGxhY2UoL1xccyskL2csXCIgXCIpLmxlbmd0aDtcclxuLy9TZXQgY3VycmVudCBzY29wZVxyXG4vL1NldCBlZGl0b3Igc2NvcGVcclxucmV0dXJuIHRoaXMuY2hhcmNvdW50PWMsdGhpcy4kZWRpdG9yKCkuY2hhcmNvdW50PWMsITF9fSl9XSk7Ly8gTk9URTogdGV4dEFuZ3VsYXJWZXJzaW9uIG11c3QgbWF0Y2ggdGhlIEdydW50ZmlsZS5qcyAnc2V0VmVyc2lvbicgdGFzay4uLi4gYW5kIGhhdmUgZm9ybWF0IHYvZCsuL2QrLi9kK1xyXG52YXIgZj1cInYxLjUuMTJcIixnPXtpZTpmdW5jdGlvbigpe2Zvcih2YXIgYSxiPTMsYz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLGQ9Yy5nZXRFbGVtZW50c0J5VGFnTmFtZShcImlcIik7Yy5pbm5lckhUTUw9XCI8IS0tW2lmIGd0IElFIFwiKyArK2IrXCJdPjxpPjwvaT48IVtlbmRpZl0tLT5cIixkWzBdOyk7cmV0dXJuIGI+ND9iOmF9KCksd2Via2l0Oi9BcHBsZVdlYktpdFxcLyhbXFxkLl0rKS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCksaXNGaXJlZm94Om5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5pbmRleE9mKFwiZmlyZWZveFwiKT4tMX0saD1ofHx7fTsvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogdW50ZXN0YWJsZSBicm93c2VyIGNoZWNrICovXHJcbmgubm93PWZ1bmN0aW9uKCl7cmV0dXJuIGgubm93fHxoLm1vek5vd3x8aC5tc05vd3x8aC5vTm93fHxoLndlYmtpdE5vd3x8ZnVuY3Rpb24oKXtyZXR1cm4obmV3IERhdGUpLmdldFRpbWUoKX19KCk7XHJcbi8vIEdsb2JhbCB0byB0ZXh0QW5ndWxhciBSRUdFWFAgdmFycyBmb3IgYmxvY2sgYW5kIGxpc3QgZWxlbWVudHMuXHJcbnZhciBpPS9eKGFkZHJlc3N8YXJ0aWNsZXxhc2lkZXxhdWRpb3xibG9ja3F1b3RlfGNhbnZhc3xjZW50ZXJ8ZGR8ZGl2fGRsfGZpZWxkc2V0fGZpZ2NhcHRpb258ZmlndXJlfGZvb3Rlcnxmb3JtfGgxfGgyfGgzfGg0fGg1fGg2fGhlYWRlcnxoZ3JvdXB8aHJ8bm9zY3JpcHR8b2x8b3V0cHV0fHB8cHJlfHNlY3Rpb258dGFibGV8dGZvb3R8dWx8dmlkZW8pJC9pLGo9L14odWx8bGl8b2wpJC9pLGs9L14oI3RleHR8c3BhbnxhZGRyZXNzfGFydGljbGV8YXNpZGV8YXVkaW98YmxvY2txdW90ZXxjYW52YXN8Y2VudGVyfGRkfGRpdnxkbHxmaWVsZHNldHxmaWdjYXB0aW9ufGZpZ3VyZXxmb290ZXJ8Zm9ybXxoMXxoMnxoM3xoNHxoNXxoNnxoZWFkZXJ8aGdyb3VwfGhyfG5vc2NyaXB0fG9sfG91dHB1dHxwfHByZXxzZWN0aW9ufHRhYmxlfHRmb290fHVsfHZpZGVvfGxpKSQvaTtcclxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL1RyaW0jQ29tcGF0aWJpbGl0eVxyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogdHJpbSBzaGltIGZvciBvbGRlciBicm93c2VycyAqL1xyXG5TdHJpbmcucHJvdG90eXBlLnRyaW18fChTdHJpbmcucHJvdG90eXBlLnRyaW09ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLFwiXCIpfSk7LypcclxuXHRDdXN0b20gc3R5bGVzaGVldCBmb3IgdGhlIHBsYWNlaG9sZGVycyBydWxlcy5cclxuXHRDcmVkaXQgdG86IGh0dHA6Ly9kYXZpZHdhbHNoLm5hbWUvYWRkLXJ1bGVzLXN0eWxlc2hlZXRzXHJcbiovXHJcbnZhciBsLG0sbixvLHAscTsvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZTogSUUgPDggdGVzdCovXHJcbmlmKGcuaWU+OHx8dm9pZCAwPT09Zy5pZSl7LyogaXN0YW5idWwgaWdub3JlIG5leHQ6IHByZWZlcmVuY2UgZm9yIHN0eWxlc2hlZXQgbG9hZGVkIGV4dGVybmFsbHkgKi9cclxuZm9yKHZhciByPWRvY3VtZW50LnN0eWxlU2hlZXRzLHM9MDtzPHIubGVuZ3RoO3MrKylpZigoMD09PXJbc10ubWVkaWEubGVuZ3RofHxyW3NdLm1lZGlhLm1lZGlhVGV4dC5tYXRjaCgvKGFsbHxzY3JlZW4pL2dpKSkmJnJbc10uaHJlZiYmcltzXS5ocmVmLm1hdGNoKC90ZXh0YW5ndWxhclxcLihtaW5cXC58KWNzcy9naSkpe2w9cltzXTticmVha30vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogcHJlZmVyZW5jZSBmb3Igc3R5bGVzaGVldCBsb2FkZWQgZXh0ZXJuYWxseSAqL1xyXG5sfHwoXHJcbi8vIHRoaXMgc2hlZXQgaXMgdXNlZCBmb3IgdGhlIHBsYWNlaG9sZGVycyBsYXRlciBvbi5cclxubD1mdW5jdGlvbigpe1xyXG4vLyBDcmVhdGUgdGhlIDxzdHlsZT4gdGFnXHJcbnZhciBhPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTsvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSA6IFdlYktpdCBoYWNrIDooICovXHJcbi8vIEFkZCB0aGUgPHN0eWxlPiBlbGVtZW50IHRvIHRoZSBwYWdlLCBhZGQgYXMgZmlyc3Qgc28gdGhlIHN0eWxlcyBjYW4gYmUgb3ZlcnJpZGRlbiBieSBjdXN0b20gc3R5bGVzaGVldHNcclxucmV0dXJuIGcud2Via2l0JiZhLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXCIpKSxkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF0uYXBwZW5kQ2hpbGQoYSksYS5zaGVldH0oKSksXHJcbi8vIHVzZSBhczogYWRkQ1NTUnVsZShcImhlYWRlclwiLCBcImZsb2F0OiBsZWZ0XCIpO1xyXG5tPWZ1bmN0aW9uKGEsYil7cmV0dXJuIG8obCxhLGIpfSxvPWZ1bmN0aW9uKGEsYixjKXt2YXIgZCxlO1xyXG4vLyByZXR1cm4gdGhlIGluc2VydGVkIHN0eWxlc2hlZXQgcnVsZVxyXG4vLyBUaGlzIG9yZGVyIGlzIGltcG9ydGFudCBhcyBJRSAxMSBoYXMgYm90aCBjc3NSdWxlcyBhbmQgcnVsZXMgYnV0IHRoZXkgaGF2ZSBkaWZmZXJlbnQgbGVuZ3RocyAtIGNzc1J1bGVzIGlzIGNvcnJlY3QsIHJ1bGVzIGdpdmVzIGFuIGVycm9yIGluIElFIDExXHJcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBicm93c2VyIGNhdGNoZXMgKi9cclxuLyogaXN0YW5idWwgaWdub3JlIGVsc2U6IHVudGVzdGFibGUgSUUgb3B0aW9uICovXHJcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBicm93c2VyIGNhdGNoZXMgKi9cclxucmV0dXJuIGEuY3NzUnVsZXM/ZD1NYXRoLm1heChhLmNzc1J1bGVzLmxlbmd0aC0xLDApOmEucnVsZXMmJihkPU1hdGgubWF4KGEucnVsZXMubGVuZ3RoLTEsMCkpLGEuaW5zZXJ0UnVsZT9hLmluc2VydFJ1bGUoYitcIntcIitjK1wifVwiLGQpOmEuYWRkUnVsZShiLGMsZCksbC5ydWxlcz9lPWwucnVsZXNbZF06bC5jc3NSdWxlcyYmKGU9bC5jc3NSdWxlc1tkXSksZX0scT1mdW5jdGlvbihhLGIpe3ZhciBjLGQ7Zm9yKGM9MDtjPGIubGVuZ3RoO2MrKykvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZTogY2hlY2sgZm9yIGNvcnJlY3QgcnVsZSAqL1xyXG5pZihiW2NdLmNzc1RleHQ9PT1hLmNzc1RleHQpe2Q9YzticmVha31yZXR1cm4gZH0sbj1mdW5jdGlvbihhKXtwKGwsYSl9LC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiB0ZXN0cyBhcmUgYnJvd3NlciBzcGVjaWZpYyAqL1xyXG5wPWZ1bmN0aW9uKGEsYil7dmFyIGM9YS5jc3NSdWxlc3x8YS5ydWxlcztpZihjJiYwIT09Yy5sZW5ndGgpe3ZhciBkPXEoYixjKTthLnJlbW92ZVJ1bGU/YS5yZW1vdmVSdWxlKGQpOmEuZGVsZXRlUnVsZShkKX19fWFuZ3VsYXIubW9kdWxlKFwidGV4dEFuZ3VsYXIuZmFjdG9yaWVzXCIsW10pLmZhY3RvcnkoXCJ0YUJyb3dzZXJUYWdcIixbZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24oYSl7LyogaXN0YW5idWwgaWdub3JlIG5leHQ6IGllIHNwZWNpZmljIHRlc3QgKi9cclxuLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IGllIHNwZWNpZmljIHRlc3QgKi9cclxucmV0dXJuIGE/XCJcIj09PWE/dm9pZCAwPT09Zy5pZT9cImRpdlwiOmcuaWU8PTg/XCJQXCI6XCJwXCI6Zy5pZTw9OD9hLnRvVXBwZXJDYXNlKCk6YTpnLmllPD04P1wiUFwiOlwicFwifX1dKS5mYWN0b3J5KFwidGFBcHBseUN1c3RvbVJlbmRlcmVyc1wiLFtcInRhQ3VzdG9tUmVuZGVyZXJzXCIsXCJ0YURPTVwiLGZ1bmN0aW9uKGEsYil7cmV0dXJuIGZ1bmN0aW9uKGMpe3ZhciBkPWFuZ3VsYXIuZWxlbWVudChcIjxkaXY+PC9kaXY+XCIpO3JldHVybiBkWzBdLmlubmVySFRNTD1jLGFuZ3VsYXIuZm9yRWFjaChhLGZ1bmN0aW9uKGEpe3ZhciBjPVtdO1xyXG4vLyBnZXQgZWxlbWVudHMgYmFzZWQgb24gd2hhdCBpcyBkZWZpbmVkLiBJZiBib3RoIGRlZmluZWQgZG8gc2Vjb25kYXJ5IGZpbHRlciBpbiB0aGUgZm9yRWFjaCBhZnRlciB1c2luZyBzZWxlY3RvciBzdHJpbmdcclxuYS5zZWxlY3RvciYmXCJcIiE9PWEuc2VsZWN0b3I/Yz1kLmZpbmQoYS5zZWxlY3Rvcik6YS5jdXN0b21BdHRyaWJ1dGUmJlwiXCIhPT1hLmN1c3RvbUF0dHJpYnV0ZSYmKGM9Yi5nZXRCeUF0dHJpYnV0ZShkLGEuY3VzdG9tQXR0cmlidXRlKSksXHJcbi8vIHByb2Nlc3MgZWxlbWVudHMgaWYgYW55IGZvdW5kXHJcbmFuZ3VsYXIuZm9yRWFjaChjLGZ1bmN0aW9uKGIpe2I9YW5ndWxhci5lbGVtZW50KGIpLGEuc2VsZWN0b3ImJlwiXCIhPT1hLnNlbGVjdG9yJiZhLmN1c3RvbUF0dHJpYnV0ZSYmXCJcIiE9PWEuY3VzdG9tQXR0cmlidXRlP3ZvaWQgMCE9PWIuYXR0cihhLmN1c3RvbUF0dHJpYnV0ZSkmJmEucmVuZGVyTG9naWMoYik6YS5yZW5kZXJMb2dpYyhiKX0pfSksZFswXS5pbm5lckhUTUx9fV0pLmZhY3RvcnkoXCJ0YUZpeENocm9tZVwiLGZ1bmN0aW9uKCl7XHJcbi8vIGdldCB3aGF0ZXJldmVyIHJ1YmJpc2ggaXMgaW5zZXJ0ZWQgaW4gY2hyb21lXHJcbi8vIHNob3VsZCBiZSBwYXNzZWQgYW4gaHRtbCBzdHJpbmcsIHJldHVybnMgYW4gaHRtbCBzdHJpbmdcclxudmFyIGE9ZnVuY3Rpb24oYSl7aWYoIWF8fCFhbmd1bGFyLmlzU3RyaW5nKGEpfHxhLmxlbmd0aDw9MClyZXR1cm4gYTtcclxuLy8gcmVtb3ZlIGFsbCB0aGUgQXBwbGUtY29udmVydGVkLXNwYWNlIHNwYW5zIGFuZCByZXBsYWNlIHdpdGggdGhlIGNvbnRlbnQgb2YgdGhlIHNwYW5cclxuLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IGFwcGxlLWNvbnRlcmV0ZWQtc3BhY2Ugc3BhbiBtYXRjaCAqL1xyXG5mb3IoXHJcbi8vIGdyYWIgYWxsIGVsZW1lbnRzIHdpdGggYSBzdHlsZSBhdHRpYnV0ZVxyXG52YXIgYixjLGQsZSxmPS88KFtePlxcL10rPylzdHlsZT0oXCIoW15cXFwiXSspXCJ8JyhbXiddKyknKShbXj5dKik+L2dpLGc9LzxzcGFuIGNsYXNzPVwiQXBwbGUtY29udmVydGVkLXNwYWNlXCI+KFtePF0rKTxcXC9zcGFuPi9naSxoPVwiXCIsaT0wO2I9Zy5leGVjKGEpOylkPWJbMV0sZD1kLnJlcGxhY2UoLyZuYnNwOy9naSxcIiBcIiksaCs9YS5zdWJzdHJpbmcoaSxiLmluZGV4KStkLGk9Yi5pbmRleCtiWzBdLmxlbmd0aDtmb3IoLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IGFwcGxlLWNvbnRlcmV0ZWQtc3BhY2Ugc3BhbiBoYXMgbWF0Y2hlZCAqL1xyXG5pJiYoXHJcbi8vIG1vZGlmaWVkLi4uLlxyXG5oKz1hLnN1YnN0cmluZyhpKSxhPWgsaD1cIlwiLGk9MCk7Yj1mLmV4ZWMoYSk7KVxyXG4vLyBvbmUgb2YgdGhlIHF1b3RlZCB2YWx1ZXMgJyBvciBcIlxyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogcXVvdGF0aW9ucyBtYXRjaCAqL1xyXG5jPWJbM118fGJbNF0sXHJcbi8vIHRlc3QgZm9yIGNocm9tZSBpbnNlcnRlZCBqdW5rXHJcbmMmJmMubWF0Y2goL2xpbmUtaGVpZ2h0OiAxLlswLTldezMsMTJ9O3xjb2xvcjogaW5oZXJpdDsgbGluZS1oZWlnaHQ6IDEuMTt8Y29sb3I6IHJnYlxcKFxcZHsxLDN9LCBcXGR7MSwzfSwgXFxkezEsM31cXCk7fGJhY2tncm91bmQtY29sb3I6IHJnYlxcKFxcZHsxLDN9LCBcXGR7MSwzfSwgXFxkezEsM31cXCk7L2kpJiYoXHJcbi8vIHJlcGxhY2Ugb3JpZ2luYWwgdGFnIHdpdGggbmV3IHRhZ1xyXG5jPWMucmVwbGFjZSgvKCB8KWZvbnQtZmFtaWx5OiBpbmhlcml0O3woIHwpbGluZS1oZWlnaHQ6IDEuWzAtOV17MywxMn07fCggfCljb2xvcjogaW5oZXJpdDt8KCB8KWNvbG9yOiByZ2JcXChcXGR7MSwzfSwgXFxkezEsM30sIFxcZHsxLDN9XFwpO3woIHwpYmFja2dyb3VuZC1jb2xvcjogcmdiXFwoXFxkezEsM30sIFxcZHsxLDN9LCBcXGR7MSwzfVxcKTsvZ2ksXCJcIiksZT1cIjxcIitiWzFdLnRyaW0oKSxjLnRyaW0oKS5sZW5ndGg+MCYmKGUrPVwiIHN0eWxlPVwiK2JbMl0uc3Vic3RyaW5nKDAsMSkrYytiWzJdLnN1YnN0cmluZygwLDEpKSxlKz1iWzVdLnRyaW0oKStcIj5cIixoKz1hLnN1YnN0cmluZyhpLGIuaW5kZXgpK2UsaT1iLmluZGV4K2JbMF0ubGVuZ3RoKTtcclxuLy8gb25seSByZXBsYWNlIHdoZW4gc29tZXRoaW5nIGhhcyBjaGFuZ2VkLCBlbHNlIHdlIGdldCBmb2N1cyBwcm9ibGVtcyBvbiBpbnNlcnRpbmcgbGlzdHNcclxuLy8gb25seSByZXBsYWNlIHdoZW4gc29tZXRoaW5nIGhhcyBjaGFuZ2VkLCBlbHNlIHdlIGdldCBmb2N1cyBwcm9ibGVtcyBvbiBpbnNlcnRpbmcgbGlzdHNcclxucmV0dXJuIGgrPWEuc3Vic3RyaW5nKGkpLGk+MD9oLnJlcGxhY2UoLzxzcGFuXFxzPz4oLio/KTxcXC9zcGFuPig8YnIoXFwvfCk+fCkvZ2ksXCIkMVwiKTphfTtyZXR1cm4gYX0pLmZhY3RvcnkoXCJ0YVNhbml0aXplXCIsW1wiJHNhbml0aXplXCIsZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYihhLGIpe2Zvcih2YXIgYyxkPTAsZT0wLGY9LzxbXj5dKj4vZ2k7Yz1mLmV4ZWMoYSk7KWlmKGU9Yy5pbmRleCxcIi9cIj09PWNbMF0uc3Vic3RyKDEsMSkpe2lmKDA9PT1kKWJyZWFrO2QtLX1lbHNlIGQrKztcclxuLy8gZ2V0IHRoZSBzdGFydCB0YWdzIHJldmVyc2VkIC0gdGhpcyBpcyBzYWZlIGFzIHdlIGNvbnN0cnVjdCB0aGUgc3RyaW5ncyB3aXRoIG5vIGNvbnRlbnQgZXhjZXB0IHRoZSB0YWdzXHJcbnJldHVybiBiK2Euc3Vic3RyaW5nKDAsZSkrYW5ndWxhci5lbGVtZW50KGIpWzBdLm91dGVySFRNTC5zdWJzdHJpbmcoYi5sZW5ndGgpK2Euc3Vic3RyaW5nKGUpfWZ1bmN0aW9uIGMoYSl7aWYoIWF8fCFhbmd1bGFyLmlzU3RyaW5nKGEpfHxhLmxlbmd0aDw9MClyZXR1cm4gYTtmb3IodmFyIGQsZixnLGgsaSxrLGw9LzwoW14+XFwvXSs/KXN0eWxlPShcIihbXlwiXSspXCJ8JyhbXiddKyknKShbXj5dKik+L2dpLG09XCJcIixuPVwiXCIsbz0wO2Y9bC5leGVjKGEpOyl7XHJcbi8vIG9uZSBvZiB0aGUgcXVvdGVkIHZhbHVlcyAnIG9yIFwiXHJcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBxdW90YXRpb25zIG1hdGNoICovXHJcbmg9ZlszXXx8Zls0XTt2YXIgcD1uZXcgUmVnRXhwKGosXCJpXCIpO1xyXG4vLyB0ZXN0IGZvciBzdHlsZSB2YWx1ZXMgdG8gY2hhbmdlXHJcbmlmKGFuZ3VsYXIuaXNTdHJpbmcoaCkmJnAudGVzdChoKSl7XHJcbi8vIHJlbW92ZSBidWlsZCB0YWcgbGlzdFxyXG5pPVwiXCI7XHJcbi8vIGZpbmQgcmVsZXZhbmQgdGFncyBhbmQgYnVpbGQgYSBzdHJpbmcgb2YgdGhlbVxyXG5mb3IoXHJcbi8vIGluaXQgcmVnZXggaGVyZSBmb3IgZXhlY1xyXG52YXIgcT1uZXcgUmVnRXhwKGosXCJpZ1wiKTtnPXEuZXhlYyhoKTspZm9yKGQ9MDtkPGUubGVuZ3RoO2QrKylnWzIqZCsyXSYmKGkrPVwiPFwiK2VbZF0udGFnK1wiPlwiKTtcclxuLy8gcmVjdXJzaXZlbHkgZmluZCBtb3JlIGxlZ2FjeSBzdHlsZXMgaW4gaHRtbCBiZWZvcmUgdGhpcyB0YWcgYW5kIGFmdGVyIHRoZSBwcmV2aW91cyBtYXRjaCAoaWYgYW55KVxyXG5rPWMoYS5zdWJzdHJpbmcobyxmLmluZGV4KSksXHJcbi8vIGJ1aWxkIHVwIGh0bWxcclxubis9bS5sZW5ndGg+MD9iKGssbSk6ayxcclxuLy8gZ3JhYiB0aGUgc3R5bGUgdmFsIHdpdGhvdXQgdGhlIHRyYW5zZm9ybWVkIHZhbHVlc1xyXG5oPWgucmVwbGFjZShuZXcgUmVnRXhwKGosXCJpZ1wiKSxcIlwiKSxcclxuLy8gYnVpbGQgdGhlIGh0bWwgdGFnXHJcbm4rPVwiPFwiK2ZbMV0udHJpbSgpLGgubGVuZ3RoPjAmJihuKz0nIHN0eWxlPVwiJytoKydcIicpLG4rPWZbNV0rXCI+XCIsXHJcbi8vIHVwZGF0ZSB0aGUgc3RhcnQgaW5kZXggdG8gYWZ0ZXIgdGhpcyB0YWdcclxubz1mLmluZGV4K2ZbMF0ubGVuZ3RoLG09aX19cmV0dXJuIG4rPW0ubGVuZ3RoPjA/YihhLnN1YnN0cmluZyhvKSxtKTphLnN1YnN0cmluZyhvKX1mdW5jdGlvbiBkKGEpe2lmKCFhfHwhYW5ndWxhci5pc1N0cmluZyhhKXx8YS5sZW5ndGg8PTApcmV0dXJuIGE7XHJcbi8vIG1hdGNoIGFsbCBhdHRyIHRhZ3NcclxuZm9yKFxyXG4vLyByZXBsYWNlIGFsbCBhbGlnbj0nLi4uJyB0YWdzIHdpdGggdGV4dC1hbGlnbiBhdHRyaWJ1dGVzXHJcbnZhciBiLGM9LzwoW14+XFwvXSs/KWFsaWduPShcIihbXlwiXSspXCJ8JyhbXiddKyknKShbXj5dKik+L2dpLGQ9XCJcIixlPTA7Yj1jLmV4ZWMoYSk7KXtcclxuLy8gYWRkIGFsbCBodG1sIGJlZm9yZSB0aGlzIHRhZ1xyXG5kKz1hLnN1YnN0cmluZyhlLGIuaW5kZXgpLFxyXG4vLyByZWNvcmQgbGFzdCBpbmRleCBhZnRlciB0aGlzIHRhZ1xyXG5lPWIuaW5kZXgrYlswXS5sZW5ndGg7XHJcbi8vIGNvbnN0cnVjdCB0YWcgd2l0aG91dCB0aGUgYWxpZ24gYXR0cmlidXRlXHJcbnZhciBmPVwiPFwiK2JbMV0rYls1XTtcclxuLy8gYWRkIHRoZSBzdHlsZSBhdHRyaWJ1dGVcclxuL3N0eWxlPShcIihbXlwiXSspXCJ8JyhbXiddKyknKS9naS50ZXN0KGYpPy8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBxdW90YXRpb25zIG1hdGNoICovXHJcbmY9Zi5yZXBsYWNlKC9zdHlsZT0oXCIoW15cIl0rKVwifCcoW14nXSspJykvaSwnc3R5bGU9XCIkMiQzIHRleHQtYWxpZ246JysoYlszXXx8Yls0XSkrJztcIicpOi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBxdW90YXRpb25zIG1hdGNoICovXHJcbmYrPScgc3R5bGU9XCJ0ZXh0LWFsaWduOicrKGJbM118fGJbNF0pKyc7XCInLGYrPVwiPlwiLFxyXG4vLyBhZGQgdG8gaHRtbFxyXG5kKz1mfVxyXG4vLyByZXR1cm4gd2l0aCByZW1haW5pbmcgaHRtbFxyXG5yZXR1cm4gZCthLnN1YnN0cmluZyhlKX1mb3IodmFyIGU9W3twcm9wZXJ0eTpcImZvbnQtd2VpZ2h0XCIsdmFsdWVzOltcImJvbGRcIl0sdGFnOlwiYlwifSx7cHJvcGVydHk6XCJmb250LXN0eWxlXCIsdmFsdWVzOltcIml0YWxpY1wiXSx0YWc6XCJpXCJ9XSxmPVtdLGc9MDtnPGUubGVuZ3RoO2crKyl7Zm9yKHZhciBoPVwiKFwiK2VbZ10ucHJvcGVydHkrXCI6XFxcXHMqKFwiLGk9MDtpPGVbZ10udmFsdWVzLmxlbmd0aDtpKyspLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IG5vdCBuZWVkZWQgdG8gYmUgdGVzdGVkIHlldCAqL1xyXG5pPjAmJihoKz1cInxcIiksaCs9ZVtnXS52YWx1ZXNbaV07aCs9XCIpOylcIixmLnB1c2goaCl9dmFyIGo9XCIoXCIrZi5qb2luKFwifFwiKStcIilcIixrPW5ldyBSZWdFeHAoLzxzcGFuIGlkPVwic2VsZWN0aW9uQm91bmRhcnlfXFxkK19cXGQrXCIgY2xhc3M9XCJyYW5neVNlbGVjdGlvbkJvdW5kYXJ5XCI+W148Pl0rPzxcXC9zcGFuPi9naSksbD1uZXcgUmVnRXhwKC88c3BhbiBjbGFzcz1cInJhbmd5U2VsZWN0aW9uQm91bmRhcnlcIiBpZD1cInNlbGVjdGlvbkJvdW5kYXJ5X1xcZCtfXFxkK1wiPltePD5dKz88XFwvc3Bhbj4vZ2kpLG09bmV3IFJlZ0V4cCgvPHNwYW4gaWQ9XCJzZWxlY3Rpb25Cb3VuZGFyeV9cXGQrX1xcZCtcIiBjbGFzcz1cInJhbmd5U2VsZWN0aW9uQm91bmRhcnlcIj5bXjw+XSs/PFxcL3NwYW4+L2dpKTtyZXR1cm4gZnVuY3Rpb24oYixlLGYpe1xyXG4vLyB1bnNhZmUgaHRtbCBzaG91bGQgTkVWRVIgYnVpbHQgaW50byBhIERPTSBvYmplY3QgdmlhIGFuZ3VsYXIuZWxlbWVudC4gVGhpcyBhbGxvd3MgWFNTIHRvIGJlIGluc2VydGVkIGFuZCBydW4uXHJcbmlmKCFmKXRyeXtiPWMoYil9Y2F0Y2goYSl7fVxyXG4vLyB3ZSBoYWQgYW4gaXNzdWUgaW4gdGhlIHBhc3QsIHdoZXJlIHdlIGR1bXBlZCBhIHdob2xlIGJ1bmNoIG9mIDxzcGFuPidzIGludG8gdGhlIGNvbnRlbnQuLi5cclxuLy8gc28gd2UgcmVtb3ZlIHRoZW0gaGVyZVxyXG4vLyBJTiBBIEZVVFVSRSByZWxlYXNlIHRoaXMgY2FuIGJlIHJlbW92ZWQgYWZ0ZXIgYWxsIGhhdmUgdXBkYXRlZCB0aHJvdWdoIHJlbGVhc2UgMS41LjlcclxuaWYoXHJcbi8vIHVuc2FmZSBhbmQgb2xkc2FmZSBzaG91bGQgYmUgdmFsaWQgSFRNTCBzdHJpbmdzXHJcbi8vIGFueSBleGNlcHRpb25zIChsZXRzIHNheSwgY29sb3IgZm9yIGV4YW1wbGUpIHNob3VsZCBiZSBtYWRlIGhlcmUgYnV0IHdpdGggZ3JlYXQgY2FyZVxyXG4vLyBzZXR1cCB1bnNhZmUgZWxlbWVudCBmb3IgbW9kaWZpY2F0aW9uXHJcbmI9ZChiKSl0cnl7Yj1iLnJlcGxhY2UoayxcIlwiKSxiPWIucmVwbGFjZShsLFwiXCIpLGI9Yi5yZXBsYWNlKGssXCJcIiksYj1iLnJlcGxhY2UobSxcIlwiKX1jYXRjaChhKXt9dmFyIGc7dHJ5e2c9YShiKSxcclxuLy8gZG8gdGhpcyBhZnRlcndhcmRzLCB0aGVuIHRoZSAkc2FuaXRpemVyIHNob3VsZCBzdGlsbCB0aHJvdyBmb3IgYmFkIG1hcmt1cFxyXG5mJiYoZz1iKX1jYXRjaChhKXtnPWV8fFwiXCJ9XHJcbi8vIERvIHByb2Nlc3NpbmcgZm9yIDxwcmU+IHRhZ3MsIHJlbW92aW5nIHRhYnMgYW5kIHJldHVybiBjYXJyaWFnZXMgb3V0c2lkZSBvZiB0aGVtXHJcbnZhciBoLGk9Zy5tYXRjaCgvKDxwcmVbXj5dKj4uKj88XFwvcHJlW14+XSo+KS9naSksaj1nLnJlcGxhY2UoLygmIyg5fDEwKTspKi9naSxcIlwiKSxuPS88cHJlW14+XSo+Lio/PFxcL3ByZVtePl0qPi9naSxvPTAscD0wO2ZvcihnPVwiXCI7bnVsbCE9PShoPW4uZXhlYyhqKSkmJm88aS5sZW5ndGg7KWcrPWouc3Vic3RyaW5nKHAsaC5pbmRleCkraVtvXSxwPWguaW5kZXgraFswXS5sZW5ndGgsbysrO3JldHVybiBnK2ouc3Vic3RyaW5nKHApfX1dKS5mYWN0b3J5KFwidGFUb29sRXhlY3V0ZUFjdGlvblwiLFtcIiRxXCIsXCIkbG9nXCIsZnVuY3Rpb24oYSxiKXtcclxuLy8gdGhpcyBtdXN0IGJlIGNhbGxlZCBvbiBhIHRvb2xTY29wZSBvciBpbnN0YW5jZVxyXG5yZXR1cm4gZnVuY3Rpb24oYyl7dm9pZCAwIT09YyYmKHRoaXMuJGVkaXRvcj1mdW5jdGlvbigpe3JldHVybiBjfSk7dmFyIGQsZT1hLmRlZmVyKCksZj1lLnByb21pc2UsZz10aGlzLiRlZGl0b3IoKTt0cnl7ZD10aGlzLmFjdGlvbihlLGcuc3RhcnRBY3Rpb24oKSksXHJcbi8vIFdlIHNldCB0aGUgLmZpbmFsbHkgY2FsbGJhY2sgaGVyZSB0byBtYWtlIHN1cmUgaXQgZG9lc24ndCBnZXQgZXhlY3V0ZWQgYmVmb3JlIGFueSBvdGhlciAudGhlbiBjYWxsYmFjay5cclxuZi5maW5hbGx5KGZ1bmN0aW9uKCl7Zy5lbmRBY3Rpb24uY2FsbChnKX0pfWNhdGNoKGEpe2IuZXJyb3IoYSl9KGR8fHZvaWQgMD09PWQpJiZcclxuLy8gaWYgdHJ1ZSBvciB1bmRlZmluZWQgaXMgcmV0dXJuZWQgdGhlbiB0aGUgYWN0aW9uIGhhcyBmaW5pc2hlZC4gT3RoZXJ3aXNlIHRoZSBkZWZlcnJlZCBhY3Rpb24gd2lsbCBiZSByZXNvbHZlZCBtYW51YWxseS5cclxuZS5yZXNvbHZlKCl9fV0pLGFuZ3VsYXIubW9kdWxlKFwidGV4dEFuZ3VsYXIuRE9NXCIsW1widGV4dEFuZ3VsYXIuZmFjdG9yaWVzXCJdKS5mYWN0b3J5KFwidGFFeGVjQ29tbWFuZFwiLFtcInRhU2VsZWN0aW9uXCIsXCJ0YUJyb3dzZXJUYWdcIixcIiRkb2N1bWVudFwiLGZ1bmN0aW9uKGIsYyxkKXt2YXIgZT1mdW5jdGlvbihhLGMpe3ZhciBkLGUsZj1hLmZpbmQoXCJsaVwiKTtmb3IoZT1mLmxlbmd0aC0xO2U+PTA7ZS0tKWQ9YW5ndWxhci5lbGVtZW50KFwiPFwiK2MrXCI+XCIrZltlXS5pbm5lckhUTUwrXCI8L1wiK2MrXCI+XCIpLGEuYWZ0ZXIoZCk7YS5yZW1vdmUoKSxiLnNldFNlbGVjdGlvblRvRWxlbWVudEVuZChkWzBdKX0sZj1mdW5jdGlvbihhLGQsZSxmLGcpe3ZhciBoLGksaixrLGwsbT1hLmZpbmQoXCJsaVwiKTtmb3IoaT0wO2k8bS5sZW5ndGg7aSsrKWlmKG1baV0ub3V0ZXJIVE1MPT09ZFswXS5vdXRlckhUTUwpe1xyXG4vLyBmb3VuZCBpdC4uLlxyXG5sPWksaT4wJiYoaj1tW2ktMV0pLGkrMTxtLmxlbmd0aCYmKGs9bVtpKzFdKTticmVha31cclxuLy9jb25zb2xlLmxvZygnbGlzdEVsZW1lbnRUb1NlbGZUYWcnLCBsaXN0LCBsaXN0RWxlbWVudCwgc2VsZlRhZywgYkRlZmF1bHQsIHByaW9yRWxlbWVudCwgbmV4dEVsZW1lbnQpO1xyXG4vLyB1bi1saXN0IHRoZSBsaXN0RWxlbWVudFxyXG52YXIgbj1cIlwiO1xyXG4vL2NvbnNvbGUubG9nKCckdGFyZ2V0JywgJHRhcmdldFswXSk7XHJcbmlmKGY/bis9XCI8XCIrZytcIj5cIitkWzBdLmlubmVySFRNTCtcIjwvXCIrZytcIj5cIjoobis9XCI8XCIrYyhlKStcIj5cIixuKz1cIjxsaT5cIitkWzBdLmlubmVySFRNTCtcIjwvbGk+XCIsbis9XCI8L1wiK2MoZSkrXCI+XCIpLGg9YW5ndWxhci5lbGVtZW50KG4pLCFqKVxyXG4vLyB0aGlzIGlzIHRoZSBmaXJzdCB0aGUgbGlzdCwgc28gd2UganVzdCByZW1vdmUgaXQuLi5cclxucmV0dXJuIGQucmVtb3ZlKCksYS5hZnRlcihhbmd1bGFyLmVsZW1lbnQoYVswXS5vdXRlckhUTUwpKSxhLmFmdGVyKGgpLGEucmVtb3ZlKCksdm9pZCBiLnNldFNlbGVjdGlvblRvRWxlbWVudEVuZChoWzBdKTtpZihrKXt2YXIgbz0oYS5wYXJlbnQoKSxcIlwiKSxwPWFbMF0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtmb3Iobys9XCI8XCIrcCtcIj5cIixpPTA7aTxsO2krKylvKz1cIjxsaT5cIittW2ldLmlubmVySFRNTCtcIjwvbGk+XCI7bys9XCI8L1wiK3ArXCI+XCI7dmFyIHE9XCJcIjtmb3IocSs9XCI8XCIrcCtcIj5cIixpPWwrMTtpPG0ubGVuZ3RoO2krKylxKz1cIjxsaT5cIittW2ldLmlubmVySFRNTCtcIjwvbGk+XCI7cSs9XCI8L1wiK3ArXCI+XCIsXHJcbi8vY29uc29sZS5sb2coaHRtbDEsICR0YXJnZXRbMF0sIGh0bWwyKTtcclxuYS5hZnRlcihhbmd1bGFyLmVsZW1lbnQocSkpLGEuYWZ0ZXIoaCksYS5hZnRlcihhbmd1bGFyLmVsZW1lbnQobykpLGEucmVtb3ZlKCksXHJcbi8vY29uc29sZS5sb2coJ3BhcmVudCAqKioqKipYWFgqKioqKicsIHBbMF0pO1xyXG5iLnNldFNlbGVjdGlvblRvRWxlbWVudEVuZChoWzBdKX1lbHNlXHJcbi8vIHRoaXMgaXMgdGhlIGxhc3QgaW4gdGhlIGxpc3QsIHNvIHdlIGp1c3QgcmVtb3ZlIGl0Li5cclxuZC5yZW1vdmUoKSxhLmFmdGVyKGgpLGIuc2V0U2VsZWN0aW9uVG9FbGVtZW50RW5kKGhbMF0pfSxnPWZ1bmN0aW9uKGEsZCxlLGYsZyl7dmFyIGgsaSxqLGssbCxtPWEuZmluZChcImxpXCIpLG49W107Zm9yKGk9MDtpPG0ubGVuZ3RoO2krKylmb3Ioaj0wO2o8ZC5sZW5ndGg7aisrKW1baV0uaXNFcXVhbE5vZGUoZFtqXSkmJihcclxuLy8gZm91bmQgaXQuLi5cclxubltqXT1pKTtuWzBdPjAmJihrPW1bblswXS0xXSksbltkLmxlbmd0aC0xXSsxPG0ubGVuZ3RoJiYobD1tW25bZC5sZW5ndGgtMV0rMV0pO1xyXG4vL2NvbnNvbGUubG9nKCdsaXN0RWxlbWVudHNUb1NlbGZUYWcnLCBsaXN0LCBsaXN0RWxlbWVudHMsIHNlbGZUYWcsIGJEZWZhdWx0LCAhcHJpb3JFbGVtZW50LCAhYWZ0ZXJFbGVtZW50LCBmb3VuZEluZGV4ZXNbbGlzdEVsZW1lbnRzLmxlbmd0aC0xXSwgY2hpbGRyZW4ubGVuZ3RoKTtcclxuLy8gdW4tbGlzdCB0aGUgbGlzdEVsZW1lbnRzXHJcbnZhciBvPVwiXCI7aWYoZilmb3Ioaj0wO2o8ZC5sZW5ndGg7aisrKW8rPVwiPFwiK2crXCI+XCIrZFtqXS5pbm5lckhUTUwrXCI8L1wiK2crXCI+XCIsZFtqXS5yZW1vdmUoKTtlbHNle2ZvcihvKz1cIjxcIitjKGUpK1wiPlwiLGo9MDtqPGQubGVuZ3RoO2orKylvKz1kW2pdLm91dGVySFRNTCxkW2pdLnJlbW92ZSgpO28rPVwiPC9cIitjKGUpK1wiPlwifWlmKGg9YW5ndWxhci5lbGVtZW50KG8pLCFrKVxyXG4vLyB0aGlzIGlzIHRoZSBmaXJzdCB0aGUgbGlzdCwgc28gd2UganVzdCByZW1vdmUgaXQuLi5cclxucmV0dXJuIGEuYWZ0ZXIoYW5ndWxhci5lbGVtZW50KGFbMF0ub3V0ZXJIVE1MKSksYS5hZnRlcihoKSxhLnJlbW92ZSgpLHZvaWQgYi5zZXRTZWxlY3Rpb25Ub0VsZW1lbnRFbmQoaFswXSk7aWYoIWwpXHJcbi8vIHRoaXMgaXMgdGhlIGxhc3QgaW4gdGhlIGxpc3QsIHNvIHdlIGp1c3QgcmVtb3ZlIGl0Li5cclxucmV0dXJuIGEuYWZ0ZXIoaCksdm9pZCBiLnNldFNlbGVjdGlvblRvRWxlbWVudEVuZChoWzBdKTtcclxuLy8gb2theSBpdCB3YXMgc29tZSB3aGVyZSBpbiB0aGUgbWlkZGxlLi4uIHNvIHdlIG5lZWQgdG8gYnJlYWsgYXBhcnQgdGhlIGxpc3QuLi5cclxudmFyIHA9XCJcIixxPWFbMF0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtmb3IocCs9XCI8XCIrcStcIj5cIixpPTA7aTxuWzBdO2krKylwKz1cIjxsaT5cIittW2ldLmlubmVySFRNTCtcIjwvbGk+XCI7cCs9XCI8L1wiK3ErXCI+XCI7dmFyIHI9XCJcIjtmb3Iocis9XCI8XCIrcStcIj5cIixpPW5bZC5sZW5ndGgtMV0rMTtpPG0ubGVuZ3RoO2krKylyKz1cIjxsaT5cIittW2ldLmlubmVySFRNTCtcIjwvbGk+XCI7cis9XCI8L1wiK3ErXCI+XCIsYS5hZnRlcihhbmd1bGFyLmVsZW1lbnQocikpLGEuYWZ0ZXIoaCksYS5hZnRlcihhbmd1bGFyLmVsZW1lbnQocCkpLGEucmVtb3ZlKCksXHJcbi8vY29uc29sZS5sb2coJ3BhcmVudCAqKioqKipZWVkqKioqKicsIGxpc3QucGFyZW50KClbMF0pO1xyXG5iLnNldFNlbGVjdGlvblRvRWxlbWVudEVuZChoWzBdKX0saD1mdW5jdGlvbihhKXsvKDxicih8XFwvKT4pJC9pLnRlc3QoYS5pbm5lckhUTUwudHJpbSgpKT9iLnNldFNlbGVjdGlvbkJlZm9yZUVsZW1lbnQoYW5ndWxhci5lbGVtZW50KGEpLmZpbmQoXCJiclwiKVswXSk6Yi5zZXRTZWxlY3Rpb25Ub0VsZW1lbnRFbmQoYSl9LGs9ZnVuY3Rpb24oYSxiKXt2YXIgYz1hbmd1bGFyLmVsZW1lbnQoXCI8XCIrYitcIj5cIithWzBdLmlubmVySFRNTCtcIjwvXCIrYitcIj5cIik7YS5hZnRlcihjKSxhLnJlbW92ZSgpLGgoYy5maW5kKFwibGlcIilbMF0pfSxsPWZ1bmN0aW9uKGEsYixkKXtmb3IodmFyIGU9XCJcIixmPTA7ZjxhLmxlbmd0aDtmKyspZSs9XCI8XCIrYyhcImxpXCIpK1wiPlwiK2FbZl0uaW5uZXJIVE1MK1wiPC9cIitjKFwibGlcIikrXCI+XCI7dmFyIGc9YW5ndWxhci5lbGVtZW50KFwiPFwiK2QrXCI+XCIrZStcIjwvXCIrZCtcIj5cIik7Yi5hZnRlcihnKSxiLnJlbW92ZSgpLGgoZy5maW5kKFwibGlcIilbMF0pfSxtPWZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPTA7YzxhLmNoaWxkTm9kZXMubGVuZ3RoO2MrKyl7dmFyIGQ9YS5jaGlsZE5vZGVzW2NdOy8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IC0gbW9yZSBjb21wbGV4IHRlc3RpbmcqL1xyXG5kLnRhZ05hbWUmJmQudGFnTmFtZS5tYXRjaChpKSYmbShkLGIpfS8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IC0gdmVyeSByYXJlIGNvbmRpdGlvbiB0aGF0IHdlIGRvIG5vdCB0ZXN0Ki9cclxuaWYobnVsbD09PWEucGFyZW50Tm9kZSlcclxuLy8gbm90aGluZyBsZWZ0IHRvIGRvLi5cclxucmV0dXJuIGE7dmFyIGU9YW5ndWxhci5lbGVtZW50KGIpO3JldHVybiBlWzBdLmlubmVySFRNTD1hLmlubmVySFRNTCxhLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVbMF0sYSksYS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGEpLGV9O3JldHVybiBmdW5jdGlvbihoLG4pe1xyXG4vLyBOT1RFOiBoZXJlIHdlIGFyZSBkZWFsaW5nIHdpdGggdGhlIGh0bWwgZGlyZWN0bHkgZnJvbSB0aGUgYnJvd3NlciBhbmQgbm90IHRoZSBodG1sIHRoZSB1c2VyIHNlZXMuXHJcbi8vIElGIHlvdSB3YW50IHRvIG1vZGlmeSB0aGUgaHRtbCB0aGUgdXNlciBzZWVzLCBkbyBpdCB3aGVuIHRoZSB1c2VyIGRvZXMgYSBzd2l0Y2hWaWV3XHJcbnJldHVybiBoPWMoaCksZnVuY3Rpb24obyxwLHEscil7dmFyIHMsdCx1LHYsdyx4LHkseixBPWFuZ3VsYXIuZWxlbWVudChcIjxcIitoK1wiPlwiKTt0cnl7Yi5nZXRTZWxlY3Rpb24mJih6PWIuZ2V0U2VsZWN0aW9uKCkpLHk9Yi5nZXRTZWxlY3Rpb25FbGVtZW50KCk7XHJcbi8vIHNwZWNpYWwgY2hlY2tzIGFuZCBmaXhlcyB3aGVuIHdlIGFyZSBzZWxlY3RpbmcgdGhlIHdob2xlIGNvbnRhaW5lclxyXG52YXIgQixDOy8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbnZvaWQgMCE9PXkudGFnTmFtZSYmKFwiZGl2XCI9PT15LnRhZ05hbWUudG9Mb3dlckNhc2UoKSYmL3RhVGV4dEVsZW1lbnQuKy8udGVzdCh5LmlkKSYmeiYmei5zdGFydCYmMT09PXouc3RhcnQub2Zmc2V0JiYxPT09ei5lbmQub2Zmc2V0PyhcclxuLy8gb3BwcyB3ZSBhcmUgYWN0dWFsbHkgc2VsZWN0aW5nIHRoZSB3aG9sZSBjb250YWluZXIhXHJcbi8vY29uc29sZS5sb2coJ3NlbGVjdGluZyB3aG9sZSBjb250YWluZXIhJyk7XHJcbkI9eS5pbm5lckhUTUwsLzxicj4vaS50ZXN0KEIpJiYoXHJcbi8vIEZpcmVmb3ggYWRkcyA8YnI+J3MgYW5kIHNvIHdlIHJlbW92ZSB0aGUgPGJyPlxyXG5CPUIucmVwbGFjZSgvPGJyPi9pLFwiJiM4MjAzO1wiKSksLzxiclxcLz4vaS50ZXN0KEIpJiYoXHJcbi8vIEZpcmVmb3ggYWRkcyA8YnIvPidzIGFuZCBzbyB3ZSByZW1vdmUgdGhlIDxici8+XHJcbkI9Qi5yZXBsYWNlKC88YnJcXC8+L2ksXCImIzgyMDM7XCIpKSxcclxuLy8gcmVtb3ZlIHN0YWNrZWQgdXAgPHNwYW4+J3NcclxuLzxzcGFuPig8c3Bhbj4pKy9pLnRlc3QoQikmJihCPV9fLnJlcGxhY2UoLzxzcGFuPig8c3Bhbj4pKy9pLFwiPHNwYW4+XCIpKSxcclxuLy8gcmVtb3ZlIHN0YWNrZWQgdXAgPC9zcGFuPidzXHJcbi88XFwvc3Bhbj4oPFxcL3NwYW4+KSsvaS50ZXN0KEIpJiYoQj1fXy5yZXBsYWNlKC88XFwvc3Bhbj4oPFxcL3NwYW4+KSsvaSxcIjwvc3Bhbj5cIikpLC88c3Bhbj48XFwvc3Bhbj4vaS50ZXN0KEIpJiYoXHJcbi8vIGlmIHdlIGVuZCB1cCB3aXRoIGEgPHNwYW4+PC9zcGFuPiBoZXJlIHdlIHJlbW92ZSBpdC4uLlxyXG5CPUIucmVwbGFjZSgvPHNwYW4+PFxcL3NwYW4+L2ksXCJcIikpLFxyXG4vL2NvbnNvbGUubG9nKCdpbm5lciB3aG9sZSBjb250YWluZXInLCBzZWxlY3RlZEVsZW1lbnQuY2hpbGROb2Rlcyk7XHJcbkM9XCI8ZGl2PlwiK0IrXCI8L2Rpdj5cIix5LmlubmVySFRNTD1DLFxyXG4vL2NvbnNvbGUubG9nKCdjaGlsZE5vZGVzOicsIHNlbGVjdGVkRWxlbWVudC5jaGlsZE5vZGVzKTtcclxuYi5zZXRTZWxlY3Rpb25Ub0VsZW1lbnRFbmQoeS5jaGlsZE5vZGVzWzBdKSx5PWIuZ2V0U2VsZWN0aW9uRWxlbWVudCgpKTpcInNwYW5cIj09PXkudGFnTmFtZS50b0xvd2VyQ2FzZSgpJiZ6JiZ6LnN0YXJ0JiYxPT09ei5zdGFydC5vZmZzZXQmJjE9PT16LmVuZC5vZmZzZXQ/KFxyXG4vLyBqdXN0IGEgc3BhbiAtLSB0aGlzIGlzIGEgcHJvYmxlbS4uLlxyXG4vL2NvbnNvbGUubG9nKCdzZWxlY3Rpbmcgc3BhbiEnKTtcclxuQj15LmlubmVySFRNTCwvPGJyPi9pLnRlc3QoQikmJihcclxuLy8gRmlyZWZveCBhZGRzIDxicj4ncyBhbmQgc28gd2UgcmVtb3ZlIHRoZSA8YnI+XHJcbkI9Qi5yZXBsYWNlKC88YnI+L2ksXCImIzgyMDM7XCIpKSwvPGJyXFwvPi9pLnRlc3QoQikmJihcclxuLy8gRmlyZWZveCBhZGRzIDxici8+J3MgYW5kIHNvIHdlIHJlbW92ZSB0aGUgPGJyLz5cclxuQj1CLnJlcGxhY2UoLzxiclxcLz4vaSxcIiYjODIwMztcIikpLFxyXG4vLyByZW1vdmUgc3RhY2tlZCB1cCA8c3Bhbj4nc1xyXG4vPHNwYW4+KDxzcGFuPikrL2kudGVzdChCKSYmKEI9X18ucmVwbGFjZSgvPHNwYW4+KDxzcGFuPikrL2ksXCI8c3Bhbj5cIikpLFxyXG4vLyByZW1vdmUgc3RhY2tlZCB1cCA8L3NwYW4+J3NcclxuLzxcXC9zcGFuPig8XFwvc3Bhbj4pKy9pLnRlc3QoQikmJihCPV9fLnJlcGxhY2UoLzxcXC9zcGFuPig8XFwvc3Bhbj4pKy9pLFwiPC9zcGFuPlwiKSksLzxzcGFuPjxcXC9zcGFuPi9pLnRlc3QoQikmJihcclxuLy8gaWYgd2UgZW5kIHVwIHdpdGggYSA8c3Bhbj48L3NwYW4+IGhlcmUgd2UgcmVtb3ZlIGl0Li4uXHJcbkI9Qi5yZXBsYWNlKC88c3Bhbj48XFwvc3Bhbj4vaSxcIlwiKSksXHJcbi8vY29uc29sZS5sb2coJ2lubmVyIHNwYW4nLCBzZWxlY3RlZEVsZW1lbnQuY2hpbGROb2Rlcyk7XHJcbi8vIHdlIHdyYXAgdGhpcyBpbiBhIDxkaXY+IGJlY2F1c2Ugb3RoZXJ3aXNlIHRoZSBicm93c2VyIGdldCBjb25mdXNlZCB3aGVuIHdlIGF0dGVtcHQgdG8gc2VsZWN0IHRoZSB3aG9sZSBub2RlXHJcbi8vIGFuZCB0aGUgZm9jdXMgaXMgbm90IHNldCBjb3JyZWN0bHkgbm8gbWF0dGVyIHdoYXQgd2UgZG9cclxuQz1cIjxkaXY+XCIrQitcIjwvZGl2PlwiLHkuaW5uZXJIVE1MPUMsYi5zZXRTZWxlY3Rpb25Ub0VsZW1lbnRFbmQoeS5jaGlsZE5vZGVzWzBdKSx5PWIuZ2V0U2VsZWN0aW9uRWxlbWVudCgpKTpcInBcIj09PXkudGFnTmFtZS50b0xvd2VyQ2FzZSgpJiZ6JiZ6LnN0YXJ0JiYxPT09ei5zdGFydC5vZmZzZXQmJjE9PT16LmVuZC5vZmZzZXQ/KFxyXG4vL2NvbnNvbGUubG9nKCdwIHNwZWNpYWwnKTtcclxuLy8gd2UgbmVlZCB0byByZW1vdmUgdGhlIDwvYnI+IHRoYXQgZmlyZWZveCBhZGRzIVxyXG5CPXkuaW5uZXJIVE1MLC88YnI+L2kudGVzdChCKSYmKFxyXG4vLyBGaXJlZm94IGFkZHMgPGJyPidzIGFuZCBzbyB3ZSByZW1vdmUgdGhlIDxicj5cclxuQj1CLnJlcGxhY2UoLzxicj4vaSxcIiYjODIwMztcIiksLy8gbm8gc3BhY2Utc3BhY2VcclxueS5pbm5lckhUTUw9QixiLnNldFNlbGVjdGlvblRvRWxlbWVudEVuZCh5LmNoaWxkTm9kZXNbMF0pLHk9Yi5nZXRTZWxlY3Rpb25FbGVtZW50KCkpKTpcImxpXCI9PT15LnRhZ05hbWUudG9Mb3dlckNhc2UoKSYmeiYmei5zdGFydCYmei5zdGFydC5vZmZzZXQ9PT16LmVuZC5vZmZzZXQmJihcclxuLy8gd2UgbmVlZCB0byByZW1vdmUgdGhlIDwvYnI+IHRoYXQgZmlyZWZveCBhZGRzIVxyXG5CPXkuaW5uZXJIVE1MLC88YnI+L2kudGVzdChCKSYmKFxyXG4vLyBGaXJlZm94IGFkZHMgPGJyPidzIGFuZCBzbyB3ZSByZW1vdmUgdGhlIDxicj5cclxuQj1CLnJlcGxhY2UoLzxicj4vaSxcIlwiKSwvLyBub3RoaW5nXHJcbnkuaW5uZXJIVE1MPUIsYi5zZXRTZWxlY3Rpb25Ub0VsZW1lbnRFbmQoeS5jaGlsZE5vZGVzWzBdKSx5PWIuZ2V0U2VsZWN0aW9uRWxlbWVudCgpKSkpfWNhdGNoKGEpe31cclxuLy9jb25zb2xlLmxvZygnKioqKioqKioqKioqKiogc2VsZWN0ZWRFbGVtZW50OicsIHNlbGVjdGVkRWxlbWVudCk7XHJcbnZhciBEPWFuZ3VsYXIuZWxlbWVudCh5KSxFPXkudGFnTmFtZSYmeS50YWdOYW1lLnRvTG93ZXJDYXNlKCl8fC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiAqL1xyXG5cIlwiO2lmKFwiaW5zZXJ0b3JkZXJlZGxpc3RcIj09PW8udG9Mb3dlckNhc2UoKXx8XCJpbnNlcnR1bm9yZGVyZWRsaXN0XCI9PT1vLnRvTG93ZXJDYXNlKCkpe3ZhciBGPWMoXCJpbnNlcnRvcmRlcmVkbGlzdFwiPT09by50b0xvd2VyQ2FzZSgpP1wib2xcIjpcInVsXCIpLEc9Yi5nZXRPbmx5U2VsZWN0ZWRFbGVtZW50cygpO1xyXG4vL2NvbnNvbGUubG9nKCdQUFBQUFBQUFBQUFBQJywgdGFnTmFtZSwgc2VsZlRhZywgc2VsZWN0ZWRFbGVtZW50cywgdGFnTmFtZS5tYXRjaChCTE9DS0VMRU1FTlRTKSwgJHNlbGVjdGVkLmhhc0NsYXNzKCd0YS1iaW5kJyksICRzZWxlY3RlZC5wYXJlbnQoKVswXS50YWdOYW1lKTtcclxuaWYoRy5sZW5ndGg+MSYmKFwib2xcIj09PUV8fFwidWxcIj09PUUpKXJldHVybiBnKEQsRyxGLEY9PT1FLGgpO2lmKEU9PT1GKVxyXG4vLyBpZiBhbGwgc2VsZWN0ZWQgdGhlbiB3ZSBzaG91bGQgcmVtb3ZlIHRoZSBsaXN0XHJcbi8vIGdyYWIgYWxsIGxpIGVsZW1lbnRzIGFuZCBjb252ZXJ0IHRvIHRhRGVmYXVsdFdyYXAgdGFnc1xyXG4vL2NvbnNvbGUubG9nKCd0YWdOYW1lPT09c2VsZlRhZycpO1xyXG4vLyBpZiBhbGwgc2VsZWN0ZWQgdGhlbiB3ZSBzaG91bGQgcmVtb3ZlIHRoZSBsaXN0XHJcbi8vIGdyYWIgYWxsIGxpIGVsZW1lbnRzIGFuZCBjb252ZXJ0IHRvIHRhRGVmYXVsdFdyYXAgdGFnc1xyXG4vL2NvbnNvbGUubG9nKCd0YWdOYW1lPT09c2VsZlRhZycpO1xyXG5yZXR1cm4gRFswXS5jaGlsZE5vZGVzLmxlbmd0aCE9PUcubGVuZ3RoJiYxPT09Ry5sZW5ndGg/KEQ9YW5ndWxhci5lbGVtZW50KEdbMF0pLGYoRC5wYXJlbnQoKSxELEYsITAsaCkpOmUoRCxoKTtpZihcImxpXCI9PT1FJiZELnBhcmVudCgpWzBdLnRhZ05hbWUudG9Mb3dlckNhc2UoKT09PUYmJjE9PT1ELnBhcmVudCgpLmNoaWxkcmVuKCkubGVuZ3RoKVxyXG4vLyBjYXRjaCBmb3IgdGhlIHByZXZpb3VzIHN0YXRlbWVudCBpZiBvbmx5IG9uZSBsaSBleGlzdHNcclxucmV0dXJuIGUoRC5wYXJlbnQoKSxoKTtpZihcImxpXCI9PT1FJiZELnBhcmVudCgpWzBdLnRhZ05hbWUudG9Mb3dlckNhc2UoKSE9PUYmJjE9PT1ELnBhcmVudCgpLmNoaWxkcmVuKCkubGVuZ3RoKVxyXG4vLyBjYXRjaCBmb3IgdGhlIHByZXZpb3VzIHN0YXRlbWVudCBpZiBvbmx5IG9uZSBsaSBleGlzdHNcclxucmV0dXJuIGsoRC5wYXJlbnQoKSxGKTtpZihFLm1hdGNoKGkpJiYhRC5oYXNDbGFzcyhcInRhLWJpbmRcIikpe1xyXG4vLyBpZiBpdCdzIG9uZSBvZiB0aG9zZSBibG9jayBlbGVtZW50cyB3ZSBoYXZlIHRvIGNoYW5nZSB0aGUgY29udGVudHNcclxuLy8gaWYgaXQncyBhIG9sL3VsIHdlIGFyZSBjaGFuZ2luZyBmcm9tIG9uZSB0byB0aGUgb3RoZXJcclxuaWYoRy5sZW5ndGgmJkRbMF0uY2hpbGROb2Rlcy5sZW5ndGghPT1HLmxlbmd0aCYmMT09PUcubGVuZ3RoKVxyXG4vL2NvbnNvbGUubG9nKCcmJiYmJiYmJiYmJiYmJiYgLS0tLS0tLS0tICYmJiYmJiYmJiYmJiYmJiYnLCBzZWxlY3RlZEVsZW1lbnRzWzBdLCAkc2VsZWN0ZWRbMF0uY2hpbGROb2Rlcyk7XHJcbnJldHVybiBEPWFuZ3VsYXIuZWxlbWVudChHWzBdKSxmKEQucGFyZW50KCksRCxGLEY9PT1FLGgpO2lmKFwib2xcIj09PUV8fFwidWxcIj09PUUpXHJcbi8vIG5vdyBpZiB0aGlzIGlzIGEgc2V0IG9mIHNlbGVjdGVkIGVsZW1lbnRzLi4uIGJlaGF2ZSBkaWZlcmVudGx5XHJcbnJldHVybiBrKEQsRik7dmFyIEg9ITE7cmV0dXJuIGFuZ3VsYXIuZm9yRWFjaChELmNoaWxkcmVuKCksZnVuY3Rpb24oYSl7YS50YWdOYW1lLm1hdGNoKGkpJiYoSD0hMCl9KSxIP2woRC5jaGlsZHJlbigpLEQsRik6bChbYW5ndWxhci5lbGVtZW50KFwiPGRpdj5cIit5LmlubmVySFRNTCtcIjwvZGl2PlwiKVswXV0sRCxGKX1pZihFLm1hdGNoKGkpKXtcclxuLy9jb25zb2xlLmxvZygnX25vZGVzJywgX25vZGVzLCB0YWdOYW1lKTtcclxuaWYoXHJcbi8vIGlmIHdlIGdldCBoZXJlIHRoZW4gdGhlIGNvbnRlbnRzIG9mIHRoZSB0YS1iaW5kIGFyZSBzZWxlY3RlZFxyXG52PWIuZ2V0T25seVNlbGVjdGVkRWxlbWVudHMoKSwwPT09di5sZW5ndGgpXHJcbi8vIGhlcmUgaXMgaWYgdGhlcmUgaXMgb25seSB0ZXh0IGluIHRhLWJpbmQgaWUgPGRpdiB0YS1iaW5kPnRlc3QgY29udGVudDwvZGl2PlxyXG50PWFuZ3VsYXIuZWxlbWVudChcIjxcIitGK1wiPjxsaT5cIit5LmlubmVySFRNTCtcIjwvbGk+PC9cIitGK1wiPlwiKSxELmh0bWwoXCJcIiksRC5hcHBlbmQodCk7ZWxzZXtpZigxPT09di5sZW5ndGgmJihcIm9sXCI9PT12WzBdLnRhZ05hbWUudG9Mb3dlckNhc2UoKXx8XCJ1bFwiPT09dlswXS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpKXJldHVybiB2WzBdLnRhZ05hbWUudG9Mb3dlckNhc2UoKT09PUY/ZShhbmd1bGFyLmVsZW1lbnQodlswXSksaCk6ayhhbmd1bGFyLmVsZW1lbnQodlswXSksRik7dT1cIlwiO3ZhciBJPVtdO2ZvcihzPTA7czx2Lmxlbmd0aDtzKyspLyogaXN0YW5idWwgaWdub3JlIGVsc2U6IGNhdGNoIGZvciByZWFsLXdvcmxkIGNhbid0IG1ha2UgaXQgb2NjdXIgaW4gdGVzdGluZyAqL1xyXG5pZigzIT09dltzXS5ub2RlVHlwZSl7dmFyIEo9YW5ndWxhci5lbGVtZW50KHZbc10pOy8qIGlzdGFuYnVsIGlnbm9yZSBpZjogYnJvd3NlciBjaGVjayBvbmx5LCBwaGFudG9tanMgZG9lc24ndCByZXR1cm4gY2hpbGRyZW4gbm9kZXMgYnV0IGNocm9tZSBhdCBsZWFzdCBkb2VzICovXHJcbmlmKFwibGlcIj09PXZbc10udGFnTmFtZS50b0xvd2VyQ2FzZSgpKWNvbnRpbnVlO3UrPVwib2xcIj09PXZbc10udGFnTmFtZS50b0xvd2VyQ2FzZSgpfHxcInVsXCI9PT12W3NdLnRhZ05hbWUudG9Mb3dlckNhc2UoKT9KWzBdLmlubmVySFRNTDpcInNwYW5cIiE9PXZbc10udGFnTmFtZS50b0xvd2VyQ2FzZSgpfHxcIm9sXCIhPT12W3NdLmNoaWxkTm9kZXNbMF0udGFnTmFtZS50b0xvd2VyQ2FzZSgpJiZcInVsXCIhPT12W3NdLmNoaWxkTm9kZXNbMF0udGFnTmFtZS50b0xvd2VyQ2FzZSgpP1wiPFwiK2MoXCJsaVwiKStcIj5cIitKWzBdLmlubmVySFRNTCtcIjwvXCIrYyhcImxpXCIpK1wiPlwiOkpbMF0uY2hpbGROb2Rlc1swXS5pbm5lckhUTUwsSS51bnNoaWZ0KEopfVxyXG4vL2NvbnNvbGUubG9nKCckbm9kZXMnLCAkbm9kZXMpO1xyXG50PWFuZ3VsYXIuZWxlbWVudChcIjxcIitGK1wiPlwiK3UrXCI8L1wiK0YrXCI+XCIpLEkucG9wKCkucmVwbGFjZVdpdGgodCksYW5ndWxhci5mb3JFYWNoKEksZnVuY3Rpb24oYSl7YS5yZW1vdmUoKX0pfXJldHVybiB2b2lkIGIuc2V0U2VsZWN0aW9uVG9FbGVtZW50RW5kKHRbMF0pfX1lbHNle2lmKFwiZm9ybWF0YmxvY2tcIj09PW8udG9Mb3dlckNhc2UoKSl7XHJcbi8vIGZpbmQgdGhlIGZpcnN0IGJsb2NrRWxlbWVudFxyXG5mb3IoeD1xLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvWzw+XS9naSxcIlwiKSxcImRlZmF1bHRcIj09PXgudHJpbSgpJiYoeD1oLHE9XCI8XCIraCtcIj5cIiksdD1cImxpXCI9PT1FP0QucGFyZW50KCk6RDshdFswXS50YWdOYW1lfHwhdFswXS50YWdOYW1lLm1hdGNoKGkpJiYhdC5wYXJlbnQoKS5hdHRyKFwiY29udGVudGVkaXRhYmxlXCIpOyl0PXQucGFyZW50KCksLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuRT0odFswXS50YWdOYW1lfHxcIlwiKS50b0xvd2VyQ2FzZSgpO2lmKEU9PT14KXtcclxuLy8gJHRhcmdldCBpcyB3cmFwIGVsZW1lbnRcclxudj10LmNoaWxkcmVuKCk7dmFyIEs9ITE7Zm9yKHM9MDtzPHYubGVuZ3RoO3MrKylLPUt8fHZbc10udGFnTmFtZS5tYXRjaChpKTtLPyh0LmFmdGVyKHYpLHc9dC5uZXh0KCksdC5yZW1vdmUoKSx0PXcpOihBLmFwcGVuZCh0WzBdLmNoaWxkTm9kZXMpLHQuYWZ0ZXIoQSksdC5yZW1vdmUoKSx0PUEpfWVsc2UgaWYodC5wYXJlbnQoKVswXS50YWdOYW1lLnRvTG93ZXJDYXNlKCkhPT14fHx0LnBhcmVudCgpLmhhc0NsYXNzKFwidGEtYmluZFwiKSlpZihFLm1hdGNoKGopKVxyXG4vLyB3cmFwcGluZyBhIGxpc3QgZWxlbWVudFxyXG50LndyYXAocSk7ZWxzZXtcclxuLy8gZmluZCB0aGUgcGFyZW50IGJsb2NrIGVsZW1lbnQgaWYgYW55IG9mIHRoZSBub2RlcyBhcmUgaW5saW5lIG9yIHRleHRcclxuZm9yKFxyXG4vLyBkZWZhdWx0IHdyYXAgYmVoYXZpb3VyXHJcbnY9Yi5nZXRPbmx5U2VsZWN0ZWRFbGVtZW50cygpLDA9PT12Lmxlbmd0aCYmKFxyXG4vLyBubyBub2RlcyBhdCBhbGwuLi4uXHJcbnY9W3RbMF1dKSxzPTA7czx2Lmxlbmd0aDtzKyspaWYoMz09PXZbc10ubm9kZVR5cGV8fCF2W3NdLnRhZ05hbWUubWF0Y2goaSkpZm9yKDszPT09dltzXS5ub2RlVHlwZXx8IXZbc10udGFnTmFtZXx8IXZbc10udGFnTmFtZS5tYXRjaChpKTspdltzXT12W3NdLnBhcmVudE5vZGU7aWYoXHJcbi8vIHJlbW92ZSBhbnkgZHVwbGljYXRlcyBmcm9tIHRoZSBhcnJheSBvZiBfbm9kZXMhXHJcbnY9di5maWx0ZXIoZnVuY3Rpb24oYSxiLGMpe3JldHVybiBjLmluZGV4T2YoYSk9PT1ifSksXHJcbi8vIHJlbW92ZSBhbGwgd2hvbGUgdGFUZXh0RWxlbWVudCBpZiBpdCBpcyBoZXJlLi4uIHVubGVzcyBpdCBpcyB0aGUgb25seSBlbGVtZW50IVxyXG52Lmxlbmd0aD4xJiYodj12LmZpbHRlcihmdW5jdGlvbihhLGIsYyl7cmV0dXJuIShcImRpdlwiPT09YS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpJiYvXnRhVGV4dEVsZW1lbnQvLnRlc3QoYS5pZCkpfSkpLGFuZ3VsYXIuZWxlbWVudCh2WzBdKS5oYXNDbGFzcyhcInRhLWJpbmRcIikpdD1hbmd1bGFyLmVsZW1lbnQocSksdFswXS5pbm5lckhUTUw9dlswXS5pbm5lckhUTUwsdlswXS5pbm5lckhUTUw9dFswXS5vdXRlckhUTUw7ZWxzZSBpZihcImJsb2NrcXVvdGVcIj09PXgpe2ZvcihcclxuLy8gYmxvY2txdW90ZXMgd3JhcCBvdGhlciBibG9jayBlbGVtZW50c1xyXG51PVwiXCIscz0wO3M8di5sZW5ndGg7cysrKXUrPXZbc10ub3V0ZXJIVE1MO2Zvcih0PWFuZ3VsYXIuZWxlbWVudChxKSx0WzBdLmlubmVySFRNTD11LHZbMF0ucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodFswXSx2WzBdKSxzPXYubGVuZ3RoLTE7cz49MDtzLS0pLyogaXN0YW5idWwgaWdub3JlIGVsc2U6ICAqL1xyXG52W3NdLnBhcmVudE5vZGUmJnZbc10ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh2W3NdKX1lbHNlLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IG5vdCB0ZXN0ZWQgc2luY2UgaWRlbnRpY2FsIHRvIGJsb2NrcXVvdGUgKi9cclxuaWYoXCJwcmVcIj09PXgmJmIuZ2V0U3RhdGVTaGlmdEtleSgpKXtmb3IoXHJcbi8vY29uc29sZS5sb2coJ3NoaWZ0IHByZScsIF9ub2Rlcyk7XHJcbi8vIHByZSB3cmFwIG90aGVyIGJsb2NrIGVsZW1lbnRzXHJcbnU9XCJcIixzPTA7czx2Lmxlbmd0aDtzKyspdSs9dltzXS5vdXRlckhUTUw7Zm9yKHQ9YW5ndWxhci5lbGVtZW50KHEpLHRbMF0uaW5uZXJIVE1MPXUsdlswXS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0WzBdLHZbMF0pLHM9di5sZW5ndGgtMTtzPj0wO3MtLSkvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZTogICovXHJcbnZbc10ucGFyZW50Tm9kZSYmdltzXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHZbc10pfWVsc2VcclxuLy9jb25zb2xlLmxvZyhvcHRpb25zVGFnTmFtZSwgX25vZGVzKTtcclxuLy8gcmVndWxhciBibG9jayBlbGVtZW50cyByZXBsYWNlIG90aGVyIGJsb2NrIGVsZW1lbnRzXHJcbmZvcihzPTA7czx2Lmxlbmd0aDtzKyspe3ZhciBMPW0odltzXSxxKTt2W3NdPT09dFswXSYmKHQ9YW5ndWxhci5lbGVtZW50KEwpKX19ZWxzZXtcclxuLy91bndyYXAgbG9naWMgZm9yIHBhcmVudFxyXG52YXIgTT10LnBhcmVudCgpLE49TS5jb250ZW50cygpO2ZvcihzPTA7czxOLmxlbmd0aDtzKyspLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IGNhbid0IHRlc3QgLSBzb21lIHdpZXJkIHRoaW5nIHdpdGggaG93IHBoYW50b21qcyB3b3JrcyAqL1xyXG5NLnBhcmVudCgpLmhhc0NsYXNzKFwidGEtYmluZFwiKSYmMz09PU5bc10ubm9kZVR5cGUmJihBPWFuZ3VsYXIuZWxlbWVudChcIjxcIitoK1wiPlwiKSxBWzBdLmlubmVySFRNTD1OW3NdLm91dGVySFRNTCxOW3NdPUFbMF0pLE0ucGFyZW50KClbMF0uaW5zZXJ0QmVmb3JlKE5bc10sTVswXSk7TS5yZW1vdmUoKX1cclxuLy8gbG9vc2VzIGZvY3VzIHdoZW4gd2UgaGF2ZSB0aGUgd2hvbGUgY29udGFpbmVyIHNlbGVjdGVkIGFuZCBubyB0ZXh0IVxyXG4vLyByZWZvY3VzIG9uIHRoZSBzaG93biBkaXNwbGF5IGVsZW1lbnQsIHRoaXMgZml4ZXMgYSBidWcgd2hlbiB1c2luZyBmaXJlZm94XHJcbnJldHVybiBiLnNldFNlbGVjdGlvblRvRWxlbWVudEVuZCh0WzBdKSx2b2lkIHRbMF0uZm9jdXMoKX1pZihcImNyZWF0ZWxpbmtcIj09PW8udG9Mb3dlckNhc2UoKSl7LyogaXN0YW5idWwgaWdub3JlIG5leHQ6IGZpcmVmb3ggc3BlY2lmaWMgZml4ICovXHJcbmlmKFwiYVwiPT09RSlcclxuLy8gYWxyZWFkeSBhIGxpbmshISEgd2UgYXJlIGp1c3QgcmVwbGFjaW5nIGl0Li4uXHJcbnJldHVybiB2b2lkKGIuZ2V0U2VsZWN0aW9uRWxlbWVudCgpLmhyZWY9cSk7dmFyIE89JzxhIGhyZWY9XCInK3ErJ1wiIHRhcmdldD1cIicrKHIuYS50YXJnZXQ/ci5hLnRhcmdldDpcIlwiKSsnXCI+JyxQPVwiPC9hPlwiLFE9Yi5nZXRTZWxlY3Rpb24oKTtpZihRLmNvbGxhcHNlZClcclxuLy8gaW5zZXJ0IHRleHQgYXQgc2VsZWN0aW9uLCB0aGVuIHNlbGVjdCB0aGVuIGp1c3QgbGV0IG5vcm1hbCBleGVjLWNvbW1hbmQgcnVuXHJcbmIuaW5zZXJ0SHRtbChPK3ErUCxuKTtlbHNlIGlmKGEuZ2V0U2VsZWN0aW9uKCkuZ2V0UmFuZ2VBdCgwKS5jYW5TdXJyb3VuZENvbnRlbnRzKCkpe3ZhciBSPWFuZ3VsYXIuZWxlbWVudChPK1ApWzBdO2EuZ2V0U2VsZWN0aW9uKCkuZ2V0UmFuZ2VBdCgwKS5zdXJyb3VuZENvbnRlbnRzKFIpfXJldHVybn1pZihcImluc2VydGh0bWxcIj09PW8udG9Mb3dlckNhc2UoKSlyZXR1cm4gdm9pZCBiLmluc2VydEh0bWwocSxuKX10cnl7ZFswXS5leGVjQ29tbWFuZChvLHAscSl9Y2F0Y2goYSl7fX19fV0pLnNlcnZpY2UoXCJ0YVNlbGVjdGlvblwiLFtcIiRkb2N1bWVudFwiLFwidGFET01cIixcIiRsb2dcIiwvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogYWxsIGJyb3dzZXIgc3BlY2lmaWNzIGFuZCBQaGFudG9tSlMgZG9zZW4ndCBzZWVtIHRvIHN1cHBvcnQgaGFsZiBvZiBpdCAqL1xyXG5mdW5jdGlvbihiLGMsZCl7XHJcbi8vIG5lZWQgdG8gZGVyZWZlcmVuY2UgdGhlIGRvY3VtZW50IGVsc2UgdGhlIGNhbGxzIGRvbid0IHdvcmsgY29ycmVjdGx5XHJcbnZhciBlLGY9YlswXSxnPWZ1bmN0aW9uKGEsYil7LyogY2hlY2sgaWYgc2VsZWN0aW9uIGlzIGEgQlIgZWxlbWVudCBhdCB0aGUgYmVnaW5uaW5nIG9mIGEgY29udGFpbmVyLiBJZiBzbywgZ2V0XHJcblx0XHQqIHRoZSBwYXJlbnROb2RlIGluc3RlYWQuXHJcblx0XHQqIG9mZnNldCBzaG91bGQgYmUgemVybyBpbiB0aGlzIGNhc2UuIE90aGVyd2lzZSwgcmV0dXJuIHRoZSBvcmlnaW5hbFxyXG5cdFx0KiBlbGVtZW50LlxyXG5cdFx0Ki9cclxuLyogY2hlY2sgaWYgc2VsZWN0aW9uIGlzIGEgQlIgZWxlbWVudCBhdCB0aGUgYmVnaW5uaW5nIG9mIGEgY29udGFpbmVyLiBJZiBzbywgZ2V0XHJcblx0XHQqIHRoZSBwYXJlbnROb2RlIGluc3RlYWQuXHJcblx0XHQqIG9mZnNldCBzaG91bGQgYmUgemVybyBpbiB0aGlzIGNhc2UuIE90aGVyd2lzZSwgcmV0dXJuIHRoZSBvcmlnaW5hbFxyXG5cdFx0KiBlbGVtZW50LlxyXG5cdFx0Ki9cclxucmV0dXJuIGEudGFnTmFtZSYmYS50YWdOYW1lLm1hdGNoKC9eYnIkL2kpJiYwPT09YiYmIWEucHJldmlvdXNTaWJsaW5nP3tlbGVtZW50OmEucGFyZW50Tm9kZSxvZmZzZXQ6MH06e2VsZW1lbnQ6YSxvZmZzZXQ6Yn19LGg9e2dldFNlbGVjdGlvbjpmdW5jdGlvbigpe3ZhciBiO3RyeXtcclxuLy8gY2F0Y2ggYW55IGVycm9ycyBmcm9tIHJhbmd5IGFuZCBpZ25vcmUgdGhlIGlzc3VlXHJcbmI9YS5nZXRTZWxlY3Rpb24oKS5nZXRSYW5nZUF0KDApfWNhdGNoKGEpe1xyXG4vL2NvbnNvbGUuaW5mbyhlKTtcclxucmV0dXJufXZhciBjPWIuY29tbW9uQW5jZXN0b3JDb250YWluZXIsZD17c3RhcnQ6ZyhiLnN0YXJ0Q29udGFpbmVyLGIuc3RhcnRPZmZzZXQpLGVuZDpnKGIuZW5kQ29udGFpbmVyLGIuZW5kT2Zmc2V0KSxjb2xsYXBzZWQ6Yi5jb2xsYXBzZWR9O1xyXG4vL2NvbnNvbGUubG9nKCcqKipzZWxlY3Rpb24gY29udGFpbmVyOicsIHNlbGVjdGlvbi5jb250YWluZXIubm9kZU5hbWUsIHNlbGVjdGlvbi5zdGFydC5vZmZzZXQsIHNlbGVjdGlvbi5jb250YWluZXIpO1xyXG4vLyBUaGlzIGhhcyBwcm9ibGVtcyB1bmRlciBGaXJlZm94LlxyXG4vLyBPbiBGaXJlZm94IHdpdGhcclxuLy8gPHA+VHJ5IG1lICE8L3A+XHJcbi8vIDx1bD5cclxuLy8gPGxpPmxpbmUgMTwvbGk+XHJcbi8vIDxsaT5saW5lIDI8L2xpPlxyXG4vLyA8L3VsPlxyXG4vLyA8cD5saW5lIDM8L3A+XHJcbi8vIDx1bD5cclxuLy8gPGxpPmxpbmUgNDwvbGk+XHJcbi8vIDxsaT5saW5lIDU8L2xpPlxyXG4vLyA8L3VsPlxyXG4vLyA8cD5IZWxsbyB0ZXh0QW5ndWxhcjwvcD5cclxuLy8gV0lUSCB0aGUgY3Vyc29yIGFmdGVyIHRoZSAzIG9uIGxpbmUgMywgaXQgZ2V0cyB0aGUgY29tbW9uQW5jZXN0b3JDb250YWluZXIgYXM6XHJcbi8vIDxUZXh0Tm9kZSB0ZXh0Q29udGVudD0nbGluZSAzJz5cclxuLy8gQU5EIENocm9tZSBnZXRzIHRoZSBjb21tb25BbmNlc3RvckNvbnRhaW5lciBhczpcclxuLy8gPHA+bGluZSAzPC9wPlxyXG4vL1xyXG4vLyBDaGVjayBpZiB0aGUgY29udGFpbmVyIGlzIGEgdGV4dCBub2RlIGFuZCByZXR1cm4gaXRzIHBhcmVudCBpZiBzb1xyXG4vLyB1bmxlc3MgdGhpcyBpcyB0aGUgd2hvbGUgdGFUZXh0RWxlbWVudC4gIElmIHNvIHdlIHJldHVybiB0aGUgdGV4dE5vZGVcclxuLy9jb25zb2xlLmxvZygnKioqKioqKioqdGFUZXh0RWxlbWVudCoqKioqKioqKioqKicpO1xyXG4vL2NvbnNvbGUubG9nKCdjb21tb25BbmNlc3RvckNvbnRhaW5lcjonLCBjb250YWluZXIpO1xyXG5yZXR1cm4gMz09PWMubm9kZVR5cGUmJihcImRpdlwiPT09Yy5wYXJlbnROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkmJi9edGFUZXh0RWxlbWVudC8udGVzdChjLnBhcmVudE5vZGUuaWQpfHwoYz1jLnBhcmVudE5vZGUpKSxcImRpdlwiPT09Yy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpJiYvXnRhVGV4dEVsZW1lbnQvLnRlc3QoYy5pZCk/KGQuc3RhcnQuZWxlbWVudD1jLmNoaWxkTm9kZXNbZC5zdGFydC5vZmZzZXRdLGQuZW5kLmVsZW1lbnQ9Yy5jaGlsZE5vZGVzW2QuZW5kLm9mZnNldF0sZC5jb250YWluZXI9Yyk6Yy5wYXJlbnROb2RlPT09ZC5zdGFydC5lbGVtZW50fHxjLnBhcmVudE5vZGU9PT1kLmVuZC5lbGVtZW50P2QuY29udGFpbmVyPWMucGFyZW50Tm9kZTpkLmNvbnRhaW5lcj1jLGR9LFxyXG4vLyBpZiB3ZSB1c2UgdGhlIExFRlRfQVJST1cgYW5kIHdlIGFyZSBhdCB0aGUgc3BlY2lhbCBwbGFjZSA8c3Bhbj4mIzY1Mjc5Ozwvc3Bhbj4gd2UgbW92ZSB0aGUgY3Vyc29yIG92ZXIgYnkgb25lLi4uXHJcbi8vIENocm9tZSBhbmQgRmlyZWZveCBiZWhhdmUgZGlmZmVyZW50bHkgc28gc28gZml4IHRoaXMgZm9yIEZpcmVmb3ggaGVyZS4gIE5vIGFkanVzdG1lbnQgbmVlZGVkIGZvciBDaHJvbWUuXHJcbnVwZGF0ZUxlZnRBcnJvd0tleTpmdW5jdGlvbihiKXt2YXIgYz1hLmdldFNlbGVjdGlvbigpLmdldFJhbmdlQXQoMCk7aWYoYyYmYy5jb2xsYXBzZWQpe3ZhciBkPWguZ2V0RmxhdHRlbmVkRG9tKGMpO2lmKCFkLmZpbmRJbmRleClyZXR1cm47dmFyIGUsZixnPWMuc3RhcnRDb250YWluZXIsaT1kLmZpbmRJbmRleChmdW5jdGlvbihhLGIpe2lmKGEubm9kZT09PWcpcmV0dXJuITA7dmFyIGM9YS5wYXJlbnRzLmluZGV4T2YoZyk7cmV0dXJuIGMhPT0tMX0pO1xyXG4vL2NvbnNvbGUubG9nKCd1cGRhdGVMZWZ0QXJyb3dLZXknLCByYW5nZS5zdGFydE9mZnNldCwgcmFuZ2Uuc3RhcnRDb250YWluZXIudGV4dENvbnRlbnQpO1xyXG4vLyB0aGlzIGZpcnN0IHNlY3Rpb24gaGFuZGxlcyB0aGUgY2FzZSBmb3IgQ2hyb21lIGJyb3dzZXJcclxuLy8gaWYgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiB0aGUgbmV4dE5vZGUgaXMgYSBcXHVmZWZmIHdlIGtub3cgdGhhdCB3ZSBhcmUganVzdCBiZWZvcmUgdGhlIHNwZWNpYWwgc3Bhbi4uLlxyXG4vLyBhbmQgc28gd2UgbW9zdCBsZWZ0IGJ5IG9uZSBjaGFyYWN0ZXJcclxuaWYoXHJcbi8vY29uc29sZS5sb2coJ2luZGV4U3RhcnRDb250YWluZXInLCBpbmRleFN0YXJ0Q29udGFpbmVyLCBfbm9kZXMubGVuZ3RoLCAnc3RhcnRDb250YWluZXI6JywgX25vZGUsIF9ub2RlID09PSBfbm9kZXNbaW5kZXhTdGFydENvbnRhaW5lcl0ubm9kZSk7XHJcbmQuZm9yRWFjaChmdW5jdGlvbihhLGIpe1xyXG4vL2NvbnNvbGUubG9nKGksIG4ubm9kZSk7XHJcbmEucGFyZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGEsYil7fSl9KSxpKzE8ZC5sZW5ndGgmJihcclxuLy8gd2UgbmVlZCB0aGUgbm9kZSBqdXN0IGFmdGVyIHRoaXMgc3RhcnRDb250YWluZXJcclxuLy8gc28gd2UgY2FuIGNoZWNrIGFuZCBzZWUgaXQgdGhpcyBpcyBhIHNwZWNpYWwgcGxhY2VcclxuZj1kW2krMV0ubm9kZSksZiYmZi50ZXh0Q29udGVudCYmKGU9L15cXHVmZWZmKFteXFx1ZmVmZl0qKSQvLmV4ZWMoZi50ZXh0Q29udGVudCkpKVxyXG4vLyB3ZSBhcmUgYmVmb3JlIHRoZSBzcGVjaWFsIG5vZGUgd2l0aCBiZWdpbnMgd2l0aCBhIFxcdWZlZmYgY2hhcmFjdGVyXHJcbi8vY29uc29sZS5sb2coJ0xFRlQgLi4uZm91bmQgaXQuLi4nLCAnc3RhcnRPZmZzZXQ6JywgcmFuZ2Uuc3RhcnRPZmZzZXQsIG1bMF0ubGVuZ3RoLCBtWzFdLmxlbmd0aCk7XHJcbi8vIG5vIG5lZWQgdG8gY2hhbmdlIGFueXRoaW5nIGluIHRoaXMgY2FzZVxyXG5yZXR1cm47dmFyIGo7aWYoaT4wJiYoXHJcbi8vIHdlIG5lZWQgdGhlIG5vZGUganVzdCBhZnRlciB0aGlzIHN0YXJ0Q29udGFpbmVyXHJcbi8vIHNvIHdlIGNhbiBjaGVjayBhbmQgc2VlIGl0IHRoaXMgaXMgYSBzcGVjaWFsIHBsYWNlXHJcbmo9ZFtpLTFdLm5vZGUpLDA9PT1jLnN0YXJ0T2Zmc2V0JiZqJiYoXHJcbi8vY29uc29sZS5sb2cobmV4dE5vZGVUb0xlZnQsIHJhbmdlLnN0YXJ0T2Zmc2V0LCBuZXh0Tm9kZVRvTGVmdC50ZXh0Q29udGVudCk7XHJcbmU9L15cXHVmZWZmKFteXFx1ZmVmZl0qKSQvLmV4ZWMoai50ZXh0Q29udGVudCkpKVxyXG4vL2NvbnNvbGUubG9nKCdMRUZUICYmJiYmJiYmJiYmJiYmJiYmJiYuLi5mb3VuZCBpdC4uLiYmJiYmJiYmJiYmJywgbmV4dE5vZGVUb0xlZnQsIG1bMF0ubGVuZ3RoLCBtWzFdLmxlbmd0aCk7XHJcbi8vIG1vdmUgb3ZlciB0byB0aGUgbGVmdCBteSBvbmUgLS0gRmlyZWZveCB0cmlnZ2VycyB0aGlzIGNhc2VcclxucmV0dXJuIHZvaWQgaC5zZXRTZWxlY3Rpb25Ub0VsZW1lbnRFbmQoail9fSxcclxuLy8gaWYgd2UgdXNlIHRoZSBSSUdIVF9BUlJPVyBhbmQgd2UgYXJlIGF0IHRoZSBzcGVjaWFsIHBsYWNlIDxzcGFuPiYjNjUyNzk7PC9zcGFuPiB3ZSBtb3ZlIHRoZSBjdXJzb3Igb3ZlciBieSBvbmUuLi5cclxudXBkYXRlUmlnaHRBcnJvd0tleTpmdW5jdGlvbihhKXt9LGdldEZsYXR0ZW5lZERvbTpmdW5jdGlvbihhKXtmdW5jdGlvbiBiKGEpe2lmKGEubm9kZS5jaGlsZE5vZGVzLmxlbmd0aCl7dmFyIGM9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYS5ub2RlLmNoaWxkTm9kZXMpOy8vIGNvbnZlcnRzIE5vZGVMaXN0IHRvIEFycmF5XHJcbmMuZm9yRWFjaChmdW5jdGlvbihjKXt2YXIgZD1hLnBhcmVudHMuc2xpY2UoKTtkLnNsaWNlKC0xKVswXSE9PWEubm9kZSYmZC5wdXNoKGEubm9kZSksYih7cGFyZW50czpkLG5vZGU6Y30pfSl9ZWxzZSBkLnB1c2goe3BhcmVudHM6YS5wYXJlbnRzLG5vZGU6YS5ub2RlfSl9dmFyIGM9YS5jb21tb25BbmNlc3RvckNvbnRhaW5lci5wYXJlbnROb2RlO2lmKCFjKXJldHVybiBhLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyLmNoaWxkTm9kZXM7dmFyIGQ9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYy5jaGlsZE5vZGVzKSxlPWQuaW5kZXhPZihhLnN0YXJ0Q29udGFpbmVyKTtcclxuLy8gbWFrZSBzdXJlIHRoYXQgd2UgaGF2ZSBhIGJpZyBlbm91Z2ggc2V0IG9mIG5vZGVzXHJcbi8vIG5vdyB3YWxrIHRoZSBwYXJlbnRcclxucmV0dXJuIGUrMTxkLmxlbmd0aCYmZT4wfHxjLnBhcmVudE5vZGUmJihjPWMucGFyZW50Tm9kZSksZD1bXSxiKHtwYXJlbnRzOltjXSxub2RlOmN9KSxkfSxnZXRPbmx5U2VsZWN0ZWRFbGVtZW50czpmdW5jdGlvbigpe3ZhciBiPWEuZ2V0U2VsZWN0aW9uKCkuZ2V0UmFuZ2VBdCgwKSxjPWIuY29tbW9uQW5jZXN0b3JDb250YWluZXI7XHJcbi8vIGdldCB0aGUgbm9kZXMgaW4gdGhlIHJhbmdlIHRoYXQgYXJlIEVMRU1FTlRfTk9ERSBhbmQgYXJlIGNoaWxkcmVuIG9mIHRoZSBjb250YWluZXJcclxuLy8gaW4gdGhpcyByYW5nZS4uLlxyXG4vLyBOb2RlLlRFWFRfTk9ERSA9PT0gM1xyXG4vLyBOb2RlLkVMRU1FTlRfTk9ERSA9PT0gMVxyXG4vLyBOb2RlLkNPTU1FTlRfTk9ERSA9PT0gOFxyXG4vLyBDaGVjayBpZiB0aGUgY29udGFpbmVyIGlzIGEgdGV4dCBub2RlIGFuZCByZXR1cm4gaXRzIHBhcmVudCBpZiBzb1xyXG5yZXR1cm4gYz0zPT09Yy5ub2RlVHlwZT9jLnBhcmVudE5vZGU6YyxiLmdldE5vZGVzKFsxXSxmdW5jdGlvbihhKXtyZXR1cm4gYS5wYXJlbnROb2RlPT09Y30pfSxcclxuLy8gdGhpcyBpbmNsdWRlcyB0aGUgY29udGFpbmVyIGVsZW1lbnQgaWYgYWxsIGNoaWxkcmVuIGFyZSBzZWxlY3RlZFxyXG5nZXRBbGxTZWxlY3RlZEVsZW1lbnRzOmZ1bmN0aW9uKCl7dmFyIGI9YS5nZXRTZWxlY3Rpb24oKS5nZXRSYW5nZUF0KDApLGM9Yi5jb21tb25BbmNlc3RvckNvbnRhaW5lcjtcclxuLy8gTm9kZS5URVhUX05PREUgPT09IDNcclxuLy8gTm9kZS5FTEVNRU5UX05PREUgPT09IDFcclxuLy8gTm9kZS5DT01NRU5UX05PREUgPT09IDhcclxuLy8gQ2hlY2sgaWYgdGhlIGNvbnRhaW5lciBpcyBhIHRleHQgbm9kZSBhbmQgcmV0dXJuIGl0cyBwYXJlbnQgaWYgc29cclxuYz0zPT09Yy5ub2RlVHlwZT9jLnBhcmVudE5vZGU6YztcclxuLy8gZ2V0IHRoZSBub2RlcyBpbiB0aGUgcmFuZ2UgdGhhdCBhcmUgRUxFTUVOVF9OT0RFIGFuZCBhcmUgY2hpbGRyZW4gb2YgdGhlIGNvbnRhaW5lclxyXG4vLyBpbiB0aGlzIHJhbmdlLi4uXHJcbnZhciBkPWIuZ2V0Tm9kZXMoWzFdLGZ1bmN0aW9uKGEpe3JldHVybiBhLnBhcmVudE5vZGU9PT1jfSksZT1jLmlubmVySFRNTDtcclxuLy9jb25zb2xlLmxvZyhpbm5lckh0bWwpO1xyXG4vL2NvbnNvbGUubG9nKHJhbmdlLnRvSHRtbCgpKTtcclxuLy9jb25zb2xlLmxvZyhpbm5lckh0bWwgPT09IHJhbmdlLnRvSHRtbCgpKTtcclxuaWYoXHJcbi8vIHJlbW92ZSB0aGUganVuayB0aGF0IHJhbmd5IGhhcyBwdXQgZG93blxyXG5lPWUucmVwbGFjZSgvPHNwYW4gaWQ9LnNlbGVjdGlvbkJvdW5kYXJ5W14+XSs+XFx1ZmVmZj88XFwvc3Bhbj4vZ2ksXCJcIiksZT09PWIudG9IdG1sKCkmJihcImRpdlwiIT09Yy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpfHwhL150YVRleHRFbGVtZW50Ly50ZXN0KGMuaWQpKSl7Zm9yKHZhciBmPVtdLGc9ZC5sZW5ndGg7Zy0tO2YudW5zaGlmdChkW2ddKSk7ZD1mLGQucHVzaChjKX1yZXR1cm4gZH0sXHJcbi8vIFNvbWUgYmFzaWMgc2VsZWN0aW9uIGZ1bmN0aW9uc1xyXG5nZXRTZWxlY3Rpb25FbGVtZW50OmZ1bmN0aW9uKCl7dmFyIGE9aC5nZXRTZWxlY3Rpb24oKTtyZXR1cm4gYT9oLmdldFNlbGVjdGlvbigpLmNvbnRhaW5lcjp2b2lkIDB9LHNldFNlbGVjdGlvbjpmdW5jdGlvbihiLGMsZCxlKXt2YXIgZj1hLmNyZWF0ZVJhbmdlKCk7Zi5zZXRTdGFydChiLGQpLGYuc2V0RW5kKGMsZSksYS5nZXRTZWxlY3Rpb24oKS5zZXRTaW5nbGVSYW5nZShmKX0sc2V0U2VsZWN0aW9uQmVmb3JlRWxlbWVudDpmdW5jdGlvbihiKXt2YXIgYz1hLmNyZWF0ZVJhbmdlKCk7Yy5zZWxlY3ROb2RlKGIpLGMuY29sbGFwc2UoITApLGEuZ2V0U2VsZWN0aW9uKCkuc2V0U2luZ2xlUmFuZ2UoYyl9LHNldFNlbGVjdGlvbkFmdGVyRWxlbWVudDpmdW5jdGlvbihiKXt2YXIgYz1hLmNyZWF0ZVJhbmdlKCk7Yy5zZWxlY3ROb2RlKGIpLGMuY29sbGFwc2UoITEpLGEuZ2V0U2VsZWN0aW9uKCkuc2V0U2luZ2xlUmFuZ2UoYyl9LHNldFNlbGVjdGlvblRvRWxlbWVudFN0YXJ0OmZ1bmN0aW9uKGIpe3ZhciBjPWEuY3JlYXRlUmFuZ2UoKTtjLnNlbGVjdE5vZGVDb250ZW50cyhiKSxjLmNvbGxhcHNlKCEwKSxhLmdldFNlbGVjdGlvbigpLnNldFNpbmdsZVJhbmdlKGMpfSxzZXRTZWxlY3Rpb25Ub0VsZW1lbnRFbmQ6ZnVuY3Rpb24oYil7dmFyIGM9YS5jcmVhdGVSYW5nZSgpO2Muc2VsZWN0Tm9kZUNvbnRlbnRzKGIpLGMuY29sbGFwc2UoITEpLGIuY2hpbGROb2RlcyYmYi5jaGlsZE5vZGVzW2IuY2hpbGROb2Rlcy5sZW5ndGgtMV0mJlwiYnJcIj09PWIuY2hpbGROb2Rlc1tiLmNoaWxkTm9kZXMubGVuZ3RoLTFdLm5vZGVOYW1lJiYoYy5zdGFydE9mZnNldD1jLmVuZE9mZnNldD1jLnN0YXJ0T2Zmc2V0LTEpLGEuZ2V0U2VsZWN0aW9uKCkuc2V0U2luZ2xlUmFuZ2UoYyl9LHNldFN0YXRlU2hpZnRLZXk6ZnVuY3Rpb24oYSl7ZT1hfSxnZXRTdGF0ZVNoaWZ0S2V5OmZ1bmN0aW9uKCl7cmV0dXJuIGV9LFxyXG4vLyBmcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNjY5MDc1Mi9pbnNlcnQtaHRtbC1hdC1jYXJldC1pbi1hLWNvbnRlbnRlZGl0YWJsZS1kaXZcclxuLy8gdG9wTm9kZSBpcyB0aGUgY29udGVudGVkaXRhYmxlIG5vcm1hbGx5LCBhbGwgbWFuaXB1bGF0aW9uIE1VU1QgYmUgaW5zaWRlIHRoaXMuXHJcbmluc2VydEh0bWw6ZnVuY3Rpb24oYixkKXt2YXIgZSxnLGosbCxtLG4sbyxwPWFuZ3VsYXIuZWxlbWVudChcIjxkaXY+XCIrYitcIjwvZGl2PlwiKSxxPWEuZ2V0U2VsZWN0aW9uKCkuZ2V0UmFuZ2VBdCgwKSxyPWYuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLHM9cFswXS5jaGlsZE5vZGVzLHQ9ITA7aWYocy5sZW5ndGg+MCl7Zm9yKFxyXG4vLyBOT1RFISEgV2UgbmVlZCB0byBkbyB0aGUgZm9sbG93aW5nOlxyXG4vLyBjaGVjayBmb3IgYmxvY2tlbGVtZW50cyAtIGlmIHRoZXkgZXhpc3QgdGhlbiB3ZSBoYXZlIHRvIHNwbGl0IHRoZSBjdXJyZW50IGVsZW1lbnQgaW4gaGFsZiAoYW5kIGFsbCBvdGhlcnMgdXAgdG8gdGhlIGNsb3Nlc3QgYmxvY2sgZWxlbWVudCkgYW5kIGluc2VydCBhbGwgY2hpbGRyZW4gaW4tYmV0d2Vlbi5cclxuLy8gSWYgdGhlcmUgYXJlIG5vIGJsb2NrIGVsZW1lbnRzLCBvciB0aGVyZSBpcyBhIG1peHR1cmUgd2UgbmVlZCB0byBjcmVhdGUgdGV4dE5vZGVzIGZvciB0aGUgbm9uIHdyYXBwZWQgdGV4dCAod2UgZG9uJ3Qgd2FudCB0aGVtIHNwYW5zIG1lc3NpbmcgdXAgdGhlIHBpY3R1cmUpLlxyXG5sPVtdLGo9MDtqPHMubGVuZ3RoO2orKyl7dmFyIHU9c1tqXTtcInBcIj09PXUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSYmXCJcIj09PXUuaW5uZXJIVE1MLnRyaW0oKXx8KC8qKioqKioqKioqKioqKioqXHJcblx0XHRcdFx0XHQgKiAgYWxsb3cgYW55IHRleHQgdG8gYmUgaW5zZXJ0ZWQuLi5cclxuXHRcdFx0XHRcdGlmKCggICBfY25vZGUubm9kZVR5cGUgPT09IDMgJiZcclxuXHRcdFx0XHRcdFx0ICAgX2Nub2RlLm5vZGVWYWx1ZSA9PT0gJ1xcdWZlZmYnWzBdICYmXHJcblx0XHRcdFx0XHRcdCAgIF9jbm9kZS5ub2RlVmFsdWUudHJpbSgpID09PSAnJykgLy8gZW1wdHkgbm8tc3BhY2Ugc3BhY2UgZWxlbWVudFxyXG5cdFx0XHRcdFx0XHQpIHtcclxuXHRcdFx0XHRcdFx0Ly8gbm8gY2hhbmdlIHRvIGlzSW5saW5lXHJcblx0XHRcdFx0XHRcdG5vZGVzLnB1c2goX2Nub2RlKTtcclxuXHRcdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZihfY25vZGUubm9kZVR5cGUgPT09IDMgJiZcclxuXHRcdFx0XHRcdFx0IF9jbm9kZS5ub2RlVmFsdWUudHJpbSgpID09PSAnJykgeyAvLyBlbXB0eSB0ZXh0IG5vZGVcclxuXHRcdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHQqKioqKioqKioqKioqKioqKi9cclxudD10JiYhaS50ZXN0KHUubm9kZU5hbWUpLGwucHVzaCh1KSl9Zm9yKHZhciB2PTA7djxsLmxlbmd0aDt2Kyspbj1yLmFwcGVuZENoaWxkKGxbdl0pOyF0JiZxLmNvbGxhcHNlZCYmL14ofDxicih8XFwvKT4pJC9pLnRlc3QocS5zdGFydENvbnRhaW5lci5pbm5lckhUTUwpJiZxLnNlbGVjdE5vZGUocS5zdGFydENvbnRhaW5lcil9ZWxzZSB0PSEwLFxyXG4vLyBwYXN0ZSB0ZXh0IG9mIHNvbWUgc29ydFxyXG5uPXI9Zi5jcmVhdGVUZXh0Tm9kZShiKTtcclxuLy8gT3RoZXIgRWRnZSBjYXNlIC0gc2VsZWN0ZWQgZGF0YSBzcGFucyBtdWx0aXBsZSBibG9ja3MuXHJcbmlmKHQpcS5kZWxldGVDb250ZW50cygpO2Vsc2UvLyBub3QgaW5saW5lIGluc2VydFxyXG5pZihxLmNvbGxhcHNlZCYmcS5zdGFydENvbnRhaW5lciE9PWQpaWYocS5zdGFydENvbnRhaW5lci5pbm5lckhUTUwmJnEuc3RhcnRDb250YWluZXIuaW5uZXJIVE1MLm1hdGNoKC9ePFtePl0qPiQvaSkpXHJcbi8vIHRoaXMgbG9nIGlzIHRvIGNhdGNoIHdoZW4gaW5uZXJIVE1MIGlzIHNvbWV0aGluZyBsaWtlIGA8aW1nIC4uLj5gXHJcbmU9cS5zdGFydENvbnRhaW5lciwxPT09cS5zdGFydE9mZnNldD8oXHJcbi8vIGJlZm9yZSBzaW5nbGUgdGFnXHJcbnEuc2V0U3RhcnRBZnRlcihlKSxxLnNldEVuZEFmdGVyKGUpKTooXHJcbi8vIGFmdGVyIHNpbmdsZSB0YWdcclxucS5zZXRTdGFydEJlZm9yZShlKSxxLnNldEVuZEJlZm9yZShlKSk7ZWxzZXtcclxuLy8gc3BsaXQgZWxlbWVudCBpbnRvIDIgYW5kIGluc2VydCBibG9jayBlbGVtZW50IGluIG1pZGRsZVxyXG5pZigzPT09cS5zdGFydENvbnRhaW5lci5ub2RlVHlwZSYmcS5zdGFydENvbnRhaW5lci5wYXJlbnROb2RlIT09ZClcclxuLy8gRXNjYXBlIG91dCBvZiB0aGUgaW5saW5lIHRhZ3MgbGlrZSBiXHJcbmZvcigvLyBpZiB0ZXh0IG5vZGVcclxuZT1xLnN0YXJ0Q29udGFpbmVyLnBhcmVudE5vZGUsZz1lLmNsb25lTm9kZSgpLFxyXG4vLyBzcGxpdCB0aGUgbm9kZXMgaW50byB0d28gbGlzdHMgLSBiZWZvcmUgYW5kIGFmdGVyLCBzcGxpdHRpbmcgdGhlIG5vZGUgd2l0aCB0aGUgc2VsZWN0aW9uIGludG8gMiB0ZXh0IG5vZGVzLlxyXG5jLnNwbGl0Tm9kZXMoZS5jaGlsZE5vZGVzLGUsZyxxLnN0YXJ0Q29udGFpbmVyLHEuc3RhcnRPZmZzZXQpOyFrLnRlc3QoZS5ub2RlTmFtZSk7KXthbmd1bGFyLmVsZW1lbnQoZSkuYWZ0ZXIoZyksZT1lLnBhcmVudE5vZGU7dmFyIHc9ZztnPWUuY2xvbmVOb2RlKCksXHJcbi8vIHNwbGl0IHRoZSBub2RlcyBpbnRvIHR3byBsaXN0cyAtIGJlZm9yZSBhbmQgYWZ0ZXIsIHNwbGl0dGluZyB0aGUgbm9kZSB3aXRoIHRoZSBzZWxlY3Rpb24gaW50byAyIHRleHQgbm9kZXMuXHJcbmMuc3BsaXROb2RlcyhlLmNoaWxkTm9kZXMsZSxnLHcpfWVsc2UgZT1xLnN0YXJ0Q29udGFpbmVyLGc9ZS5jbG9uZU5vZGUoKSxjLnNwbGl0Tm9kZXMoZS5jaGlsZE5vZGVzLGUsZyx2b2lkIDAsdm9pZCAwLHEuc3RhcnRPZmZzZXQpO2lmKGFuZ3VsYXIuZWxlbWVudChlKS5hZnRlcihnKSxcclxuLy8gcHV0IGN1cnNvciB0byBlbmQgb2YgaW5zZXJ0ZWQgY29udGVudFxyXG4vL2NvbnNvbGUubG9nKCdzZXRTdGFydEFmdGVyJywgcGFyZW50KTtcclxucS5zZXRTdGFydEFmdGVyKGUpLHEuc2V0RW5kQWZ0ZXIoZSksL14ofDxicih8XFwvKT4pJC9pLnRlc3QoZS5pbm5lckhUTUwudHJpbSgpKSYmKHEuc2V0U3RhcnRCZWZvcmUoZSkscS5zZXRFbmRCZWZvcmUoZSksYW5ndWxhci5lbGVtZW50KGUpLnJlbW92ZSgpKSwvXih8PGJyKHxcXC8pPikkL2kudGVzdChnLmlubmVySFRNTC50cmltKCkpJiZhbmd1bGFyLmVsZW1lbnQoZykucmVtb3ZlKCksXCJsaVwiPT09ZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKXtmb3Iobz1mLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxtPTA7bTxyLmNoaWxkTm9kZXMubGVuZ3RoO20rKylwPWFuZ3VsYXIuZWxlbWVudChcIjxsaT5cIiksYy50cmFuc2ZlckNoaWxkTm9kZXMoci5jaGlsZE5vZGVzW21dLHBbMF0pLGMudHJhbnNmZXJOb2RlQXR0cmlidXRlcyhyLmNoaWxkTm9kZXNbbV0scFswXSksby5hcHBlbmRDaGlsZChwWzBdKTtyPW8sbiYmKG49ci5jaGlsZE5vZGVzW3IuY2hpbGROb2Rlcy5sZW5ndGgtMV0sbj1uLmNoaWxkTm9kZXNbbi5jaGlsZE5vZGVzLmxlbmd0aC0xXSl9fWVsc2UgcS5kZWxldGVDb250ZW50cygpO3EuaW5zZXJ0Tm9kZShyKSxuJiZoLnNldFNlbGVjdGlvblRvRWxlbWVudEVuZChuKX19O3JldHVybiBofV0pLnNlcnZpY2UoXCJ0YURPTVwiLGZ1bmN0aW9uKCl7dmFyIGE9e1xyXG4vLyByZWN1cnNpdmUgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIGFycmF5IG9mIGFuZ3VsYXIuZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwYXNzZWQgYXR0cmlidXRlIHNldCBvbiB0aGVtXHJcbmdldEJ5QXR0cmlidXRlOmZ1bmN0aW9uKGIsYyl7dmFyIGQ9W10sZT1iLmNoaWxkcmVuKCk7cmV0dXJuIGUubGVuZ3RoJiZhbmd1bGFyLmZvckVhY2goZSxmdW5jdGlvbihiKXtkPWQuY29uY2F0KGEuZ2V0QnlBdHRyaWJ1dGUoYW5ndWxhci5lbGVtZW50KGIpLGMpKX0pLHZvaWQgMCE9PWIuYXR0cihjKSYmZC5wdXNoKGIpLGR9LHRyYW5zZmVyQ2hpbGROb2RlczpmdW5jdGlvbihhLGIpe2ZvcihcclxuLy8gY2xlYXIgb3V0IHRhcmdldFxyXG5iLmlubmVySFRNTD1cIlwiO2EuY2hpbGROb2Rlcy5sZW5ndGg+MDspYi5hcHBlbmRDaGlsZChhLmNoaWxkTm9kZXNbMF0pO3JldHVybiBifSxzcGxpdE5vZGVzOmZ1bmN0aW9uKGIsYyxkLGUsZixnKXtpZighZSYmaXNOYU4oZykpdGhyb3cgbmV3IEVycm9yKFwidGFET00uc3BsaXROb2RlcyByZXF1aXJlcyBhIHNwbGl0Tm9kZSBvciBzcGxpdEluZGV4XCIpO2Zvcih2YXIgaD1kb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksaT1kb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksaj0wO2IubGVuZ3RoPjAmJihpc05hTihnKXx8ZyE9PWopJiZiWzBdIT09ZTspaC5hcHBlbmRDaGlsZChiWzBdKSwvLyB0aGlzIHJlbW92ZXMgZnJvbSB0aGUgbm9kZXMgYXJyYXkgKGlmIHByb3BlciBjaGlsZE5vZGVzIG9iamVjdC5cclxuaisrO2ZvcighaXNOYU4oZikmJmY+PTAmJmJbMF0mJihoLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGJbMF0ubm9kZVZhbHVlLnN1YnN0cmluZygwLGYpKSksYlswXS5ub2RlVmFsdWU9YlswXS5ub2RlVmFsdWUuc3Vic3RyaW5nKGYpKTtiLmxlbmd0aD4wOylpLmFwcGVuZENoaWxkKGJbMF0pO2EudHJhbnNmZXJDaGlsZE5vZGVzKGgsYyksYS50cmFuc2ZlckNoaWxkTm9kZXMoaSxkKX0sdHJhbnNmZXJOb2RlQXR0cmlidXRlczpmdW5jdGlvbihhLGIpe2Zvcih2YXIgYz0wO2M8YS5hdHRyaWJ1dGVzLmxlbmd0aDtjKyspYi5zZXRBdHRyaWJ1dGUoYS5hdHRyaWJ1dGVzW2NdLm5hbWUsYS5hdHRyaWJ1dGVzW2NdLnZhbHVlKTtyZXR1cm4gYn19O3JldHVybiBhfSksYW5ndWxhci5tb2R1bGUoXCJ0ZXh0QW5ndWxhci52YWxpZGF0b3JzXCIsW10pLmRpcmVjdGl2ZShcInRhTWF4VGV4dFwiLGZ1bmN0aW9uKCl7cmV0dXJue3Jlc3RyaWN0OlwiQVwiLHJlcXVpcmU6XCJuZ01vZGVsXCIsbGluazpmdW5jdGlvbihhLGIsYyxkKXt2YXIgZT1wYXJzZUludChhLiRldmFsKGMudGFNYXhUZXh0KSk7aWYoaXNOYU4oZSkpdGhyb3dcIk1heCB0ZXh0IG11c3QgYmUgYW4gaW50ZWdlclwiO2MuJG9ic2VydmUoXCJ0YU1heFRleHRcIixmdW5jdGlvbihhKXtpZihlPXBhcnNlSW50KGEpLGlzTmFOKGUpKXRocm93XCJNYXggdGV4dCBtdXN0IGJlIGFuIGludGVnZXJcIjtkLiRkaXJ0eSYmZC4kdmFsaWRhdGUoKX0pLGQuJHZhbGlkYXRvcnMudGFNYXhUZXh0PWZ1bmN0aW9uKGEpe3ZhciBiPWFuZ3VsYXIuZWxlbWVudChcIjxkaXYvPlwiKTtyZXR1cm4gYi5odG1sKGEpLGIudGV4dCgpLmxlbmd0aDw9ZX19fX0pLmRpcmVjdGl2ZShcInRhTWluVGV4dFwiLGZ1bmN0aW9uKCl7cmV0dXJue3Jlc3RyaWN0OlwiQVwiLHJlcXVpcmU6XCJuZ01vZGVsXCIsbGluazpmdW5jdGlvbihhLGIsYyxkKXt2YXIgZT1wYXJzZUludChhLiRldmFsKGMudGFNaW5UZXh0KSk7aWYoaXNOYU4oZSkpdGhyb3dcIk1pbiB0ZXh0IG11c3QgYmUgYW4gaW50ZWdlclwiO2MuJG9ic2VydmUoXCJ0YU1pblRleHRcIixmdW5jdGlvbihhKXtpZihlPXBhcnNlSW50KGEpLGlzTmFOKGUpKXRocm93XCJNaW4gdGV4dCBtdXN0IGJlIGFuIGludGVnZXJcIjtkLiRkaXJ0eSYmZC4kdmFsaWRhdGUoKX0pLGQuJHZhbGlkYXRvcnMudGFNaW5UZXh0PWZ1bmN0aW9uKGEpe3ZhciBiPWFuZ3VsYXIuZWxlbWVudChcIjxkaXYvPlwiKTtyZXR1cm4gYi5odG1sKGEpLCFiLnRleHQoKS5sZW5ndGh8fGIudGV4dCgpLmxlbmd0aD49ZX19fX0pLGFuZ3VsYXIubW9kdWxlKFwidGV4dEFuZ3VsYXIudGFCaW5kXCIsW1widGV4dEFuZ3VsYXIuZmFjdG9yaWVzXCIsXCJ0ZXh0QW5ndWxhci5ET01cIl0pLnNlcnZpY2UoXCJfdGFCbGFua1Rlc3RcIixbZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24oYSl7XHJcbi8vIHdlIHJhZGljYWxseSByZXN0cnVjdHVyZSB0aGlzIGNvZGUuXHJcbi8vIHdoYXQgd2FzIGhlcmUgYmVmb3JlIHdhcyBpbmNyZWRpYmx5IGZyYWdpbGUuXHJcbi8vIFdoYXQgd2UgZG8gbm93IGlzIHRvIGNoZWNrIHRoYXQgdGhlIGh0bWwgaXMgbm9uLWJsYW5rIHZpc3VhbGx5XHJcbi8vIHdoaWNoIHdlIGNoZWNrIGJ5IGxvb2tpbmcgYXQgaHRtbC0+dGV4dFxyXG5pZighYSlyZXR1cm4hMDtcclxuLy8gZmluZCBmaXJzdCBub24tdGFnIG1hdGNoIC0gaWUgc3RhcnQgb2Ygc3RyaW5nIG9yIGFmdGVyIHRhZyB0aGF0IGlzIG5vdCB3aGl0ZXNwYWNlXHJcbi8vIHZhciB0MCA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4vLyBUYWtlcyBhIHNtYWxsIGZyYWN0aW9uIG9mIGEgbVNlYyB0byBkbyB0aGlzLi4uXHJcbnZhciBiPWQoYSk7XHJcbi8vIHZhciB0MSA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4vLyBjb25zb2xlLmxvZygnVG9vaycsICh0MSAtIHQwKS50b0ZpeGVkKDQpLCAnbWlsbGlzZWNvbmRzIHRvIGdlbmVyYXRlOicpO1xyXG4vLyB2YXIgdDEgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuLy8gY29uc29sZS5sb2coJ1Rvb2snLCAodDEgLSB0MCkudG9GaXhlZCg0KSwgJ21pbGxpc2Vjb25kcyB0byBnZW5lcmF0ZTonKTtcclxucmV0dXJuXCJcIj09PWImJiEvPGltZ1tePl0rPi8udGVzdChhKX19XSkuZGlyZWN0aXZlKFwidGFCdXR0b25cIixbZnVuY3Rpb24oKXtyZXR1cm57bGluazpmdW5jdGlvbihhLGIsYyl7Yi5hdHRyKFwidW5zZWxlY3RhYmxlXCIsXCJvblwiKSxiLm9uKFwibW91c2Vkb3duXCIsZnVuY3Rpb24oYSxiKXsvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZTogdGhpcyBpcyBmb3IgY2F0Y2hpbmcgdGhlIGpxTGl0ZSB0ZXN0aW5nKi9cclxuLy8gdGhpcyBwcmV2ZW50cyBmb2N1c291dCBmcm9tIGZpcmluZyBvbiB0aGUgZWRpdG9yIHdoZW4gY2xpY2tpbmcgdG9vbGJhciBidXR0b25zXHJcbnJldHVybiBiJiZhbmd1bGFyLmV4dGVuZChhLGIpLGEucHJldmVudERlZmF1bHQoKSwhMX0pfX19XSkuZGlyZWN0aXZlKFwidGFCaW5kXCIsW1widGFTYW5pdGl6ZVwiLFwiJHRpbWVvdXRcIixcIiRkb2N1bWVudFwiLFwidGFGaXhDaHJvbWVcIixcInRhQnJvd3NlclRhZ1wiLFwidGFTZWxlY3Rpb25cIixcInRhU2VsZWN0YWJsZUVsZW1lbnRzXCIsXCJ0YUFwcGx5Q3VzdG9tUmVuZGVyZXJzXCIsXCJ0YU9wdGlvbnNcIixcIl90YUJsYW5rVGVzdFwiLFwiJHBhcnNlXCIsXCJ0YURPTVwiLFwidGV4dEFuZ3VsYXJNYW5hZ2VyXCIsZnVuY3Rpb24oYixjLGQsZSxmLGgsaixsLG8scCxxLHIscyl7XHJcbi8vIFVzZXMgZm9yIHRoaXMgYXJlIHRleHRhcmVhIG9yIGlucHV0IHdpdGggbmctbW9kZWwgYW5kIHRhLWJpbmQ9J3RleHQnXHJcbi8vIE9SIGFueSBub24tZm9ybSBlbGVtZW50IHdpdGggY29udGVudGVkaXRhYmxlPVwiY29udGVudGVkaXRhYmxlXCIgdGEtYmluZD1cImh0bWx8dGV4dFwiIG5nLW1vZGVsXHJcbnJldHVybntwcmlvcml0eToyLC8vIFNvIHdlIG92ZXJyaWRlIHZhbGlkYXRvcnMgY29ycmVjdGx5XHJcbnJlcXVpcmU6W1wibmdNb2RlbFwiLFwiP25nTW9kZWxPcHRpb25zXCJdLGxpbms6ZnVuY3Rpb24oZix1LHYsdyl7ZnVuY3Rpb24geChhKXt2YXIgYjtyZXR1cm4gVi5mb3JFYWNoKGZ1bmN0aW9uKGMpe2lmKGMua2V5Q29kZT09PWEua2V5Q29kZSl7dmFyIGQ9KGEubWV0YUtleT9OOjApKyhhLmN0cmxLZXk/TTowKSsoYS5zaGlmdEtleT9QOjApKyhhLmFsdEtleT9POjApO2lmKGMuZm9yYmlkZGVuTW9kaWZpZXJzJmQpcmV0dXJuO2MubXVzdEhhdmVNb2RpZmllcnMuZXZlcnkoZnVuY3Rpb24oYSl7cmV0dXJuIGQmYX0pJiYoYj1jLnNwZWNpYWxLZXkpfX0pLGJ9dmFyIHkseixBLEIsQz13WzBdLEQ9d1sxXXx8e30sRT12b2lkIDAhPT11LmF0dHIoXCJjb250ZW50ZWRpdGFibGVcIikmJnUuYXR0cihcImNvbnRlbnRlZGl0YWJsZVwiKSxGPUV8fFwidGV4dGFyZWFcIj09PXVbMF0udGFnTmFtZS50b0xvd2VyQ2FzZSgpfHxcImlucHV0XCI9PT11WzBdLnRhZ05hbWUudG9Mb3dlckNhc2UoKSxHPSExLEg9ITEsST0hMSxKPXYudGFVbnNhZmVTYW5pdGl6ZXJ8fG8uZGlzYWJsZVNhbml0aXplcixLPS9eKDl8MTl8MjB8Mjd8MzN8MzR8MzV8MzZ8Mzd8Mzh8Mzl8NDB8NDV8MTEyfDExM3wxMTR8MTE1fDExNnwxMTd8MTE4fDExOXwxMjB8MTIxfDEyMnwxMjN8MTQ0fDE0NSkkL2ksTD0vXig4fDEzfDMyfDQ2fDU5fDYxfDEwN3wxMDl8MTczfDE4NnwxODd8MTg4fDE4OXwxOTB8MTkxfDE5MnwyMTl8MjIwfDIyMXwyMjIpJC9pLE09MSxOPTIsTz00LFA9OCxRPTEzLFI9MTYsUz05LFQ9MzcsVT0zOSxWPVtcclxuLy9cdFx0Y3RybC9jb21tYW5kICsgelxyXG57c3BlY2lhbEtleTpcIlVuZG9LZXlcIixmb3JiaWRkZW5Nb2RpZmllcnM6TytQLG11c3RIYXZlTW9kaWZpZXJzOltOK01dLGtleUNvZGU6OTB9LFxyXG4vL1x0XHRjdHJsL2NvbW1hbmQgKyBzaGlmdCArIHpcclxue3NwZWNpYWxLZXk6XCJSZWRvS2V5XCIsZm9yYmlkZGVuTW9kaWZpZXJzOk8sbXVzdEhhdmVNb2RpZmllcnM6W04rTSxQXSxrZXlDb2RlOjkwfSxcclxuLy9cdFx0Y3RybC9jb21tYW5kICsgeVxyXG57c3BlY2lhbEtleTpcIlJlZG9LZXlcIixmb3JiaWRkZW5Nb2RpZmllcnM6TytQLG11c3RIYXZlTW9kaWZpZXJzOltOK01dLGtleUNvZGU6ODl9LFxyXG4vL1x0XHRUYWJLZXlcclxue3NwZWNpYWxLZXk6XCJUYWJLZXlcIixmb3JiaWRkZW5Nb2RpZmllcnM6TitQK08rTSxtdXN0SGF2ZU1vZGlmaWVyczpbXSxrZXlDb2RlOlN9LFxyXG4vL1x0XHRzaGlmdCArIFRhYktleVxyXG57c3BlY2lhbEtleTpcIlNoaWZ0VGFiS2V5XCIsZm9yYmlkZGVuTW9kaWZpZXJzOk4rTytNLG11c3RIYXZlTW9kaWZpZXJzOltQXSxrZXlDb2RlOlN9XTtcclxuLy8gc2V0IHRoZSBkZWZhdWx0IHRvIGJlIGEgcGFyYWdyYXBoIHZhbHVlXHJcbnZvaWQgMD09PXYudGFEZWZhdWx0V3JhcCYmKHYudGFEZWZhdWx0V3JhcD1cInBcIiksLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IGllIHNwZWNpZmljIHRlc3QgKi9cclxuXCJcIj09PXYudGFEZWZhdWx0V3JhcD8oQT1cIlwiLEI9dm9pZCAwPT09Zy5pZT9cIjxkaXY+PGJyPjwvZGl2PlwiOmcuaWU+PTExP1wiPHA+PGJyPjwvcD5cIjpnLmllPD04P1wiPFA+Jm5ic3A7PC9QPlwiOlwiPHA+Jm5ic3A7PC9wPlwiKTooQT12b2lkIDA9PT1nLmllfHxnLmllPj0xMT9cImJyXCI9PT12LnRhRGVmYXVsdFdyYXAudG9Mb3dlckNhc2UoKT9cIjxCUj48QlI+XCI6XCI8XCIrdi50YURlZmF1bHRXcmFwK1wiPjxicj48L1wiK3YudGFEZWZhdWx0V3JhcCtcIj5cIjpnLmllPD04P1wiPFwiK3YudGFEZWZhdWx0V3JhcC50b1VwcGVyQ2FzZSgpK1wiPjwvXCIrdi50YURlZmF1bHRXcmFwLnRvVXBwZXJDYXNlKCkrXCI+XCI6XCI8XCIrdi50YURlZmF1bHRXcmFwK1wiPjwvXCIrdi50YURlZmF1bHRXcmFwK1wiPlwiLEI9dm9pZCAwPT09Zy5pZXx8Zy5pZT49MTE/XCJiclwiPT09di50YURlZmF1bHRXcmFwLnRvTG93ZXJDYXNlKCk/XCI8YnI+PGJyPlwiOlwiPFwiK3YudGFEZWZhdWx0V3JhcCtcIj48YnI+PC9cIit2LnRhRGVmYXVsdFdyYXArXCI+XCI6Zy5pZTw9OD9cIjxcIit2LnRhRGVmYXVsdFdyYXAudG9VcHBlckNhc2UoKStcIj4mbmJzcDs8L1wiK3YudGFEZWZhdWx0V3JhcC50b1VwcGVyQ2FzZSgpK1wiPlwiOlwiPFwiK3YudGFEZWZhdWx0V3JhcCtcIj4mbmJzcDs8L1wiK3YudGFEZWZhdWx0V3JhcCtcIj5cIiksLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cclxuRC4kb3B0aW9uc3x8KEQuJG9wdGlvbnM9e30pOy8vIG5nLW1vZGVsLW9wdGlvbnMgc3VwcG9ydFxyXG52YXIgVz1mdW5jdGlvbihhKXtpZihwKGEpKXJldHVybiBhO3ZhciBiPWFuZ3VsYXIuZWxlbWVudChcIjxkaXY+XCIrYStcIjwvZGl2PlwiKTtcclxuLy9jb25zb2xlLmxvZygnZG9tVGVzdC5jaGlsZHJlbigpLmxlbmd0aCgpOicsIGRvbVRlc3QuY2hpbGRyZW4oKS5sZW5ndGgpO1xyXG4vL2NvbnNvbGUubG9nKCdfZW5zdXJlQ29udGVudFdyYXBwZWQnLCBkb21UZXN0LmNoaWxkcmVuKCkpO1xyXG4vL2NvbnNvbGUubG9nKHZhbHVlLCBhdHRycy50YURlZmF1bHRXcmFwKTtcclxuaWYoMD09PWIuY2hpbGRyZW4oKS5sZW5ndGgpXHJcbi8vIGlmIHdlIGhhdmUgYSA8YnI+IGFuZCB0aGUgYXR0cnMudGFEZWZhdWx0V3JhcCBpcyBhIDxwPiB3ZSBuZWVkIHRvIHJlbW92ZSB0aGUgPGJyPlxyXG4vL3ZhbHVlID0gdmFsdWUucmVwbGFjZSgvPGJyPi9pLCAnJyk7XHJcbmE9XCI8XCIrdi50YURlZmF1bHRXcmFwK1wiPlwiK2ErXCI8L1wiK3YudGFEZWZhdWx0V3JhcCtcIj5cIjtlbHNle3ZhciBjLGQ9YlswXS5jaGlsZE5vZGVzLGU9ITE7Zm9yKGM9MDtjPGQubGVuZ3RoJiYhKGU9ZFtjXS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLm1hdGNoKGkpKTtjKyspO2lmKGUpZm9yKGE9XCJcIixjPTA7YzxkLmxlbmd0aDtjKyspe3ZhciBmPWRbY10sZz1mLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XHJcbi8vY29uc29sZS5sb2coJ25vZGUjOicsIGksICduYW1lOicsIG5vZGVOYW1lKTtcclxuaWYoXCIjY29tbWVudFwiPT09ZylhKz1cIjwhLS1cIitmLm5vZGVWYWx1ZStcIi0tPlwiO2Vsc2UgaWYoXCIjdGV4dFwiPT09Zyl7XHJcbi8vIGRldGVybWluZSBpZiB0aGlzIGlzIGFsbCB3aGl0ZXNwYWNlLCBpZiBzbywgd2Ugd2lsbCBsZWF2ZSBpdCBhcyBpdCBpcy5cclxuLy8gb3RoZXJ3aXNlLCB3ZSB3aWxsIHdyYXAgaXQgYXMgaXQgaXNcclxudmFyIGg9Zi50ZXh0Q29udGVudDtcclxuLy8gbm90IHB1cmUgd2hpdGUgc3BhY2Ugc28gd3JhcCBpbiA8cD4uLi48L3A+IG9yIHdoYXRldmVyIGF0dHJzLnRhRGVmYXVsdFdyYXAgaXMgc2V0IHRvLlxyXG5hKz1oLnRyaW0oKT9cIjxcIit2LnRhRGVmYXVsdFdyYXArXCI+XCIraCtcIjwvXCIrdi50YURlZmF1bHRXcmFwK1wiPlwiOmh9ZWxzZSBpZihnLm1hdGNoKGkpKWErPWYub3V0ZXJIVE1MO2Vsc2V7LyogaXN0YW5idWwgaWdub3JlICBuZXh0OiBEb2Vzbid0IHNlZW0gdG8gdHJpZ2dlciBvbiB0ZXN0cyAqL1xyXG52YXIgaj1mLm91dGVySFRNTHx8Zi5ub2RlVmFsdWU7LyogaXN0YW5idWwgaWdub3JlIGVsc2U6IERvZXNuJ3Qgc2VlbSB0byB0cmlnZ2VyIG9uIHRlc3RzLCBpcyB0ZXN0ZWQgdGhvdWdoICovXHJcbmErPVwiXCIhPT1qLnRyaW0oKT9cIjxcIit2LnRhRGVmYXVsdFdyYXArXCI+XCIraitcIjwvXCIrdi50YURlZmF1bHRXcmFwK1wiPlwiOmp9fWVsc2UgYT1cIjxcIit2LnRhRGVmYXVsdFdyYXArXCI+XCIrYStcIjwvXCIrdi50YURlZmF1bHRXcmFwK1wiPlwifVxyXG4vL2NvbnNvbGUubG9nKHZhbHVlKTtcclxucmV0dXJuIGF9O3YudGFQYXN0ZSYmKHo9cSh2LnRhUGFzdGUpKSx1LmFkZENsYXNzKFwidGEtYmluZFwiKTt2YXIgWDtmW1wiJHVuZG9NYW5hZ2VyXCIrKHYuaWR8fFwiXCIpXT1DLiR1bmRvTWFuYWdlcj17X3N0YWNrOltdLF9pbmRleDowLF9tYXg6MWUzLHB1c2g6ZnVuY3Rpb24oYSl7cmV0dXJuXCJ1bmRlZmluZWRcIj09dHlwZW9mIGF8fG51bGw9PT1hfHxcInVuZGVmaW5lZFwiIT10eXBlb2YgdGhpcy5jdXJyZW50KCkmJm51bGwhPT10aGlzLmN1cnJlbnQoKSYmYT09PXRoaXMuY3VycmVudCgpP2E6KHRoaXMuX2luZGV4PHRoaXMuX3N0YWNrLmxlbmd0aC0xJiYodGhpcy5fc3RhY2s9dGhpcy5fc3RhY2suc2xpY2UoMCx0aGlzLl9pbmRleCsxKSksdGhpcy5fc3RhY2sucHVzaChhKSxYJiZjLmNhbmNlbChYKSx0aGlzLl9zdGFjay5sZW5ndGg+dGhpcy5fbWF4JiZ0aGlzLl9zdGFjay5zaGlmdCgpLHRoaXMuX2luZGV4PXRoaXMuX3N0YWNrLmxlbmd0aC0xLGEpfSx1bmRvOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2V0VG9JbmRleCh0aGlzLl9pbmRleC0xKX0scmVkbzpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNldFRvSW5kZXgodGhpcy5faW5kZXgrMSl9LHNldFRvSW5kZXg6ZnVuY3Rpb24oYSl7aWYoIShhPDB8fGE+dGhpcy5fc3RhY2subGVuZ3RoLTEpKXJldHVybiB0aGlzLl9pbmRleD1hLHRoaXMuY3VycmVudCgpfSxjdXJyZW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3N0YWNrW3RoaXMuX2luZGV4XX19O1xyXG4vLyBpbiBoZXJlIHdlIGFyZSB1bmRvaW5nIHRoZSBjb252ZXJ0cyB1c2VkIGVsc2V3aGVyZSB0byBwcmV2ZW50IHRoZSA8ID4gYW5kICYgYmVpbmcgZGlzcGxheWVkIHdoZW4gdGhleSBzaG91bGRuJ3QgaW4gdGhlIGNvZGUuXHJcbnZhciBZLFo9ZnVuY3Rpb24oKXtpZihFKXJldHVybiB1WzBdLmlubmVySFRNTDtpZihGKXJldHVybiB1LnZhbCgpO3Rocm93XCJ0ZXh0QW5ndWxhciBFcnJvcjogYXR0ZW1wdGluZyB0byB1cGRhdGUgbm9uLWVkaXRhYmxlIHRhQmluZFwifSwkPWZ1bmN0aW9uKGEpe1xyXG4vLyBlbWl0IHRoZSBlbGVtZW50LXNlbGVjdCBldmVudCwgcGFzcyB0aGUgZWxlbWVudFxyXG5yZXR1cm4gZi4kZW1pdChcInRhLWVsZW1lbnQtc2VsZWN0XCIsdGhpcyksYS5wcmV2ZW50RGVmYXVsdCgpLCExfSxfPWZbXCJyZUFwcGx5T25TZWxlY3RvckhhbmRsZXJzXCIrKHYuaWR8fFwiXCIpXT1mdW5jdGlvbigpey8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXHJcbkd8fGFuZ3VsYXIuZm9yRWFjaChqLGZ1bmN0aW9uKGEpe1xyXG4vLyBjaGVjayB3ZSBkb24ndCBhcHBseSB0aGUgaGFuZGxlciB0d2ljZVxyXG51LmZpbmQoYSkub2ZmKFwiY2xpY2tcIiwkKS5vbihcImNsaWNrXCIsJCl9KX0sYWE9ZnVuY3Rpb24oYSxiLGMpe0k9Y3x8ITEsXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGImJm51bGwhPT1ifHwoYj1FKSwvLyBpZiBub3QgY29udGVudEVkaXRhYmxlIHRoZW4gdGhlIG5hdGl2ZSB1bmRvL3JlZG8gaXMgZmluZVxyXG5cInVuZGVmaW5lZFwiIT10eXBlb2YgYSYmbnVsbCE9PWF8fChhPVooKSkscChhKT8oXHJcbi8vIHRoaXMgYXZvaWRzIHVzIGZyb20gdHJpcHBpbmcgdGhlIG5nLXByaXN0aW5lIGZsYWcgaWYgd2UgY2xpY2sgaW4gYW5kIG91dCB3aXRoIG91dCB0eXBpbmdcclxuXCJcIiE9PUMuJHZpZXdWYWx1ZSYmQy4kc2V0Vmlld1ZhbHVlKFwiXCIpLGImJlwiXCIhPT1DLiR1bmRvTWFuYWdlci5jdXJyZW50KCkmJkMuJHVuZG9NYW5hZ2VyLnB1c2goXCJcIikpOihfKCksQy4kdmlld1ZhbHVlIT09YSYmKEMuJHNldFZpZXdWYWx1ZShhKSxiJiZDLiR1bmRvTWFuYWdlci5wdXNoKGEpKSksQy4kcmVuZGVyKCl9LGJhPWZ1bmN0aW9uKGEpe3VbMF0uaW5uZXJIVE1MPWF9LGNhPWZbXCIkdW5kb1RhQmluZFwiKyh2LmlkfHxcIlwiKV09ZnVuY3Rpb24oKXsvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZTogY2FuJ3QgcmVhbGx5IHRlc3QgaXQgZHVlIHRvIGFsbCBjaGFuZ2VzIGJlaW5nIGlnbm9yZWQgYXMgd2VsbCBpbiByZWFkb25seSAqL1xyXG5pZighRyYmRSl7dmFyIGE9Qy4kdW5kb01hbmFnZXIudW5kbygpO1widW5kZWZpbmVkXCIhPXR5cGVvZiBhJiZudWxsIT09YSYmKGJhKGEpLGFhKGEsITEpLFkmJmMuY2FuY2VsKFkpLFk9YyhmdW5jdGlvbigpe3VbMF0uZm9jdXMoKSxoLnNldFNlbGVjdGlvblRvRWxlbWVudEVuZCh1WzBdKX0sMSkpfX0sZGE9ZltcIiRyZWRvVGFCaW5kXCIrKHYuaWR8fFwiXCIpXT1mdW5jdGlvbigpey8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlOiBjYW4ndCByZWFsbHkgdGVzdCBpdCBkdWUgdG8gYWxsIGNoYW5nZXMgYmVpbmcgaWdub3JlZCBhcyB3ZWxsIGluIHJlYWRvbmx5ICovXHJcbmlmKCFHJiZFKXt2YXIgYT1DLiR1bmRvTWFuYWdlci5yZWRvKCk7XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGEmJm51bGwhPT1hJiYoYmEoYSksYWEoYSwhMSksLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuWSYmYy5jYW5jZWwoWSksWT1jKGZ1bmN0aW9uKCl7dVswXS5mb2N1cygpLGguc2V0U2VsZWN0aW9uVG9FbGVtZW50RW5kKHVbMF0pfSwxKSl9fTtcclxuLy91c2VkIGZvciB1cGRhdGluZyB3aGVuIGluc2VydGluZyB3cmFwcGVkIGVsZW1lbnRzXHJcbmZbXCJ1cGRhdGVUYUJpbmRcIisodi5pZHx8XCJcIildPWZ1bmN0aW9uKCl7R3x8YWEodm9pZCAwLHZvaWQgMCwhMCl9O1xyXG4vLyBjYXRjaCBET00gWFNTIHZpYSB0YVNhbml0aXplXHJcbi8vIFNhbml0aXppbmcgYm90aCB3YXlzIGlzIGlkZW50aWNhbFxyXG52YXIgZWE9ZnVuY3Rpb24oYSl7cmV0dXJuIEMuJG9sZFZpZXdWYWx1ZT1iKGUoYSksQy4kb2xkVmlld1ZhbHVlLEopfTtcclxuLy90aGlzIGNvZGUgaXMgdXNlZCB0byB1cGRhdGUgdGhlIG1vZGVscyB3aGVuIGRhdGEgaXMgZW50ZXJlZC9kZWxldGVkXHJcbmlmKFxyXG4vLyB0cmlnZ2VyIHRoZSB2YWxpZGF0aW9uIGNhbGxzXHJcbnUuYXR0cihcInJlcXVpcmVkXCIpJiYoQy4kdmFsaWRhdG9ycy5yZXF1aXJlZD1mdW5jdGlvbihhLGIpe3JldHVybiFwKGF8fGIpfSksXHJcbi8vIHBhcnNlcnMgdHJpZ2dlciBmcm9tIHRoZSBhYm92ZSBrZXl1cCBmdW5jdGlvbiBvciBhbnkgb3RoZXIgdGltZSB0aGF0IHRoZSB2aWV3VmFsdWUgaXMgdXBkYXRlZCBhbmQgcGFyc2VzIGl0IGZvciBzdG9yYWdlIGluIHRoZSBuZ01vZGVsXHJcbkMuJHBhcnNlcnMucHVzaChlYSksQy4kcGFyc2Vycy51bnNoaWZ0KFcpLFxyXG4vLyBiZWNhdXNlIHRleHRBbmd1bGFyIGlzIGJpLWRpcmVjdGlvbmFsICh3aGljaCBpcyBhd2Vzb21lKSB3ZSBuZWVkIHRvIGFsc28gc2FuaXRpemUgdmFsdWVzIGdvaW5nIGluIGZyb20gdGhlIHNlcnZlclxyXG5DLiRmb3JtYXR0ZXJzLnB1c2goZWEpLEMuJGZvcm1hdHRlcnMudW5zaGlmdChXKSxDLiRmb3JtYXR0ZXJzLnVuc2hpZnQoZnVuY3Rpb24oYSl7cmV0dXJuIEMuJHVuZG9NYW5hZ2VyLnB1c2goYXx8XCJcIil9KSxGKWlmKGYuZXZlbnRzPXt9LEUpe1xyXG4vLyBhbGwgdGhlIGNvZGUgc3BlY2lmaWMgdG8gY29udGVudGVkaXRhYmxlIGRpdnNcclxudmFyIGZhPSExLGdhPWZ1bmN0aW9uKGEpe3ZhciBkPXZvaWQgMCE9PWEmJmEubWF0Y2goL2NvbnRlbnQ9W1wiJ10qT25lTm90ZS5GaWxlL2kpOy8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlOiBkb24ndCBjYXJlIGlmIG5vdGhpbmcgcGFzdGVkICovXHJcbi8vY29uc29sZS5sb2codGV4dCk7XHJcbmlmKGEmJmEudHJpbSgpLmxlbmd0aCl7XHJcbi8vIHRlc3QgcGFzdGUgZnJvbSB3b3JkL21pY3Jvc29mdCBwcm9kdWN0XHJcbmlmKGEubWF0Y2goL2NsYXNzPVtcIiddKk1zbyhOb3JtYWx8TGlzdCkvaSl8fGEubWF0Y2goL2NvbnRlbnQ9W1wiJ10qV29yZC5Eb2N1bWVudC9pKXx8YS5tYXRjaCgvY29udGVudD1bXCInXSpPbmVOb3RlLkZpbGUvaSkpe3ZhciBlPWEubWF0Y2goLzwhLS1TdGFydEZyYWdtZW50LS0+KFtcXHNcXFNdKj8pPCEtLUVuZEZyYWdtZW50LS0+L2kpO2U9ZT9lWzFdOmEsZT1lLnJlcGxhY2UoLzxvOnA+W1xcc1xcU10qPzxcXC9vOnA+L2dpLFwiXCIpLnJlcGxhY2UoL2NsYXNzPShbXCInXXwpTXNvTm9ybWFsKFtcIiddfCkvZ2ksXCJcIik7dmFyIGc9YW5ndWxhci5lbGVtZW50KFwiPGRpdj5cIitlK1wiPC9kaXY+XCIpLGk9YW5ndWxhci5lbGVtZW50KFwiPGRpdj48L2Rpdj5cIiksaj17ZWxlbWVudDpudWxsLGxhc3RJbmRlbnQ6W10sbGFzdExpOm51bGwsaXNVbDohMX07ai5sYXN0SW5kZW50LnBlZWs9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmxlbmd0aDtpZihhPjApcmV0dXJuIHRoaXNbYS0xXX07Zm9yKHZhciBrPWZ1bmN0aW9uKGEpe2ouaXNVbD1hLGouZWxlbWVudD1hbmd1bGFyLmVsZW1lbnQoYT9cIjx1bD5cIjpcIjxvbD5cIiksai5sYXN0SW5kZW50PVtdLGoubGFzdEluZGVudC5wZWVrPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5sZW5ndGg7aWYoYT4wKXJldHVybiB0aGlzW2EtMV19LGoubGFzdExldmVsTWF0Y2g9bnVsbH0sbD0wO2w8PWdbMF0uY2hpbGROb2Rlcy5sZW5ndGg7bCsrKWlmKGdbMF0uY2hpbGROb2Rlc1tsXSYmXCIjdGV4dFwiIT09Z1swXS5jaGlsZE5vZGVzW2xdLm5vZGVOYW1lKXt2YXIgbT1nWzBdLmNoaWxkTm9kZXNbbF0udGFnTmFtZS50b0xvd2VyQ2FzZSgpO2lmKFwicFwiPT09bXx8XCJoMVwiPT09bXx8XCJoMlwiPT09bXx8XCJoM1wiPT09bXx8XCJoNFwiPT09bXx8XCJoNVwiPT09bXx8XCJoNlwiPT09bSl7dmFyIG49YW5ndWxhci5lbGVtZW50KGdbMF0uY2hpbGROb2Rlc1tsXSksbz0obi5hdHRyKFwiY2xhc3NcIil8fFwiXCIpLm1hdGNoKC9Nc29MaXN0KEJ1bGxldHxOdW1iZXJ8UGFyYWdyYXBoKShDeFNwKEZpcnN0fE1pZGRsZXxMYXN0KXwpL2kpO2lmKG8pe2lmKG5bMF0uY2hpbGROb2Rlcy5sZW5ndGg8Mnx8blswXS5jaGlsZE5vZGVzWzFdLmNoaWxkTm9kZXMubGVuZ3RoPDEpY29udGludWU7dmFyIHA9XCJidWxsZXRcIj09PW9bMV0udG9Mb3dlckNhc2UoKXx8XCJudW1iZXJcIiE9PW9bMV0udG9Mb3dlckNhc2UoKSYmISgvXlteMC05YS16PF0qWzAtOWEtel0rW14wLTlhLXo8Pl08L2kudGVzdChuWzBdLmNoaWxkTm9kZXNbMV0uaW5uZXJIVE1MKXx8L15bXjAtOWEtejxdKlswLTlhLXpdK1teMC05YS16PD5dPC9pLnRlc3QoblswXS5jaGlsZE5vZGVzWzFdLmNoaWxkTm9kZXNbMF0uaW5uZXJIVE1MKSkscT0obi5hdHRyKFwic3R5bGVcIil8fFwiXCIpLm1hdGNoKC9tYXJnaW4tbGVmdDooW1xcLVxcLjAtOV0qKS9pKSxzPXBhcnNlRmxvYXQocT9xWzFdOjApLHQ9KG4uYXR0cihcInN0eWxlXCIpfHxcIlwiKS5tYXRjaCgvbXNvLWxpc3Q6bChbMC05XSspIGxldmVsKFswLTldKykgbGZvWzAtOStdKCR8OykvaSk7aWYoXHJcbi8vIHByZWZlcnMgdGhlIG1zby1saXN0IHN5bnRheFxyXG50JiZ0WzJdJiYocz1wYXJzZUludCh0WzJdKSksdCYmKCFqLmxhc3RMZXZlbE1hdGNofHx0WzFdIT09ai5sYXN0TGV2ZWxNYXRjaFsxXSl8fCFvWzNdfHxcImZpcnN0XCI9PT1vWzNdLnRvTG93ZXJDYXNlKCl8fG51bGw9PT1qLmxhc3RJbmRlbnQucGVlaygpfHxqLmlzVWwhPT1wJiZqLmxhc3RJbmRlbnQucGVlaygpPT09cylrKHApLGkuYXBwZW5kKGouZWxlbWVudCk7ZWxzZSBpZihudWxsIT1qLmxhc3RJbmRlbnQucGVlaygpJiZqLmxhc3RJbmRlbnQucGVlaygpPHMpai5lbGVtZW50PWFuZ3VsYXIuZWxlbWVudChwP1wiPHVsPlwiOlwiPG9sPlwiKSxqLmxhc3RMaS5hcHBlbmQoai5lbGVtZW50KTtlbHNlIGlmKG51bGwhPWoubGFzdEluZGVudC5wZWVrKCkmJmoubGFzdEluZGVudC5wZWVrKCk+cyl7Zm9yKDtudWxsIT1qLmxhc3RJbmRlbnQucGVlaygpJiZqLmxhc3RJbmRlbnQucGVlaygpPnM7KWlmKFwibGlcIiE9PWouZWxlbWVudC5wYXJlbnQoKVswXS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpe2lmKCEvW3VvXWwvaS50ZXN0KGouZWxlbWVudC5wYXJlbnQoKVswXS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpKS8vIGVsc2UgaXQncyBpdCBzaG91bGQgYmUgYSBzaWJsaW5nXHJcbmJyZWFrO2ouZWxlbWVudD1qLmVsZW1lbnQucGFyZW50KCksai5sYXN0SW5kZW50LnBvcCgpfWVsc2Ugai5lbGVtZW50PWouZWxlbWVudC5wYXJlbnQoKTtqLmlzVWw9XCJ1bFwiPT09ai5lbGVtZW50WzBdLnRhZ05hbWUudG9Mb3dlckNhc2UoKSxwIT09ai5pc1VsJiYoayhwKSxpLmFwcGVuZChqLmVsZW1lbnQpKX1qLmxhc3RMZXZlbE1hdGNoPXQscyE9PWoubGFzdEluZGVudC5wZWVrKCkmJmoubGFzdEluZGVudC5wdXNoKHMpLGoubGFzdExpPWFuZ3VsYXIuZWxlbWVudChcIjxsaT5cIiksai5lbGVtZW50LmFwcGVuZChqLmxhc3RMaSksai5sYXN0TGkuaHRtbChuLmh0bWwoKS5yZXBsYWNlKC88ISgtLXwpXFxbaWYgIXN1cHBvcnRMaXN0c1xcXSgtLXwpPltcXHNcXFNdKj88ISgtLXwpXFxbZW5kaWZcXF0oLS18KT4vZ2ksXCJcIikpLG4ucmVtb3ZlKCl9ZWxzZSBrKCExKSxpLmFwcGVuZChuKX19dmFyIHY9ZnVuY3Rpb24oYSl7YT1hbmd1bGFyLmVsZW1lbnQoYSk7Zm9yKHZhciBiPWFbMF0uY2hpbGROb2Rlcy5sZW5ndGgtMTtiPj0wO2ItLSlhLmFmdGVyKGFbMF0uY2hpbGROb2Rlc1tiXSk7YS5yZW1vdmUoKX07YW5ndWxhci5mb3JFYWNoKGkuZmluZChcInNwYW5cIiksZnVuY3Rpb24oYSl7YS5yZW1vdmVBdHRyaWJ1dGUoXCJsYW5nXCIpLGEuYXR0cmlidXRlcy5sZW5ndGg8PTAmJnYoYSl9KSxhbmd1bGFyLmZvckVhY2goaS5maW5kKFwiZm9udFwiKSx2KSxhPWkuaHRtbCgpLGQmJihhPWkuaHRtbCgpfHxnLmh0bWwoKSksXHJcbi8vIExGIGNoYXJhY3RlcnMgaW5zdGVhZCBvZiBzcGFjZXMgaW4gc29tZSBzcG90cyBhbmQgdGhleSBhcmUgcmVwbGFjZWQgYnkgXCIvblwiLCBzbyB3ZSBuZWVkIHRvIGp1c3Qgc3dhcCB0aGVtIHRvIHNwYWNlc1xyXG5hPWEucmVwbGFjZSgvXFxuL2csXCIgXCIpfWVsc2V7aWYoXHJcbi8vIHJlbW92ZSB1bm5lY2Vzc2FyeSBjaHJvbWUgaW5zZXJ0XHJcbmE9YS5yZXBsYWNlKC88KHxcXC8pbWV0YVtePl0qPz4vZ2ksXCJcIiksYS5tYXRjaCgvPFtePl0qPyh0YS1iaW5kKVtePl0qPz4vKSl7XHJcbi8vIGVudGlyZSB0ZXh0LWFuZ3VsYXIgb3IgdGEtYmluZCBoYXMgYmVlbiBwYXN0ZWQsIFJFTU9WRSBBVCBPTkNFISFcclxuaWYoYS5tYXRjaCgvPFtePl0qPyh0ZXh0LWFuZ3VsYXIpW14+XSo/Pi8pKXt2YXIgdz1hbmd1bGFyLmVsZW1lbnQoXCI8ZGl2PlwiK2ErXCI8L2Rpdj5cIik7dy5maW5kKFwidGV4dGFyZWFcIikucmVtb3ZlKCk7Zm9yKHZhciB4PXIuZ2V0QnlBdHRyaWJ1dGUodyxcInRhLWJpbmRcIikseT0wO3k8eC5sZW5ndGg7eSsrKXtmb3IodmFyIEE9eFt5XVswXS5wYXJlbnROb2RlLnBhcmVudE5vZGUsQj0wO0I8eFt5XVswXS5jaGlsZE5vZGVzLmxlbmd0aDtCKyspQS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh4W3ldWzBdLmNoaWxkTm9kZXNbQl0sQSk7QS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKEEpfWE9dy5odG1sKCkucmVwbGFjZSgnPGJyIGNsYXNzPVwiQXBwbGUtaW50ZXJjaGFuZ2UtbmV3bGluZVwiPicsXCJcIil9fWVsc2UgYS5tYXRjaCgvXjxzcGFuLykmJihcclxuLy8gaW4gY2FzZSBvZiBwYXN0aW5nIG9ubHkgYSBzcGFuIC0gY2hyb21lIHBhc3RlLCByZW1vdmUgdGhlbS4gVEhpcyBpcyBqdXN0IHNvbWUgd2llcmQgZm9ybWF0dGluZ1xyXG4vLyBpZiB3ZSByZW1vdmUgdGhlICc8c3BhbiBjbGFzcz1cIkFwcGxlLWNvbnZlcnRlZC1zcGFjZVwiPsKgPC9zcGFuPicgaGVyZSB3ZSBkZXN0cm95IHRoZSBzcGFjaW5nXHJcbi8vIG9uIHBhc3RlIGZyb20gZXZlbiBvdXJzZWx2ZXMhXHJcbmEubWF0Y2goLzxzcGFuIGNsYXNzPShcXFwiQXBwbGUtY29udmVydGVkLXNwYWNlXFxcInxcXCdBcHBsZS1jb252ZXJ0ZWQtc3BhY2VcXCcpPi48XFwvc3Bhbj4vZ2kpfHwoYT1hLnJlcGxhY2UoLzwofFxcLylzcGFuW14+XSo/Pi9naSxcIlwiKSkpO1xyXG4vLyBXZWJraXQgb24gQXBwbGUgdGFnc1xyXG5hPWEucmVwbGFjZSgvPGJyIGNsYXNzPVwiQXBwbGUtaW50ZXJjaGFuZ2UtbmV3bGluZVwiW14+XSo/Pi9naSxcIlwiKS5yZXBsYWNlKC88c3BhbiBjbGFzcz1cIkFwcGxlLWNvbnZlcnRlZC1zcGFjZVwiPiggfCZuYnNwOyk8XFwvc3Bhbj4vZ2ksXCImbmJzcDtcIil9LzxsaShcXHMuKik/Pi9pLnRlc3QoYSkmJi8oPHVsKFxccy4qKT8+fDxvbChcXHMuKik/PikuKjxsaShcXHMuKik/Pi9pLnRlc3QoYSk9PT0hMSYmKFxyXG4vLyBpbnNlcnQgbWlzc2luZyBwYXJlbnQgb2YgbGkgZWxlbWVudFxyXG5hPWEucmVwbGFjZSgvPGxpKFxccy4qKT8+Lio8XFwvbGkoXFxzLiopPz4vaSxcIjx1bD4kJjwvdWw+XCIpKSxcclxuLy8gcGFyc2Ugd2hpdGVzcGFjZSBmcm9tIHBsYWludGV4dCBpbnB1dCwgc3RhcnRpbmcgd2l0aCBwcmVjZWRpbmcgc3BhY2VzIHRoYXQgZ2V0IHN0cmlwcGVkIG9uIHBhc3RlXHJcbmE9YS5yZXBsYWNlKC9eWyB8XFx1MDBBMF0rL2dtLGZ1bmN0aW9uKGEpe2Zvcih2YXIgYj1cIlwiLGM9MDtjPGEubGVuZ3RoO2MrKyliKz1cIiZuYnNwO1wiO3JldHVybiBifSkucmVwbGFjZSgvXFxufFxcclxcbnxcXHIvZyxcIjxiciAvPlwiKS5yZXBsYWNlKC9cXHQvZyxcIiZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwO1wiKSx6JiYoYT16KGYseyRodG1sOmF9KXx8YSksYT1iKGEsXCJcIixKKSxoLmluc2VydEh0bWwoYSx1WzBdKSxjKGZ1bmN0aW9uKCl7Qy4kc2V0Vmlld1ZhbHVlKFooKSksZmE9ITEsdS5yZW1vdmVDbGFzcyhcInByb2Nlc3NpbmctcGFzdGVcIil9LDApfWVsc2UgZmE9ITEsdS5yZW1vdmVDbGFzcyhcInByb2Nlc3NpbmctcGFzdGVcIil9O3Uub24oXCJwYXN0ZVwiLGYuZXZlbnRzLnBhc3RlPWZ1bmN0aW9uKGIsZSl7aWYoLyogaXN0YW5idWwgaWdub3JlIGVsc2U6IHRoaXMgaXMgZm9yIGNhdGNoaW5nIHRoZSBqcUxpdGUgdGVzdGluZyovXHJcbmUmJmFuZ3VsYXIuZXh0ZW5kKGIsZSksR3x8ZmEpcmV0dXJuIGIuc3RvcFByb3BhZ2F0aW9uKCksYi5wcmV2ZW50RGVmYXVsdCgpLCExO1xyXG4vLyBDb2RlIGFkYXB0ZWQgZnJvbSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzIxNzY4NjEvamF2YXNjcmlwdC1nZXQtY2xpcGJvYXJkLWRhdGEtb24tcGFzdGUtZXZlbnQtY3Jvc3MtYnJvd3Nlci82ODA0NzE4IzY4MDQ3MThcclxuZmE9ITAsdS5hZGRDbGFzcyhcInByb2Nlc3NpbmctcGFzdGVcIik7dmFyIGYsZz0oYi5vcmlnaW5hbEV2ZW50fHxiKS5jbGlwYm9hcmREYXRhO2lmKGcmJmcuZ2V0RGF0YSYmZy50eXBlcy5sZW5ndGg+MCl7Zm9yKHZhciBoPVwiXCIsaT0wO2k8Zy50eXBlcy5sZW5ndGg7aSsrKWgrPVwiIFwiK2cudHlwZXNbaV07LyogaXN0YW5idWwgaWdub3JlIG5leHQ6IGJyb3dzZXIgdGVzdHMgKi9cclxucmV0dXJuL3RleHRcXC9odG1sL2kudGVzdChoKT9mPWcuZ2V0RGF0YShcInRleHQvaHRtbFwiKTovdGV4dFxcL3BsYWluL2kudGVzdChoKSYmKGY9Zy5nZXREYXRhKFwidGV4dC9wbGFpblwiKSksZ2EoZiksYi5zdG9wUHJvcGFnYXRpb24oKSxiLnByZXZlbnREZWZhdWx0KCksITF9Ly8gRXZlcnl0aGluZyBlbHNlIC0gZW1wdHkgZWRpdGRpdiBhbmQgYWxsb3cgYnJvd3NlciB0byBwYXN0ZSBjb250ZW50IGludG8gaXQsIHRoZW4gY2xlYW51cFxyXG52YXIgaj1hLnNhdmVTZWxlY3Rpb24oKSxrPWFuZ3VsYXIuZWxlbWVudCgnPGRpdiBjbGFzcz1cInRhLWhpZGRlbi1pbnB1dFwiIGNvbnRlbnRlZGl0YWJsZT1cInRydWVcIj48L2Rpdj4nKTtkLmZpbmQoXCJib2R5XCIpLmFwcGVuZChrKSxrWzBdLmZvY3VzKCksYyhmdW5jdGlvbigpe1xyXG4vLyByZXN0b3JlIHNlbGVjdGlvblxyXG5hLnJlc3RvcmVTZWxlY3Rpb24oaiksZ2Eoa1swXS5pbm5lckhUTUwpLHVbMF0uZm9jdXMoKSxrLnJlbW92ZSgpfSwwKX0pLHUub24oXCJjdXRcIixmLmV2ZW50cy5jdXQ9ZnVuY3Rpb24oYSl7XHJcbi8vIHRpbWVvdXQgdG8gbmV4dCBpcyBuZWVkZWQgYXMgb3RoZXJ3aXNlIHRoZSBwYXN0ZS9jdXQgZXZlbnQgaGFzIG5vdCBmaW5pc2hlZCBhY3R1YWxseSBjaGFuZ2luZyB0aGUgZGlzcGxheVxyXG5HP2EucHJldmVudERlZmF1bHQoKTpjKGZ1bmN0aW9uKCl7Qy4kc2V0Vmlld1ZhbHVlKFooKSl9LDApfSksdS5vbihcImtleWRvd25cIixmLmV2ZW50cy5rZXlkb3duPWZ1bmN0aW9uKGEsYil7LyogaXN0YW5idWwgaWdub3JlIGVsc2U6IHRoaXMgaXMgZm9yIGNhdGNoaW5nIHRoZSBqcUxpdGUgdGVzdGluZyovXHJcbmImJmFuZ3VsYXIuZXh0ZW5kKGEsYiksYS5rZXlDb2RlPT09Uj9oLnNldFN0YXRlU2hpZnRLZXkoITApOmguc2V0U3RhdGVTaGlmdEtleSghMSksYS5zcGVjaWFsS2V5PXgoYSk7dmFyIGM7LyogaXN0YW5idWwgaWdub3JlIGVsc2U6IHJlYWRvbmx5IGNoZWNrICovXHJcbmlmKC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBkaWZmaWN1bHQgdG8gdGVzdCAqL1xyXG5vLmtleU1hcHBpbmdzLmZvckVhY2goZnVuY3Rpb24oYil7YS5zcGVjaWFsS2V5PT09Yi5jb21tYW5kS2V5Q29kZSYmKFxyXG4vLyB0YU9wdGlvbnMgaGFzIHJlbWFwcGVkIHRoaXMgYmluZGluZy4uLiBzb1xyXG4vLyB3ZSBkaXNhYmxlIG91ciBvd25cclxuYS5zcGVjaWFsS2V5PXZvaWQgMCksYi50ZXN0Rm9yS2V5KGEpJiYoYz1iLmNvbW1hbmRLZXlDb2RlKSxcIlVuZG9LZXlcIiE9PWIuY29tbWFuZEtleUNvZGUmJlwiUmVkb0tleVwiIT09Yi5jb21tYW5kS2V5Q29kZXx8Yi5lbmFibGVQcm9wYWdhdGlvbnx8YS5wcmV2ZW50RGVmYXVsdCgpfSksLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IGRpZmZpY3VsdCB0byB0ZXN0ICovXHJcblwidW5kZWZpbmVkXCIhPXR5cGVvZiBjJiYoYS5zcGVjaWFsS2V5PWMpLC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBkaWZmaWN1bHQgdG8gdGVzdCBhcyBjYW4ndCBzZWVtIHRvIHNlbGVjdCAqL1xyXG5cInVuZGVmaW5lZFwiPT10eXBlb2YgYS5zcGVjaWFsS2V5fHxcIlVuZG9LZXlcIj09PWEuc3BlY2lhbEtleSYmXCJSZWRvS2V5XCI9PT1hLnNwZWNpYWxLZXl8fChhLnByZXZlbnREZWZhdWx0KCkscy5zZW5kS2V5Q29tbWFuZChmLGEpKSwhKEd8fChcIlVuZG9LZXlcIj09PWEuc3BlY2lhbEtleSYmKGNhKCksYS5wcmV2ZW50RGVmYXVsdCgpKSxcIlJlZG9LZXlcIj09PWEuc3BlY2lhbEtleSYmKGRhKCksYS5wcmV2ZW50RGVmYXVsdCgpKSxhLmtleUNvZGUhPT1RfHxhLnNoaWZ0S2V5fHxhLmN0cmxLZXl8fGEubWV0YUtleXx8YS5hbHRLZXkpKSl7dmFyIGQsZT1mdW5jdGlvbihhLGIpe2Zvcih2YXIgYz0wO2M8YS5sZW5ndGg7YysrKWlmKGFbY109PT1iKXJldHVybiEwO3JldHVybiExfSxnPWguZ2V0U2VsZWN0aW9uRWxlbWVudCgpO1xyXG4vLyBzaGlmdGVkIHRvIG5vZGVOYW1lIGhlcmUgZnJvbSB0YWdOYW1lIHNpbmNlIGl0IGlzIG1vcmUgd2lkZWx5IHN1cHBvcnRlZCBzZWU6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDg3ODQ4NC9kaWZmZXJlbmNlLWJldHdlZW4tdGFnbmFtZS1hbmQtbm9kZW5hbWVcclxuaWYoIWcubm9kZU5hbWUubWF0Y2goaykpcmV0dXJuO3ZhciBpPWFuZ3VsYXIuZWxlbWVudChBKSxqPVtcImJsb2NrcXVvdGVcIixcInVsXCIsXCJvbFwiXTtpZihlKGosZy5wYXJlbnROb2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSkpe2lmKC9ePGJyKHxcXC8pPiQvaS50ZXN0KGcuaW5uZXJIVE1MLnRyaW0oKSkmJiFnLm5leHRTaWJsaW5nKXtcclxuLy8gaWYgbGFzdCBlbGVtZW50IGlzIGJsYW5rLCBwdWxsIGVsZW1lbnQgb3V0c2lkZS5cclxuZD1hbmd1bGFyLmVsZW1lbnQoZyk7dmFyIGw9ZC5wYXJlbnQoKTtsLmFmdGVyKGkpLGQucmVtb3ZlKCksMD09PWwuY2hpbGRyZW4oKS5sZW5ndGgmJmwucmVtb3ZlKCksaC5zZXRTZWxlY3Rpb25Ub0VsZW1lbnRTdGFydChpWzBdKSxhLnByZXZlbnREZWZhdWx0KCl9L148W14+XSs+PGJyKHxcXC8pPjxcXC9bXj5dKz4kL2kudGVzdChnLmlubmVySFRNTC50cmltKCkpJiYoZD1hbmd1bGFyLmVsZW1lbnQoZyksZC5hZnRlcihpKSxkLnJlbW92ZSgpLGguc2V0U2VsZWN0aW9uVG9FbGVtZW50U3RhcnQoaVswXSksYS5wcmV2ZW50RGVmYXVsdCgpKX19fSk7dmFyIGhhO3Uub24oXCJrZXl1cFwiLGYuZXZlbnRzLmtleXVwPWZ1bmN0aW9uKGEsYil7Ly8gY2xlYXIgdGhlIFNoaWZ0S2V5IHN0YXRlXHJcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBGRiBzcGVjaWZpYyBidWcgZml4ICovXHJcbmlmKC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlOiB0aGlzIGlzIGZvciBjYXRjaGluZyB0aGUganFMaXRlIHRlc3RpbmcqL1xyXG5iJiZhbmd1bGFyLmV4dGVuZChhLGIpLGguc2V0U3RhdGVTaGlmdEtleSghMSksYS5rZXlDb2RlPT09Uyl7dmFyIGQ9aC5nZXRTZWxlY3Rpb24oKTtyZXR1cm4gdm9pZChkLnN0YXJ0LmVsZW1lbnQ9PT11WzBdJiZ1LmNoaWxkcmVuKCkubGVuZ3RoJiZoLnNldFNlbGVjdGlvblRvRWxlbWVudFN0YXJ0KHUuY2hpbGRyZW4oKVswXSkpfWlmKFxyXG4vLyB3ZSBkbyB0aGlzIGhlcmUgZHVyaW5nIHRoZSAna2V5dXAnIHNvIHRoYXQgdGhlIGJyb3dzZXIgaGFzIGFscmVhZHkgbW92ZWQgdGhlIHNsZWN0aW9uIGJ5IG9uZSBjaGFyYWN0ZXIuLi5cclxuYS5rZXlDb2RlIT09VHx8YS5zaGlmdEtleXx8aC51cGRhdGVMZWZ0QXJyb3dLZXkodSksXHJcbi8vIHdlIGRvIHRoaXMgaGVyZSBkdXJpbmcgdGhlICdrZXl1cCcgc28gdGhhdCB0aGUgYnJvd3NlciBoYXMgYWxyZWFkeSBtb3ZlZCB0aGUgc2xlY3Rpb24gYnkgb25lIGNoYXJhY3Rlci4uLlxyXG5hLmtleUNvZGUhPT1VfHxhLnNoaWZ0S2V5fHxoLnVwZGF0ZVJpZ2h0QXJyb3dLZXkodSksWCYmYy5jYW5jZWwoWCksIUcmJiFLLnRlc3QoYS5rZXlDb2RlKSkvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogSWdub3JlIGFueSBfRU5URVJfS0VZQ09ERSB0aGF0IGhhcyBjdHJsS2V5LCBtZXRhS2V5IG9yIGFsS2V5ICovXHJcbmlmKGEua2V5Q29kZT09PVEmJihhLmN0cmxLZXl8fGEubWV0YUtleXx8YS5hbHRLZXkpKTtlbHNle1xyXG4vLyBpZiBlbnRlciAtIGluc2VydCBuZXcgdGFEZWZhdWx0V3JhcCwgaWYgc2hpZnQrZW50ZXIgaW5zZXJ0IDxici8+XHJcbmlmKCEoXCJcIj09PUF8fFwiPEJSPjxCUj5cIj09PUF8fGEua2V5Q29kZSE9PVF8fGEuY3RybEtleXx8YS5tZXRhS2V5fHxhLmFsdEtleXx8YS5zaGlmdEtleSkpe1xyXG4vLyBzaGlmdGVkIHRvIG5vZGVOYW1lIGhlcmUgZnJvbSB0YWdOYW1lIHNpbmNlIGl0IGlzIG1vcmUgd2lkZWx5IHN1cHBvcnRlZCBzZWU6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDg3ODQ4NC9kaWZmZXJlbmNlLWJldHdlZW4tdGFnbmFtZS1hbmQtbm9kZW5hbWVcclxuZm9yKFxyXG4vLyBuZXcgcGFyYWdyYXBoLCBiciBzaG91bGQgYmUgY2F1Z2h0IGNvcnJlY3RseVxyXG52YXIgZT1oLmdldFNlbGVjdGlvbkVsZW1lbnQoKTshZS5ub2RlTmFtZS5tYXRjaChrKSYmZSE9PXVbMF07KWU9ZS5wYXJlbnROb2RlO2lmKGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpIT09di50YURlZmF1bHRXcmFwJiZcImxpXCIhPT1lLnRhZ05hbWUudG9Mb3dlckNhc2UoKSYmKFwiXCI9PT1lLmlubmVySFRNTC50cmltKCl8fFwiPGJyPlwiPT09ZS5pbm5lckhUTUwudHJpbSgpKSl7XHJcbi8vIENocm9tZSBzdGFydHMgd2l0aCBhIDxkaXY+PGJyPjwvZGl2PiBhZnRlciBhbiBFbnRlcktleVxyXG4vLyBzbyB3ZSByZXBsYWNlIHRoaXMgd2l0aCB0aGUgX2RlZmF1bHRWYWxcclxudmFyIGY9YW5ndWxhci5lbGVtZW50KEEpO2FuZ3VsYXIuZWxlbWVudChlKS5yZXBsYWNlV2l0aChmKSxoLnNldFNlbGVjdGlvblRvRWxlbWVudFN0YXJ0KGZbMF0pfX12YXIgZz1aKCk7XCJcIj09PUF8fFwiXCIhPT1nLnRyaW0oKSYmXCI8YnI+XCIhPT1nLnRyaW0oKT9cIjxcIiE9PWcuc3Vic3RyaW5nKDAsMSkmJlwiXCIhPT12LnRhRGVmYXVsdFdyYXA6KGJhKEEpLGguc2V0U2VsZWN0aW9uVG9FbGVtZW50U3RhcnQodS5jaGlsZHJlbigpWzBdKSk7dmFyIGk9eSE9PWEua2V5Q29kZSYmTC50ZXN0KGEua2V5Q29kZSk7aGEmJmMuY2FuY2VsKGhhKSxoYT1jKGZ1bmN0aW9uKCl7YWEoZyxpLCEwKX0sRC4kb3B0aW9ucy5kZWJvdW5jZXx8NDAwKSxpfHwoWD1jKGZ1bmN0aW9uKCl7Qy4kdW5kb01hbmFnZXIucHVzaChnKX0sMjUwKSkseT1hLmtleUNvZGV9fSk7XHJcbi8vIHdoZW4gdGhlcmUgaXMgYSBjaGFuZ2UgZnJvbSBhIHNwZWxsaW5nIGNvcnJlY3Rpb24gaW4gdGhlIGJyb3dzZXIsIHRoZSBvbmx5XHJcbi8vIGNoYW5nZSB0aGF0IGlzIHNlZW4gaXMgYSAnaW5wdXQnIGFuZCB0aGUgJHdhdGNoKCdodG1sJykgc2VlcyBub3RoaW5nLi4uIFNvXHJcbi8vIHdlIGFkZGVkIHRoaXMgZWxlbWVudC5vbignaW5wdXQnKSB0byBjYXRjaCB0aGlzIGNoYW5nZSBhbmQgY2FsbCB0aGUgX3NldFZpZXdWYWx1ZSgpXHJcbi8vIHNvIHRoZSBuZ01vZGVsIGlzIHVwZGF0ZWQgYW5kIGFsbCB3b3JrcyBhcyBpdCBzaG91bGQuXHJcbnZhciBpYTtcclxuLy8gUGxhY2Vob2xkZXJzIG5vdCBzdXBwb3J0ZWQgb24gaWUgOCBhbmQgYmVsb3dcclxuaWYodS5vbihcImlucHV0XCIsZnVuY3Rpb24oKXtaKCkhPT1DLiR2aWV3VmFsdWUmJihcclxuLy8gd2Ugd2FpdCBhIHRpbWUgbm93IHRvIGFsbG93IHRoZSBuYXR1cmFsICR3YXRjaCgnaHRtbCcpIHRvIGhhbmRsZSB0aGlzIGNoYW5nZVxyXG4vLyBhbmQgdGhlbiBhZnRlciBhIDEgc2Vjb25kIGRlbGF5LCBpZiB0aGVyZSBpcyBzdGlsbCBhIGRpZmZlcmVuY2Ugd2Ugd2lsbCBkbyB0aGVcclxuLy8gX3NldFZpZXdWYWx1ZSgpIGNhbGwuXHJcbi8qIGlzdGFuYnVsIGlnbm9yZSBpZjogY2FuJ3QgdGVzdCAqL1xyXG5pYSYmYy5jYW5jZWwoaWEpLC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBjYW50JyB0ZXN0PyAqL1xyXG5pYT1jKGZ1bmN0aW9uKCl7dmFyIGE9WigpO2EhPT1DLiR2aWV3VmFsdWUmJlxyXG4vL2NvbnNvbGUubG9nKCdfc2V0Vmlld1ZhbHVlJyk7XHJcbi8vY29uc29sZS5sb2coJ29sZDonLCBuZ01vZGVsLiR2aWV3VmFsdWUpO1xyXG4vL2NvbnNvbGUubG9nKCduZXc6JywgX3ZhbCk7XHJcbmFhKGEsITApfSwxZTMpKX0pLHUub24oXCJibHVyXCIsZi5ldmVudHMuYmx1cj1mdW5jdGlvbigpe0g9ITEsLyogaXN0YW5idWwgaWdub3JlIGVsc2U6IGlmIHJlYWRvbmx5IGRvbid0IHVwZGF0ZSBtb2RlbCAqL1xyXG5HPyhJPSEwLC8vIGRvbid0IHJlZG8gdGhlIHdob2xlIHRoaW5nLCBqdXN0IGNoZWNrIHRoZSBwbGFjZWhvbGRlciBsb2dpY1xyXG5DLiRyZW5kZXIoKSk6YWEodm9pZCAwLHZvaWQgMCwhMCl9KSx2LnBsYWNlaG9sZGVyJiYoZy5pZT44fHx2b2lkIDA9PT1nLmllKSl7dmFyIGphO2lmKCF2LmlkKXRocm93XCJ0ZXh0QW5ndWxhciBFcnJvcjogQW4gdW5pcXVlIElEIGlzIHJlcXVpcmVkIGZvciBwbGFjZWhvbGRlcnMgdG8gd29ya1wiO2phPW0oXCIjXCIrdi5pZCtcIi5wbGFjZWhvbGRlci10ZXh0OmJlZm9yZVwiLCdjb250ZW50OiBcIicrdi5wbGFjZWhvbGRlcisnXCInKSxmLiRvbihcIiRkZXN0cm95XCIsZnVuY3Rpb24oKXtuKGphKX0pfXUub24oXCJmb2N1c1wiLGYuZXZlbnRzLmZvY3VzPWZ1bmN0aW9uKCl7SD0hMCx1LnJlbW92ZUNsYXNzKFwicGxhY2Vob2xkZXItdGV4dFwiKSxfKCl9KSx1Lm9uKFwibW91c2V1cFwiLGYuZXZlbnRzLm1vdXNldXA9ZnVuY3Rpb24oKXt2YXIgYT1oLmdldFNlbGVjdGlvbigpO2EmJmEuc3RhcnQuZWxlbWVudD09PXVbMF0mJnUuY2hpbGRyZW4oKS5sZW5ndGgmJmguc2V0U2VsZWN0aW9uVG9FbGVtZW50U3RhcnQodS5jaGlsZHJlbigpWzBdKX0pLFxyXG4vLyBwcmV2ZW50IHByb3BhZ2F0aW9uIG9uIG1vdXNlZG93biBpbiBlZGl0b3IsIHNlZSAjMjA2XHJcbnUub24oXCJtb3VzZWRvd25cIixmLmV2ZW50cy5tb3VzZWRvd249ZnVuY3Rpb24oYSxiKXsvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZTogdGhpcyBpcyBmb3IgY2F0Y2hpbmcgdGhlIGpxTGl0ZSB0ZXN0aW5nKi9cclxuYiYmYW5ndWxhci5leHRlbmQoYSxiKSxhLnN0b3BQcm9wYWdhdGlvbigpfSl9ZWxzZXtcclxuLy8gaWYgYSB0ZXh0YXJlYSBvciBpbnB1dCBqdXN0IGFkZCBpbiBjaGFuZ2UgYW5kIGJsdXIgaGFuZGxlcnMsIGV2ZXJ5dGhpbmcgZWxzZSBpcyBkb25lIGJ5IGFuZ3VsYXJzIGlucHV0IGRpcmVjdGl2ZVxyXG51Lm9uKFwiY2hhbmdlIGJsdXJcIixmLmV2ZW50cy5jaGFuZ2U9Zi5ldmVudHMuYmx1cj1mdW5jdGlvbigpe0d8fEMuJHNldFZpZXdWYWx1ZShaKCkpfSksdS5vbihcImtleWRvd25cIixmLmV2ZW50cy5rZXlkb3duPWZ1bmN0aW9uKGEsYil7XHJcbi8vIFJlZmVyZW5jZSB0byBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzYxNDA2MzIvaG93LXRvLWhhbmRsZS10YWItaW4tdGV4dGFyZWFcclxuLyogaXN0YW5idWwgaWdub3JlIGVsc2U6IG90aGVyd2lzZSBub3JtYWwgZnVuY3Rpb25hbGl0eSAqL1xyXG5pZigvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZTogdGhpcyBpcyBmb3IgY2F0Y2hpbmcgdGhlIGpxTGl0ZSB0ZXN0aW5nKi9cclxuYiYmYW5ndWxhci5leHRlbmQoYSxiKSxhLmtleUNvZGU9PT1TKXsvLyB0YWIgd2FzIHByZXNzZWRcclxuLy8gZ2V0IGNhcmV0IHBvc2l0aW9uL3NlbGVjdGlvblxyXG52YXIgYz10aGlzLnNlbGVjdGlvblN0YXJ0LGQ9dGhpcy5zZWxlY3Rpb25FbmQsZT11LnZhbCgpO2lmKGEuc2hpZnRLZXkpe1xyXG4vLyBmaW5kIFxcdFxyXG52YXIgZj1lLmxhc3RJbmRleE9mKFwiXFxuXCIsYyksZz1lLmxhc3RJbmRleE9mKFwiXFx0XCIsYyk7ZyE9PS0xJiZnPj1mJiYoXHJcbi8vIHNldCB0ZXh0YXJlYSB2YWx1ZSB0bzogdGV4dCBiZWZvcmUgY2FyZXQgKyB0YWIgKyB0ZXh0IGFmdGVyIGNhcmV0XHJcbnUudmFsKGUuc3Vic3RyaW5nKDAsZykrZS5zdWJzdHJpbmcoZysxKSksXHJcbi8vIHB1dCBjYXJldCBhdCByaWdodCBwb3NpdGlvbiBhZ2FpbiAoYWRkIG9uZSBmb3IgdGhlIHRhYilcclxudGhpcy5zZWxlY3Rpb25TdGFydD10aGlzLnNlbGVjdGlvbkVuZD1jLTEpfWVsc2VcclxuLy8gc2V0IHRleHRhcmVhIHZhbHVlIHRvOiB0ZXh0IGJlZm9yZSBjYXJldCArIHRhYiArIHRleHQgYWZ0ZXIgY2FyZXRcclxudS52YWwoZS5zdWJzdHJpbmcoMCxjKStcIlxcdFwiK2Uuc3Vic3RyaW5nKGQpKSxcclxuLy8gcHV0IGNhcmV0IGF0IHJpZ2h0IHBvc2l0aW9uIGFnYWluIChhZGQgb25lIGZvciB0aGUgdGFiKVxyXG50aGlzLnNlbGVjdGlvblN0YXJ0PXRoaXMuc2VsZWN0aW9uRW5kPWMrMTtcclxuLy8gcHJldmVudCB0aGUgZm9jdXMgbG9zZVxyXG5hLnByZXZlbnREZWZhdWx0KCl9fSk7dmFyIGthPWZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPVwiXCIsZD0wO2Q8YjtkKyspYys9YTtyZXR1cm4gY30sbGE9ZnVuY3Rpb24oYSxiLGMpe2Zvcih2YXIgZD0wO2Q8YS5sZW5ndGg7ZCsrKWIuY2FsbChjLGQsYVtkXSl9LG1hPWZ1bmN0aW9uKGEsYil7dmFyIGM9XCJcIixkPWEuY2hpbGROb2RlcztcclxuLy8gdGFiIG91dCBhbmQgYWRkIHRoZSA8dWw+IG9yIDxvbD4gaHRtbCBwaWVjZVxyXG4vLyBub3cgYWRkIG9uIHRoZSA8L29sPiBvciA8L3VsPiBwaWVjZVxyXG5yZXR1cm4gYisrLGMrPWthKFwiXFx0XCIsYi0xKSthLm91dGVySFRNTC5zdWJzdHJpbmcoMCw0KSxsYShkLGZ1bmN0aW9uKGEsZCl7LyogaXN0YW5idWwgaWdub3JlIG5leHQ6IGJyb3dzZXIgY2F0Y2ggKi9cclxudmFyIGU9ZC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpOy8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBub3QgdGVzdGVkLCBhbmQgdGhpcyB3YXMgb3JpZ2luYWwgY29kZSAtLSBzbyBub3Qgd2FudGluZyB0byBwb3NzaWJseSBjYXVzZSBhbiBpc3N1ZSwgbGVhdmluZyBpdC4uLiAqL1xyXG5yZXR1cm5cIiNjb21tZW50XCI9PT1lP3ZvaWQoYys9XCI8IS0tXCIrZC5ub2RlVmFsdWUrXCItLT5cIik6XCIjdGV4dFwiPT09ZT92b2lkKGMrPWQudGV4dENvbnRlbnQpOnZvaWQoZC5vdXRlckhUTUwmJihjKz1cInVsXCI9PT1lfHxcIm9sXCI9PT1lP1wiXFxuXCIrbWEoZCxiKTpcIlxcblwiK2thKFwiXFx0XCIsYikrZC5vdXRlckhUTUwpKX0pLGMrPVwiXFxuXCIra2EoXCJcXHRcIixiLTEpK2Eub3V0ZXJIVE1MLnN1YnN0cmluZyhhLm91dGVySFRNTC5sYXN0SW5kZXhPZihcIjxcIikpfTtcclxuLy8gaGFuZGxlIGZvcm1hdGluZyBvZiBzb21ldGhpbmcgbGlrZTpcclxuLy8gPG9sPjwhLS1GaXJzdCBjb21tZW50LS0+XHJcbi8vICA8bGk+VGVzdCBMaW5lIDE8IS0tY29tbWVudCB0ZXN0IGxpc3QgMS0tPjwvbGk+XHJcbi8vICAgIDx1bD48IS0tY29tbWVudCB1bC0tPlxyXG4vLyAgICAgIDxsaT5OZXN0ZWQgTGluZSAxPC9saT5cclxuLy8gICAgICAgIDwhLS1jb21tZW50IGJldHdlZW4gbmVzdGVkIGxpbmVzLS0+PGxpPk5lc3RlZCBMaW5lIDI8L2xpPlxyXG4vLyAgICA8L3VsPlxyXG4vLyAgPGxpPlRlc3QgTGluZSAzPC9saT5cclxuLy8gPC9vbD5cclxuQy4kZm9ybWF0dGVycy51bnNoaWZ0KGZ1bmN0aW9uKGEpe1xyXG4vLyB0YWJ1bGF0ZSB0aGUgSFRNTCBzbyBpdCBsb29rcyBuaWNlclxyXG4vL1xyXG4vLyBmaXJzdCBnZXQgYSBsaXN0IG9mIHRoZSBub2Rlcy4uLlxyXG4vLyB3ZSBkbyB0aGlzIGJ5IHVzaW5nIHRoZSBlbGVtZW50IHBhcnNlci4uLlxyXG4vL1xyXG4vLyBkb2luZyB0aGlzIC0tIHdoaWNoIGlzIHNpbXBpbGVyIC0tIGJyZWFrcyBvdXIgdGVzdHMuLi5cclxuLy92YXIgX25vZGVzPWFuZ3VsYXIuZWxlbWVudChodG1sVmFsdWUpO1xyXG52YXIgYj1hbmd1bGFyLmVsZW1lbnQoXCI8ZGl2PlwiK2ErXCI8L2Rpdj5cIilbMF0uY2hpbGROb2RlcztcclxuLy8gZG8gdGhlIHJlZm9ybWF0dGluZyBvZiB0aGUgbGF5b3V0Li4uXHJcbnJldHVybiBiLmxlbmd0aD4wJiYoYT1cIlwiLGxhKGIsZnVuY3Rpb24oYixjKXt2YXIgZD1jLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7LyogaXN0YW5idWwgaWdub3JlIG5leHQ6IG5vdCB0ZXN0ZWQsIGFuZCB0aGlzIHdhcyBvcmlnaW5hbCBjb2RlIC0tIHNvIG5vdCB3YW50aW5nIHRvIHBvc3NpYmx5IGNhdXNlIGFuIGlzc3VlLCBsZWF2aW5nIGl0Li4uICovXHJcbi8vIHdlIGFyZWFkeSBoYXZlIHNvbWUgY29udGVudCwgc28gZHJvcCB0byBhIG5ldyBsaW5lXHJcbi8vIG9rYXkgYSBzZXQgb2YgbGlzdCBzdHVmZiB3ZSB3YW50IHRvIHJlZm9ybWF0IGluIGEgbmVzdGVkIHdheVxyXG5yZXR1cm5cIiNjb21tZW50XCI9PT1kP3ZvaWQoYSs9XCI8IS0tXCIrYy5ub2RlVmFsdWUrXCItLT5cIik6XCIjdGV4dFwiPT09ZD92b2lkKGErPWMudGV4dENvbnRlbnQpOnZvaWQoYy5vdXRlckhUTUwmJihhLmxlbmd0aD4wJiYoYSs9XCJcXG5cIiksYSs9XCJ1bFwiPT09ZHx8XCJvbFwiPT09ZD9cIlwiK21hKGMsMCk6XCJcIitjLm91dGVySFRNTCkpfSkpLGF9KX12YXIgbmEsb2E9ZnVuY3Rpb24oYSxiKXtcclxuLy8gZW1pdCB0aGUgZHJvcCBldmVudCwgcGFzcyB0aGUgZWxlbWVudCwgcHJldmVudGluZyBzaG91bGQgYmUgZG9uZSBlbHNld2hlcmVcclxuaWYoLyogaXN0YW5idWwgaWdub3JlIGVsc2U6IHRoaXMgaXMgZm9yIGNhdGNoaW5nIHRoZSBqcUxpdGUgdGVzdGluZyovXHJcbmImJmFuZ3VsYXIuZXh0ZW5kKGEsYiksIXQmJiFHKXt0PSEwO3ZhciBkO2Q9YS5vcmlnaW5hbEV2ZW50P2Eub3JpZ2luYWxFdmVudC5kYXRhVHJhbnNmZXI6YS5kYXRhVHJhbnNmZXIsZi4kZW1pdChcInRhLWRyb3AtZXZlbnRcIix0aGlzLGEsZCksYyhmdW5jdGlvbigpe3Q9ITEsYWEodm9pZCAwLHZvaWQgMCwhMCl9LDEwMCl9fSxwYT0hMTtcclxuLy8gY2hhbmdlcyB0byB0aGUgbW9kZWwgdmFyaWFibGUgZnJvbSBvdXRzaWRlIHRoZSBodG1sL3RleHQgaW5wdXRzXHJcbkMuJHJlbmRlcj1mdW5jdGlvbigpey8qIGlzdGFuYnVsIGlnbm9yZSBpZjogQ2F0Y2hlcyByb2d1ZSByZW5kZXJzLCBoYXJkIHRvIHJlcGxpY2F0ZSBpbiB0ZXN0cyAqL1xyXG5pZighcGEpe3BhPSEwO1xyXG4vLyBjYXRjaCBtb2RlbCBiZWluZyBudWxsIG9yIHVuZGVmaW5lZFxyXG52YXIgYT1DLiR2aWV3VmFsdWV8fFwiXCI7XHJcbi8vIGlmIHRoZSBlZGl0b3IgaXNuJ3QgZm9jdXNlZCBpdCBuZWVkcyB0byBiZSB1cGRhdGVkLCBvdGhlcndpc2UgaXQncyByZWNlaXZpbmcgdXNlciBpbnB1dFxyXG5JfHwoLyogaXN0YW5idWwgaWdub3JlIGVsc2U6IGluIG90aGVyIGNhc2VzIHdlIGRvbid0IGNhcmUgKi9cclxuRSYmSCYmKFxyXG4vLyB1cGRhdGUgd2hpbGUgZm9jdXNzZWRcclxudS5yZW1vdmVDbGFzcyhcInBsYWNlaG9sZGVyLXRleHRcIiksLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IGRvbid0IGtub3cgaG93IHRvIHRlc3QgdGhpcyAqL1xyXG5uYSYmYy5jYW5jZWwobmEpLG5hPWMoZnVuY3Rpb24oKXsvKiBpc3RhbmJ1bCBpZ25vcmUgaWY6IENhbid0IGJlIGJvdGhlcmVkIHRlc3RpbmcgdGhpcy4uLiAqL1xyXG5IfHwodVswXS5mb2N1cygpLGguc2V0U2VsZWN0aW9uVG9FbGVtZW50RW5kKHUuY2hpbGRyZW4oKVt1LmNoaWxkcmVuKCkubGVuZ3RoLTFdKSksbmE9dm9pZCAwfSwxKSksRT8oXHJcbi8vIGJsYW5rXHJcbmJhKFxyXG4vLyBXWVNJV1lHIE1vZGVcclxudi5wbGFjZWhvbGRlcj9cIlwiPT09YT9BOmE6XCJcIj09PWE/QTphKSxcclxuLy8gaWYgaW4gV1lTSVdZRyBhbmQgcmVhZE9ubHkgd2Uga2lsbCB0aGUgdXNlIG9mIGxpbmtzIGJ5IGNsaWNraW5nXHJcbkc/dS5vZmYoXCJkcm9wXCIsb2EpOihfKCksdS5vbihcImRyb3BcIixvYSkpKTpcInRleHRhcmVhXCIhPT11WzBdLnRhZ05hbWUudG9Mb3dlckNhc2UoKSYmXCJpbnB1dFwiIT09dVswXS50YWdOYW1lLnRvTG93ZXJDYXNlKCk/XHJcbi8vIG1ha2Ugc3VyZSB0aGUgZW5kIHVzZXIgY2FuIFNFRSB0aGUgaHRtbCBjb2RlIGFzIGEgZGlzcGxheS4gVGhpcyBpcyBhIHJlYWQtb25seSBkaXNwbGF5IGVsZW1lbnRcclxuYmEobChhKSk6XHJcbi8vIG9ubHkgZm9yIGlucHV0IGFuZCB0ZXh0YXJlYSBpbnB1dHNcclxudS52YWwoYSkpLEUmJnYucGxhY2Vob2xkZXImJihcIlwiPT09YT9IP3UucmVtb3ZlQ2xhc3MoXCJwbGFjZWhvbGRlci10ZXh0XCIpOnUuYWRkQ2xhc3MoXCJwbGFjZWhvbGRlci10ZXh0XCIpOnUucmVtb3ZlQ2xhc3MoXCJwbGFjZWhvbGRlci10ZXh0XCIpKSxwYT1JPSExfX0sdi50YVJlYWRvbmx5JiYoXHJcbi8vc2V0IGluaXRpYWwgdmFsdWVcclxuRz1mLiRldmFsKHYudGFSZWFkb25seSksRz8odS5hZGRDbGFzcyhcInRhLXJlYWRvbmx5XCIpLFxyXG4vLyB3ZSBjaGFuZ2VkIHRvIHJlYWRPbmx5IG1vZGUgKHRhUmVhZG9ubHk9J3RydWUnKVxyXG5cInRleHRhcmVhXCIhPT11WzBdLnRhZ05hbWUudG9Mb3dlckNhc2UoKSYmXCJpbnB1dFwiIT09dVswXS50YWdOYW1lLnRvTG93ZXJDYXNlKCl8fHUuYXR0cihcImRpc2FibGVkXCIsXCJkaXNhYmxlZFwiKSx2b2lkIDAhPT11LmF0dHIoXCJjb250ZW50ZWRpdGFibGVcIikmJnUuYXR0cihcImNvbnRlbnRlZGl0YWJsZVwiKSYmdS5yZW1vdmVBdHRyKFwiY29udGVudGVkaXRhYmxlXCIpKToodS5yZW1vdmVDbGFzcyhcInRhLXJlYWRvbmx5XCIpLFxyXG4vLyB3ZSBjaGFuZ2VkIHRvIE5PVCByZWFkT25seSBtb2RlICh0YVJlYWRvbmx5PSdmYWxzZScpXHJcblwidGV4dGFyZWFcIj09PXVbMF0udGFnTmFtZS50b0xvd2VyQ2FzZSgpfHxcImlucHV0XCI9PT11WzBdLnRhZ05hbWUudG9Mb3dlckNhc2UoKT91LnJlbW92ZUF0dHIoXCJkaXNhYmxlZFwiKTpFJiZ1LmF0dHIoXCJjb250ZW50ZWRpdGFibGVcIixcInRydWVcIikpLFxyXG4vLyB0YVJlYWRvbmx5IG9ubHkgaGFzIGFuIGVmZmVjdCBpZiB0aGUgdGFCaW5kIGVsZW1lbnQgaXMgYW4gaW5wdXQgb3IgdGV4dGFyZWEgb3IgaGFzIGNvbnRlbnRlZGl0YWJsZT0ndHJ1ZScgb24gaXQuXHJcbi8vIE90aGVyd2lzZSBpdCBpcyByZWFkb25seSBieSBkZWZhdWx0XHJcbmYuJHdhdGNoKHYudGFSZWFkb25seSxmdW5jdGlvbihhLGIpe2IhPT1hJiYoYT8odS5hZGRDbGFzcyhcInRhLXJlYWRvbmx5XCIpLFxyXG4vLyB3ZSBjaGFuZ2VkIHRvIHJlYWRPbmx5IG1vZGUgKHRhUmVhZG9ubHk9J3RydWUnKVxyXG5cInRleHRhcmVhXCIhPT11WzBdLnRhZ05hbWUudG9Mb3dlckNhc2UoKSYmXCJpbnB1dFwiIT09dVswXS50YWdOYW1lLnRvTG93ZXJDYXNlKCl8fHUuYXR0cihcImRpc2FibGVkXCIsXCJkaXNhYmxlZFwiKSx2b2lkIDAhPT11LmF0dHIoXCJjb250ZW50ZWRpdGFibGVcIikmJnUuYXR0cihcImNvbnRlbnRlZGl0YWJsZVwiKSYmdS5yZW1vdmVBdHRyKFwiY29udGVudGVkaXRhYmxlXCIpLFxyXG4vLyB0dXJuIE9OIHNlbGVjdG9yIGNsaWNrIGhhbmRsZXJzXHJcbmFuZ3VsYXIuZm9yRWFjaChqLGZ1bmN0aW9uKGEpe3UuZmluZChhKS5vbihcImNsaWNrXCIsJCl9KSx1Lm9mZihcImRyb3BcIixvYSkpOih1LnJlbW92ZUNsYXNzKFwidGEtcmVhZG9ubHlcIiksXHJcbi8vIHdlIGNoYW5nZWQgdG8gTk9UIHJlYWRPbmx5IG1vZGUgKHRhUmVhZG9ubHk9J2ZhbHNlJylcclxuXCJ0ZXh0YXJlYVwiPT09dVswXS50YWdOYW1lLnRvTG93ZXJDYXNlKCl8fFwiaW5wdXRcIj09PXVbMF0udGFnTmFtZS50b0xvd2VyQ2FzZSgpP3UucmVtb3ZlQXR0cihcImRpc2FibGVkXCIpOkUmJnUuYXR0cihcImNvbnRlbnRlZGl0YWJsZVwiLFwidHJ1ZVwiKSxcclxuLy8gcmVtb3ZlIHRoZSBzZWxlY3RvciBjbGljayBoYW5kbGVyc1xyXG5hbmd1bGFyLmZvckVhY2goaixmdW5jdGlvbihhKXt1LmZpbmQoYSkub2ZmKFwiY2xpY2tcIiwkKX0pLHUub24oXCJkcm9wXCIsb2EpKSxHPWEpfSkpLFxyXG4vLyBJbml0aWFsaXNlIHRoZSBzZWxlY3RhYmxlRWxlbWVudHNcclxuLy8gaWYgaW4gV1lTSVdZRyBhbmQgcmVhZE9ubHkgd2Uga2lsbCB0aGUgdXNlIG9mIGxpbmtzIGJ5IGNsaWNraW5nXHJcbkUmJiFHJiYoYW5ndWxhci5mb3JFYWNoKGosZnVuY3Rpb24oYSl7dS5maW5kKGEpLm9uKFwiY2xpY2tcIiwkKX0pLHUub24oXCJkcm9wXCIsb2EpKX19fV0pO1xyXG4vLyB0aGlzIGdsb2JhbCB2YXIgaXMgdXNlZCB0byBwcmV2ZW50IG11bHRpcGxlIGZpcmVzIG9mIHRoZSBkcm9wIGV2ZW50LiBOZWVkcyB0byBiZSBnbG9iYWwgdG8gdGhlIHRleHRBbmd1bGFyIGZpbGUuXHJcbnZhciB0PSExLHU9YW5ndWxhci5tb2R1bGUoXCJ0ZXh0QW5ndWxhclwiLFtcIm5nU2FuaXRpemVcIixcInRleHRBbmd1bGFyU2V0dXBcIixcInRleHRBbmd1bGFyLmZhY3Rvcmllc1wiLFwidGV4dEFuZ3VsYXIuRE9NXCIsXCJ0ZXh0QW5ndWxhci52YWxpZGF0b3JzXCIsXCJ0ZXh0QW5ndWxhci50YUJpbmRcIl0pOy8vVGhpcyBtYWtlcyBuZ1Nhbml0aXplIHJlcXVpcmVkXHJcbnJldHVybiB1LmNvbmZpZyhbZnVuY3Rpb24oKXtcclxuLy8gY2xlYXIgdGFUb29scyB2YXJpYWJsZS4gSnVzdCBjYXRjaGVzIHRlc3RpbmcgYW5kIGFueSBvdGhlciB0aW1lIHRoYXQgdGhpcyBjb25maWcgbWF5IHJ1biBtdWx0aXBsZSB0aW1lcy4uLlxyXG5hbmd1bGFyLmZvckVhY2goZSxmdW5jdGlvbihhLGIpe2RlbGV0ZSBlW2JdfSl9XSksdS5kaXJlY3RpdmUoXCJ0ZXh0QW5ndWxhclwiLFtcIiRjb21waWxlXCIsXCIkdGltZW91dFwiLFwidGFPcHRpb25zXCIsXCJ0YVNlbGVjdGlvblwiLFwidGFFeGVjQ29tbWFuZFwiLFwidGV4dEFuZ3VsYXJNYW5hZ2VyXCIsXCIkZG9jdW1lbnRcIixcIiRhbmltYXRlXCIsXCIkbG9nXCIsXCIkcVwiLFwiJHBhcnNlXCIsZnVuY3Rpb24oYixjLGQsZSxmLGcsaCxpLGosayxsKXtyZXR1cm57cmVxdWlyZTpcIj9uZ01vZGVsXCIsc2NvcGU6e30scmVzdHJpY3Q6XCJFQVwiLHByaW9yaXR5OjIsLy8gU28gd2Ugb3ZlcnJpZGUgdmFsaWRhdG9ycyBjb3JyZWN0bHlcclxubGluazpmdW5jdGlvbihtLG4sbyxwKXtcclxuLy8gYWxsIHRoZXNlIHZhcnMgc2hvdWxkIG5vdCBiZSBhY2Nlc3NhYmxlIG91dHNpZGUgdGhpcyBkaXJlY3RpdmVcclxudmFyIHEscixzLHQsdSx2LHcseCx5LHosQSxCLEMsRD1vLnNlcmlhbD9vLnNlcmlhbDpNYXRoLmZsb29yKDFlMTYqTWF0aC5yYW5kb20oKSk7bS5fbmFtZT1vLm5hbWU/by5uYW1lOlwidGV4dEFuZ3VsYXJFZGl0b3JcIitEO3ZhciBFPWZ1bmN0aW9uKGEsYixkKXtjKGZ1bmN0aW9uKCl7XHJcbi8vIHNoaW0gdGhlIC5vbmUgdGlsbCBmaXhlZFxyXG52YXIgYz1mdW5jdGlvbigpe2Eub2ZmKGIsYyksZC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O2Eub24oYixjKX0sMTAwKX07aWYoeT1mKG8udGFEZWZhdWx0V3JhcCksXHJcbi8vIGdldCB0aGUgc2V0dGluZ3MgZnJvbSB0aGUgZGVmYXVsdHMgYW5kIGFkZCBvdXIgc3BlY2lmaWMgZnVuY3Rpb25zIHRoYXQgbmVlZCB0byBiZSBvbiB0aGUgc2NvcGVcclxuYW5ndWxhci5leHRlbmQobSxhbmd1bGFyLmNvcHkoZCkse1xyXG4vLyB3cmFwcyB0aGUgc2VsZWN0aW9uIGluIHRoZSBwcm92aWRlZCB0YWcgLyBleGVjQ29tbWFuZCBmdW5jdGlvbi4gU2hvdWxkIG9ubHkgYmUgY2FsbGVkIGluIFdZU0lXWUcgbW9kZS5cclxud3JhcFNlbGVjdGlvbjpmdW5jdGlvbihhLGIsYyl7XHJcbi8vIHdlIHJlc3RvcmUgdGhlIHNhdmVkIHNlbGVjdGlvbiB0aGF0IHdhcyBzYXZlZCB3aGVuIGZvY3VzIHdhcyBsb3N0XHJcbi8qIE5PVCBGVU5DVElPTkFMIFlFVCAqL1xyXG4vKiB0ZXh0QW5ndWxhck1hbmFnZXIucmVzdG9yZUZvY3VzU2VsZWN0aW9uKHNjb3BlLl9uYW1lLCBzY29wZSk7ICovXHJcblwidW5kb1wiPT09YS50b0xvd2VyQ2FzZSgpP21bXCIkdW5kb1RhQmluZHRhVGV4dEVsZW1lbnRcIitEXSgpOlwicmVkb1wiPT09YS50b0xvd2VyQ2FzZSgpP21bXCIkcmVkb1RhQmluZHRhVGV4dEVsZW1lbnRcIitEXSgpOihcclxuLy8gY2F0Y2ggZXJyb3JzIGxpa2UgRkYgZXJyb3Jpbmcgd2hlbiB5b3UgdHJ5IHRvIGZvcmNlIGFuIHVuZG8gd2l0aCBub3RoaW5nIGRvbmVcclxueShhLCExLGIsbS5kZWZhdWx0VGFnQXR0cmlidXRlcyksYyYmXHJcbi8vIHJlLWFwcGx5IHRoZSBzZWxlY3RhYmxlIHRvb2wgZXZlbnRzXHJcbm1bXCJyZUFwcGx5T25TZWxlY3RvckhhbmRsZXJzdGFUZXh0RWxlbWVudFwiK0RdKCksXHJcbi8vIHJlZm9jdXMgb24gdGhlIHNob3duIGRpc3BsYXkgZWxlbWVudCwgdGhpcyBmaXhlcyBhIGRpc3BsYXkgYnVnIHdoZW4gdXNpbmcgOmZvY3VzIHN0eWxlcyB0byBvdXRsaW5lIHRoZSBib3guXHJcbi8vIFlvdSBzdGlsbCBoYXZlIGZvY3VzIG9uIHRoZSB0ZXh0L2h0bWwgaW5wdXQgaXQganVzdCBkb2Vzbid0IHNob3cgdXBcclxubS5kaXNwbGF5RWxlbWVudHMudGV4dFswXS5mb2N1cygpKX0sc2hvd0h0bWw6bS4kZXZhbChvLnRhU2hvd0h0bWwpfHwhMX0pLFxyXG4vLyBzZXR1cCB0aGUgb3B0aW9ucyBmcm9tIHRoZSBvcHRpb25hbCBhdHRyaWJ1dGVzXHJcbm8udGFGb2N1c3NlZENsYXNzJiYobS5jbGFzc2VzLmZvY3Vzc2VkPW8udGFGb2N1c3NlZENsYXNzKSxvLnRhVGV4dEVkaXRvckNsYXNzJiYobS5jbGFzc2VzLnRleHRFZGl0b3I9by50YVRleHRFZGl0b3JDbGFzcyksby50YUh0bWxFZGl0b3JDbGFzcyYmKG0uY2xhc3Nlcy5odG1sRWRpdG9yPW8udGFIdG1sRWRpdG9yQ2xhc3MpLG8udGFEZWZhdWx0VGFnQXR0cmlidXRlcyl0cnl7XHJcbi8vXHRUT0RPOiBUaGlzIHNob3VsZCB1c2UgYW5ndWxhci5tZXJnZSB0byBlbmhhbmNlIGZ1bmN0aW9uYWxpdHkgb25jZSBhbmd1bGFyIDEuNCBpcyByZXF1aXJlZFxyXG5hbmd1bGFyLmV4dGVuZChtLmRlZmF1bHRUYWdBdHRyaWJ1dGVzLGFuZ3VsYXIuZnJvbUpzb24oby50YURlZmF1bHRUYWdBdHRyaWJ1dGVzKSl9Y2F0Y2goYSl7ai5lcnJvcihhKX1cclxuLy8gb3B0aW9uYWwgc2V0dXAgZnVuY3Rpb25zXHJcbm8udGFUZXh0RWRpdG9yU2V0dXAmJihtLnNldHVwLnRleHRFZGl0b3JTZXR1cD1tLiRwYXJlbnQuJGV2YWwoby50YVRleHRFZGl0b3JTZXR1cCkpLG8udGFIdG1sRWRpdG9yU2V0dXAmJihtLnNldHVwLmh0bWxFZGl0b3JTZXR1cD1tLiRwYXJlbnQuJGV2YWwoby50YUh0bWxFZGl0b3JTZXR1cCkpLFxyXG4vLyBvcHRpb25hbCBmaWxlRHJvcEhhbmRsZXIgZnVuY3Rpb25cclxuby50YUZpbGVEcm9wP20uZmlsZURyb3BIYW5kbGVyPW0uJHBhcmVudC4kZXZhbChvLnRhRmlsZURyb3ApOm0uZmlsZURyb3BIYW5kbGVyPW0uZGVmYXVsdEZpbGVEcm9wSGFuZGxlcix3PW5bMF0uaW5uZXJIVE1MLFxyXG4vLyBjbGVhciB0aGUgb3JpZ2luYWwgY29udGVudFxyXG5uWzBdLmlubmVySFRNTD1cIlwiLFxyXG4vLyBTZXR1cCB0aGUgSFRNTCBlbGVtZW50cyBhcyB2YXJpYWJsZSByZWZlcmVuY2VzIGZvciB1c2UgbGF0ZXJcclxubS5kaXNwbGF5RWxlbWVudHM9e1xyXG4vLyB3ZSBzdGlsbCBuZWVkIHRoZSBoaWRkZW4gaW5wdXQgZXZlbiB3aXRoIGEgdGV4dGFyZWEgYXMgdGhlIHRleHRhcmVhIG1heSBoYXZlIGludmFsaWQvb2xkIGlucHV0IGluIGl0LFxyXG4vLyB3aGVyYXMgdGhlIGlucHV0IHdpbGwgQUxMV0FZUyBoYXZlIHRoZSBjb3JyZWN0IHZhbHVlLlxyXG5mb3JtaW5wdXQ6YW5ndWxhci5lbGVtZW50KFwiPGlucHV0IHR5cGU9J2hpZGRlbicgdGFiaW5kZXg9Jy0xJyBzdHlsZT0nZGlzcGxheTogbm9uZTsnPlwiKSxodG1sOmFuZ3VsYXIuZWxlbWVudChcIjx0ZXh0YXJlYT48L3RleHRhcmVhPlwiKSx0ZXh0OmFuZ3VsYXIuZWxlbWVudChcIjxkaXY+PC9kaXY+XCIpLFxyXG4vLyBvdGhlciB0b29sYmFzZWQgZWxlbWVudHNcclxuc2Nyb2xsV2luZG93OmFuZ3VsYXIuZWxlbWVudChcIjxkaXYgY2xhc3M9J3RhLXNjcm9sbC13aW5kb3cnPjwvZGl2PlwiKSxwb3BvdmVyOmFuZ3VsYXIuZWxlbWVudCgnPGRpdiBjbGFzcz1cInBvcG92ZXIgZmFkZSBib3R0b21cIiBzdHlsZT1cIm1heC13aWR0aDogbm9uZTsgd2lkdGg6IDMwNXB4O1wiPjwvZGl2PicpLHBvcG92ZXJBcnJvdzphbmd1bGFyLmVsZW1lbnQoJzxkaXYgY2xhc3M9XCJhcnJvd1wiPjwvZGl2PicpLHBvcG92ZXJDb250YWluZXI6YW5ndWxhci5lbGVtZW50KCc8ZGl2IGNsYXNzPVwicG9wb3Zlci1jb250ZW50XCI+PC9kaXY+JykscmVzaXplOntvdmVybGF5OmFuZ3VsYXIuZWxlbWVudCgnPGRpdiBjbGFzcz1cInRhLXJlc2l6ZXItaGFuZGxlLW92ZXJsYXlcIj48L2Rpdj4nKSxiYWNrZ3JvdW5kOmFuZ3VsYXIuZWxlbWVudCgnPGRpdiBjbGFzcz1cInRhLXJlc2l6ZXItaGFuZGxlLWJhY2tncm91bmRcIj48L2Rpdj4nKSxhbmNob3JzOlthbmd1bGFyLmVsZW1lbnQoJzxkaXYgY2xhc3M9XCJ0YS1yZXNpemVyLWhhbmRsZS1jb3JuZXIgdGEtcmVzaXplci1oYW5kbGUtY29ybmVyLXRsXCI+PC9kaXY+JyksYW5ndWxhci5lbGVtZW50KCc8ZGl2IGNsYXNzPVwidGEtcmVzaXplci1oYW5kbGUtY29ybmVyIHRhLXJlc2l6ZXItaGFuZGxlLWNvcm5lci10clwiPjwvZGl2PicpLGFuZ3VsYXIuZWxlbWVudCgnPGRpdiBjbGFzcz1cInRhLXJlc2l6ZXItaGFuZGxlLWNvcm5lciB0YS1yZXNpemVyLWhhbmRsZS1jb3JuZXItYmxcIj48L2Rpdj4nKSxhbmd1bGFyLmVsZW1lbnQoJzxkaXYgY2xhc3M9XCJ0YS1yZXNpemVyLWhhbmRsZS1jb3JuZXIgdGEtcmVzaXplci1oYW5kbGUtY29ybmVyLWJyXCI+PC9kaXY+JyldLGluZm86YW5ndWxhci5lbGVtZW50KCc8ZGl2IGNsYXNzPVwidGEtcmVzaXplci1oYW5kbGUtaW5mb1wiPjwvZGl2PicpfX0sXHJcbi8vIFNldHVwIHRoZSBwb3BvdmVyXHJcbm0uZGlzcGxheUVsZW1lbnRzLnBvcG92ZXIuYXBwZW5kKG0uZGlzcGxheUVsZW1lbnRzLnBvcG92ZXJBcnJvdyksbS5kaXNwbGF5RWxlbWVudHMucG9wb3Zlci5hcHBlbmQobS5kaXNwbGF5RWxlbWVudHMucG9wb3ZlckNvbnRhaW5lciksbS5kaXNwbGF5RWxlbWVudHMuc2Nyb2xsV2luZG93LmFwcGVuZChtLmRpc3BsYXlFbGVtZW50cy5wb3BvdmVyKSxtLmRpc3BsYXlFbGVtZW50cy5wb3BvdmVyLm9uKFwibW91c2Vkb3duXCIsZnVuY3Rpb24oYSxiKXsvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZTogdGhpcyBpcyBmb3IgY2F0Y2hpbmcgdGhlIGpxTGl0ZSB0ZXN0aW5nKi9cclxuLy8gdGhpcyBwcmV2ZW50cyBmb2N1c291dCBmcm9tIGZpcmluZyBvbiB0aGUgZWRpdG9yIHdoZW4gY2xpY2tpbmcgYW55dGhpbmcgaW4gdGhlIHBvcG92ZXJcclxucmV0dXJuIGImJmFuZ3VsYXIuZXh0ZW5kKGEsYiksYS5wcmV2ZW50RGVmYXVsdCgpLCExfSksLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IHBvcG92ZXIgcmVzaXplIGFuZCBzY3JvbGwgZXZlbnRzIGhhbmRsZWQgKi9cclxubS5oYW5kbGVQb3BvdmVyRXZlbnRzPWZ1bmN0aW9uKCl7XCJibG9ja1wiPT09bS5kaXNwbGF5RWxlbWVudHMucG9wb3Zlci5jc3MoXCJkaXNwbGF5XCIpJiYoQiYmYy5jYW5jZWwoQiksQj1jKGZ1bmN0aW9uKCl7XHJcbi8vY29uc29sZS5sb2coJ3Jlc2l6ZScsIHNjb3BlLmRpc3BsYXlFbGVtZW50cy5wb3BvdmVyLmNzcygnZGlzcGxheScpKTtcclxubS5yZWZsb3dQb3BvdmVyKEMpLG0ucmVmbG93UmVzaXplT3ZlcmxheShDKX0sMTAwKSl9LC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBicm93c2VyIHJlc2l6ZSBjaGVjayAqL1xyXG5hbmd1bGFyLmVsZW1lbnQod2luZG93KS5vbihcInJlc2l6ZVwiLGZ1bmN0aW9uKGEsYil7bS5oYW5kbGVQb3BvdmVyRXZlbnRzKCl9KSwvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogYnJvd3NlciBzY3JvbGwgY2hlY2sgKi9cclxuYW5ndWxhci5lbGVtZW50KHdpbmRvdykub24oXCJzY3JvbGxcIixmdW5jdGlvbihhLGIpe20uaGFuZGxlUG9wb3ZlckV2ZW50cygpfSk7XHJcbi8vIHdlIHdhbnQgdG8ga25vdyBpZiBhIGdpdmVuIG5vZGUgaGFzIGEgc2Nyb2xsYmFyIVxyXG4vLyBjcmVkaXQgdG8gbG90aWYgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80ODgwMzgxL2NoZWNrLXdoZXRoZXItaHRtbC1lbGVtZW50LWhhcy1zY3JvbGxiYXJzXHJcbnZhciBGPWZ1bmN0aW9uKGEpe3ZhciBiLGM9e3ZlcnRpY2FsOiExLGhvcml6b250YWw6ITF9O3RyeXtpZihiPXdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGEpLG51bGw9PT1iKXJldHVybiBjfWNhdGNoKGEpey8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBlcnJvciBoYW5kbGVyICovXHJcbnJldHVybiBjfXZhciBkPWJbXCJvdmVyZmxvdy15XCJdLGU9YltcIm92ZXJmbG93LXhcIl07cmV0dXJue3ZlcnRpY2FsOihcInNjcm9sbFwiPT09ZHx8XCJhdXRvXCI9PT1kKSYmLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IG5vdCB0ZXN0ZWQgKi9cclxuYS5zY3JvbGxIZWlnaHQ+YS5jbGllbnRIZWlnaHQsaG9yaXpvbnRhbDooXCJzY3JvbGxcIj09PWV8fFwiYXV0b1wiPT09ZSkmJi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBub3QgdGVzdGVkICovXHJcbmEuc2Nyb2xsV2lkdGg+YS5jbGllbnRXaWR0aH19O1xyXG4vLyBnZXRTY3JvbGxUb3BcclxuLy9cclxuLy8gd2Ugc3RydWN0dXJlIHRoaXMgc28gdGhhdCBpdCBjYW4gY2xpbWIgdGhlIHBhcmVudHMgb2YgdGhlIF9lbCBhbmQgd2hlbiBpdCBmaW5kc1xyXG4vLyBvbmUgd2l0aCBzY3JvbGxiYXJzLCBpdCBhZGRzIGFuIEV2ZW50TGlzdGVuZXIsIHNvIHRoYXQgbm8gbWF0dGVyIGhvdyB0aGVcclxuLy8gRE9NIGlzIHN0cnVjdHVyZWQgaW4gdGhlIHVzZXIgQVBQLCBpZiB0aGVyZSBpcyBhIHNjcm9sbGJhciBub3QgYXMgcGFydCBvZiB0aGVcclxuLy8gdGEtc2Nyb2xsLXdpbmRvdywgd2Ugd2lsbCBzdGlsbCBjYXB0dXJlIHRoZSAnc2Nyb2xsJyBldmVudHMuLi5cclxuLy8gYW5kIGhhbmRsZSB0aGUgc2Nyb2xsIGV2ZW50IHByb3Blcmx5IGFuZCBkbyB0aGUgcmVzaXplLCBldGMuXHJcbi8vXHJcbm0uZ2V0U2Nyb2xsVG9wPWZ1bmN0aW9uKGEsYil7dmFyIGM9YS5zY3JvbGxUb3A7LyogaXN0YW5idWwgaWdub3JlIG5leHQ6IHRyaWdnZXJlZCBvbmx5IGlmIGhhcyBzY3JvbGxiYXIgYW5kIHNjcm9sbGVkICovXHJcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiB0cmlnZ2VyZWQgb25seSBpZiBoYXMgc2Nyb2xsYmFyICovXHJcbi8vIHJlbW92ZSBlbGVtZW50IGV2ZW50TGlzdGVuZXJcclxuLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IHRyaWdnZXJlZCBvbmx5IGlmIGhhcyBzY3JvbGxiYXIgYW5kIHNjcm9sbGVkICovXHJcbi8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlOiBjYXRjaGVzIG9ubHkgaWYgbm8gc2Nyb2xsICovXHJcbnJldHVyblwidW5kZWZpbmVkXCI9PXR5cGVvZiBjJiYoYz0wKSxiJiZGKGEpLnZlcnRpY2FsJiYoYS5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsbS5fc2Nyb2xsTGlzdGVuZXIsITEpLGEuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLG0uX3Njcm9sbExpc3RlbmVyLCExKSksMCE9PWM/e25vZGU6YS5ub2RlTmFtZSx0b3A6Y306YS5wYXJlbnROb2RlP20uZ2V0U2Nyb2xsVG9wKGEucGFyZW50Tm9kZSxiKTp7bm9kZTpcIjxub25lPlwiLHRvcDowfX0sXHJcbi8vIGRlZmluZSB0aGUgcG9wb3ZlciBzaG93IGFuZCBoaWRlIGZ1bmN0aW9uc1xyXG5tLnNob3dQb3BvdmVyPWZ1bmN0aW9uKGEpe20uZ2V0U2Nyb2xsVG9wKG0uZGlzcGxheUVsZW1lbnRzLnNjcm9sbFdpbmRvd1swXSwhMCksbS5kaXNwbGF5RWxlbWVudHMucG9wb3Zlci5jc3MoXCJkaXNwbGF5XCIsXCJibG9ja1wiKSxDPWEsbS5yZWZsb3dQb3BvdmVyKGEpLGkuYWRkQ2xhc3MobS5kaXNwbGF5RWxlbWVudHMucG9wb3ZlcixcImluXCIpLEUoaC5maW5kKFwiYm9keVwiKSxcImNsaWNrIGtleXVwXCIsZnVuY3Rpb24oKXttLmhpZGVQb3BvdmVyKCl9KX0sLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IGJyb3dzZXIgc2Nyb2xsIGV2ZW50IGhhbmRsZXIgKi9cclxubS5fc2Nyb2xsTGlzdGVuZXI9ZnVuY3Rpb24oYSxiKXttLmhhbmRsZVBvcG92ZXJFdmVudHMoKX0sbS5yZWZsb3dQb3BvdmVyPWZ1bmN0aW9uKGEpe3ZhciBiPW0uZ2V0U2Nyb2xsVG9wKG0uZGlzcGxheUVsZW1lbnRzLnNjcm9sbFdpbmRvd1swXSwhMSksYz1hWzBdLm9mZnNldFRvcC1iLnRvcDtcclxuLy92YXIgc3BhY2VCZWxvd0ltYWdlID0gc2NvcGUuZGlzcGxheUVsZW1lbnRzLnRleHRbMF0ub2Zmc2V0SGVpZ2h0IC0gX2VsWzBdLm9mZnNldEhlaWdodCAtIHNwYWNlQWJvdmVJbWFnZTtcclxuLy9jb25zb2xlLmxvZyhzcGFjZUFib3ZlSW1hZ2UsIHNwYWNlQmVsb3dJbWFnZSk7XHJcbi8qIGlzdGFuYnVsIGlnbm9yZSBpZjogY2F0Y2hlcyBvbmx5IGlmIG5lYXIgYm90dG9tIG9mIGVkaXRvciAqL1xyXG5jPDUxPyhtLmRpc3BsYXlFbGVtZW50cy5wb3BvdmVyLmNzcyhcInRvcFwiLGFbMF0ub2Zmc2V0VG9wK2FbMF0ub2Zmc2V0SGVpZ2h0K20uZGlzcGxheUVsZW1lbnRzLnNjcm9sbFdpbmRvd1swXS5zY3JvbGxUb3ArXCJweFwiKSxtLmRpc3BsYXlFbGVtZW50cy5wb3BvdmVyLnJlbW92ZUNsYXNzKFwidG9wXCIpLmFkZENsYXNzKFwiYm90dG9tXCIpKToobS5kaXNwbGF5RWxlbWVudHMucG9wb3Zlci5jc3MoXCJ0b3BcIixhWzBdLm9mZnNldFRvcC01NCttLmRpc3BsYXlFbGVtZW50cy5zY3JvbGxXaW5kb3dbMF0uc2Nyb2xsVG9wK1wicHhcIiksbS5kaXNwbGF5RWxlbWVudHMucG9wb3Zlci5yZW1vdmVDbGFzcyhcImJvdHRvbVwiKS5hZGRDbGFzcyhcInRvcFwiKSk7dmFyIGQ9bS5kaXNwbGF5RWxlbWVudHMudGV4dFswXS5vZmZzZXRXaWR0aC1tLmRpc3BsYXlFbGVtZW50cy5wb3BvdmVyWzBdLm9mZnNldFdpZHRoLGU9YVswXS5vZmZzZXRMZWZ0K2FbMF0ub2Zmc2V0V2lkdGgvMi1tLmRpc3BsYXlFbGVtZW50cy5wb3BvdmVyWzBdLm9mZnNldFdpZHRoLzIsZj1NYXRoLm1heCgwLE1hdGgubWluKGQsZSkpLGc9TWF0aC5taW4oZSxNYXRoLm1heCgwLGUtZCkpLTExO2YrPXdpbmRvdy5zY3JvbGxYLGctPXdpbmRvdy5zY3JvbGxYLG0uZGlzcGxheUVsZW1lbnRzLnBvcG92ZXIuY3NzKFwibGVmdFwiLGYrXCJweFwiKSxtLmRpc3BsYXlFbGVtZW50cy5wb3BvdmVyQXJyb3cuY3NzKFwibWFyZ2luLWxlZnRcIixnK1wicHhcIil9LG0uaGlkZVBvcG92ZXI9ZnVuY3Rpb24oKXttLmRpc3BsYXlFbGVtZW50cy5wb3BvdmVyLmNzcyhcImRpc3BsYXlcIixcIm5vbmVcIiksbS5kaXNwbGF5RWxlbWVudHMucG9wb3ZlckNvbnRhaW5lci5hdHRyKFwic3R5bGVcIixcIlwiKSxtLmRpc3BsYXlFbGVtZW50cy5wb3BvdmVyQ29udGFpbmVyLmF0dHIoXCJjbGFzc1wiLFwicG9wb3Zlci1jb250ZW50XCIpLG0uZGlzcGxheUVsZW1lbnRzLnBvcG92ZXIucmVtb3ZlQ2xhc3MoXCJpblwiKX0sXHJcbi8vIHNldHVwIHRoZSByZXNpemUgb3ZlcmxheVxyXG5tLmRpc3BsYXlFbGVtZW50cy5yZXNpemUub3ZlcmxheS5hcHBlbmQobS5kaXNwbGF5RWxlbWVudHMucmVzaXplLmJhY2tncm91bmQpLGFuZ3VsYXIuZm9yRWFjaChtLmRpc3BsYXlFbGVtZW50cy5yZXNpemUuYW5jaG9ycyxmdW5jdGlvbihhKXttLmRpc3BsYXlFbGVtZW50cy5yZXNpemUub3ZlcmxheS5hcHBlbmQoYSl9KSxtLmRpc3BsYXlFbGVtZW50cy5yZXNpemUub3ZlcmxheS5hcHBlbmQobS5kaXNwbGF5RWxlbWVudHMucmVzaXplLmluZm8pLG0uZGlzcGxheUVsZW1lbnRzLnNjcm9sbFdpbmRvdy5hcHBlbmQobS5kaXNwbGF5RWxlbWVudHMucmVzaXplLm92ZXJsYXkpLFxyXG4vLyBBIGNsaWNrIGV2ZW50IG9uIHRoZSByZXNpemUuYmFja2dyb3VuZCB3aWxsIG5vdyBzaGlmdCB0aGUgZm9jdXMgdG8gdGhlIGVkaXRvclxyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogY2xpY2sgb24gdGhlIHJlc2l6ZS5iYWNrZ3JvdW5kIHRvIGZvY3VzIGJhY2sgdG8gZWRpdG9yICovXHJcbm0uZGlzcGxheUVsZW1lbnRzLnJlc2l6ZS5iYWNrZ3JvdW5kLm9uKFwiY2xpY2tcIixmdW5jdGlvbihhKXttLmRpc3BsYXlFbGVtZW50cy50ZXh0WzBdLmZvY3VzKCl9KSxcclxuLy8gZGVmaW5lIHRoZSBzaG93IGFuZCBoaWRlIGV2ZW50c1xyXG5tLnJlZmxvd1Jlc2l6ZU92ZXJsYXk9ZnVuY3Rpb24oYSl7YT1hbmd1bGFyLmVsZW1lbnQoYSlbMF0sbS5kaXNwbGF5RWxlbWVudHMucmVzaXplLm92ZXJsYXkuY3NzKHtkaXNwbGF5OlwiYmxvY2tcIixsZWZ0OmEub2Zmc2V0TGVmdC01K1wicHhcIix0b3A6YS5vZmZzZXRUb3AtNStcInB4XCIsd2lkdGg6YS5vZmZzZXRXaWR0aCsxMCtcInB4XCIsaGVpZ2h0OmEub2Zmc2V0SGVpZ2h0KzEwK1wicHhcIn0pLG0uZGlzcGxheUVsZW1lbnRzLnJlc2l6ZS5pbmZvLnRleHQoYS5vZmZzZXRXaWR0aCtcIiB4IFwiK2Eub2Zmc2V0SGVpZ2h0KX0sLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IHByZXR0eSBzdXJlIHBoYW50b21qcyB3b24ndCB0ZXN0IHRoaXMgKi9cclxubS5zaG93UmVzaXplT3ZlcmxheT1mdW5jdGlvbihhKXt2YXIgYj1oLmZpbmQoXCJib2R5XCIpO3o9ZnVuY3Rpb24oYyl7dmFyIGQ9e3dpZHRoOnBhcnNlSW50KGEuYXR0cihcIndpZHRoXCIpKSxoZWlnaHQ6cGFyc2VJbnQoYS5hdHRyKFwiaGVpZ2h0XCIpKSx4OmMuY2xpZW50WCx5OmMuY2xpZW50WX07KHZvaWQgMD09PWQud2lkdGh8fGlzTmFOKGQud2lkdGgpKSYmKGQud2lkdGg9YVswXS5vZmZzZXRXaWR0aCksKHZvaWQgMD09PWQuaGVpZ2h0fHxpc05hTihkLmhlaWdodCkpJiYoZC5oZWlnaHQ9YVswXS5vZmZzZXRIZWlnaHQpLG0uaGlkZVBvcG92ZXIoKTt2YXIgZT1kLmhlaWdodC9kLndpZHRoLGY9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYyhhKXtyZXR1cm4gTWF0aC5yb3VuZChNYXRoLm1heCgwLGEpKX1cclxuLy8gY2FsY3VsYXRlIG5ldyBzaXplXHJcbnZhciBmPXt4Ok1hdGgubWF4KDAsZC53aWR0aCsoYi5jbGllbnRYLWQueCkpLHk6TWF0aC5tYXgoMCxkLmhlaWdodCsoYi5jbGllbnRZLWQueSkpfSxnPXZvaWQgMCE9PW8udGFSZXNpemVGb3JjZUFzcGVjdFJhdGlvLGg9by50YVJlc2l6ZU1haW50YWluQXNwZWN0UmF0aW8saT1nfHxoJiYhYi5zaGlmdEtleTtpZihpKXt2YXIgaj1mLnkvZi54O2YueD1lPmo/Zi54OmYueS9lLGYueT1lPmo/Zi54KmU6Zi55fXZhciBrPWFuZ3VsYXIuZWxlbWVudChhKTtrLmNzcyhcImhlaWdodFwiLGMoZi55KStcInB4XCIpLGsuY3NzKFwid2lkdGhcIixjKGYueCkrXCJweFwiKSxcclxuLy8gcmVmbG93IHRoZSBwb3BvdmVyIHRvb2x0aXBcclxubS5yZWZsb3dSZXNpemVPdmVybGF5KGEpfTtiLm9uKFwibW91c2Vtb3ZlXCIsZiksRShiLFwibW91c2V1cFwiLGZ1bmN0aW9uKGEpe2EucHJldmVudERlZmF1bHQoKSxhLnN0b3BQcm9wYWdhdGlvbigpLGIub2ZmKFwibW91c2Vtb3ZlXCIsZiksXHJcbi8vIGF0IHRoaXMgcG9pbnQsIHdlIG5lZWQgdG8gZm9yY2UgdGhlIG1vZGVsIHRvIHVwZGF0ZSEgc2luY2UgdGhlIGNzcyBoYXMgY2hhbmdlZCFcclxuLy8gdGhpcyBmaXhlcyBidWc6ICM4NjIgLSB3ZSBub3cgaGlkZSB0aGUgcG9wb3ZlciAtLSBhcyB0aGlzIHNlZW1zIG1vcmUgY29uc2l0ZW50LlxyXG4vLyB0aGVyZSBhcmUgc3RpbGwgaXNzdWVzIHVuZGVyIGZpcmVmb3gsIHRoZSB3aW5kb3cgZG9lcyBub3QgcmVwYWludC4gLS0gbm90IHN1cmVcclxuLy8gaG93IGJlc3QgdG8gcmVzb2x2ZSB0aGlzLCBidXQgY2xpY2tpbmcgYW55d2hlcmUgd29ya3MuXHJcbm0uJGFwcGx5KGZ1bmN0aW9uKCl7bS5oaWRlUG9wb3ZlcigpLG0udXBkYXRlVGFCaW5kdGFUZXh0RWxlbWVudCgpfSwxMDApfSksYy5zdG9wUHJvcGFnYXRpb24oKSxjLnByZXZlbnREZWZhdWx0KCl9LG0uZGlzcGxheUVsZW1lbnRzLnJlc2l6ZS5hbmNob3JzWzNdLm9mZihcIm1vdXNlZG93blwiKSxtLmRpc3BsYXlFbGVtZW50cy5yZXNpemUuYW5jaG9yc1szXS5vbihcIm1vdXNlZG93blwiLHopLG0ucmVmbG93UmVzaXplT3ZlcmxheShhKSxFKGIsXCJjbGlja1wiLGZ1bmN0aW9uKCl7bS5oaWRlUmVzaXplT3ZlcmxheSgpfSl9LC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBwcmV0dHkgc3VyZSBwaGFudG9tanMgd29uJ3QgdGVzdCB0aGlzICovXHJcbm0uaGlkZVJlc2l6ZU92ZXJsYXk9ZnVuY3Rpb24oKXttLmRpc3BsYXlFbGVtZW50cy5yZXNpemUuYW5jaG9yc1szXS5vZmYoXCJtb3VzZWRvd25cIix6KSxtLmRpc3BsYXlFbGVtZW50cy5yZXNpemUub3ZlcmxheS5jc3MoXCJkaXNwbGF5XCIsXCJub25lXCIpfSxcclxuLy8gYWxsb3cgZm9yIGluc2VydGlvbiBvZiBjdXN0b20gZGlyZWN0aXZlcyBvbiB0aGUgdGV4dGFyZWEgYW5kIGRpdlxyXG5tLnNldHVwLmh0bWxFZGl0b3JTZXR1cChtLmRpc3BsYXlFbGVtZW50cy5odG1sKSxtLnNldHVwLnRleHRFZGl0b3JTZXR1cChtLmRpc3BsYXlFbGVtZW50cy50ZXh0KSxtLmRpc3BsYXlFbGVtZW50cy5odG1sLmF0dHIoe2lkOlwidGFIdG1sRWxlbWVudFwiK0QsXCJuZy1zaG93XCI6XCJzaG93SHRtbFwiLFwidGEtYmluZFwiOlwidGEtYmluZFwiLFwibmctbW9kZWxcIjpcImh0bWxcIixcIm5nLW1vZGVsLW9wdGlvbnNcIjpuLmF0dHIoXCJuZy1tb2RlbC1vcHRpb25zXCIpfSksbS5kaXNwbGF5RWxlbWVudHMudGV4dC5hdHRyKHtpZDpcInRhVGV4dEVsZW1lbnRcIitELGNvbnRlbnRFZGl0YWJsZTpcInRydWVcIixcInRhLWJpbmRcIjpcInRhLWJpbmRcIixcIm5nLW1vZGVsXCI6XCJodG1sXCIsXCJuZy1tb2RlbC1vcHRpb25zXCI6bi5hdHRyKFwibmctbW9kZWwtb3B0aW9uc1wiKX0pLG0uZGlzcGxheUVsZW1lbnRzLnNjcm9sbFdpbmRvdy5hdHRyKHtcIm5nLWhpZGVcIjpcInNob3dIdG1sXCJ9KSxvLnRhRGVmYXVsdFdyYXAmJlxyXG4vLyB0YURlZmF1bHRXcmFwIGlzIG9ubHkgYXBwbGllZCB0byB0aGUgdGV4dCBhbmQgbm90IHRoZSBodG1sIHZpZXdcclxubS5kaXNwbGF5RWxlbWVudHMudGV4dC5hdHRyKFwidGEtZGVmYXVsdC13cmFwXCIsby50YURlZmF1bHRXcmFwKSxvLnRhVW5zYWZlU2FuaXRpemVyJiYobS5kaXNwbGF5RWxlbWVudHMudGV4dC5hdHRyKFwidGEtdW5zYWZlLXNhbml0aXplclwiLG8udGFVbnNhZmVTYW5pdGl6ZXIpLG0uZGlzcGxheUVsZW1lbnRzLmh0bWwuYXR0cihcInRhLXVuc2FmZS1zYW5pdGl6ZXJcIixvLnRhVW5zYWZlU2FuaXRpemVyKSksXHJcbi8vIGFkZCB0aGUgbWFpbiBlbGVtZW50cyB0byB0aGUgb3JpZ2lvbmFsIGVsZW1lbnRcclxubS5kaXNwbGF5RWxlbWVudHMuc2Nyb2xsV2luZG93LmFwcGVuZChtLmRpc3BsYXlFbGVtZW50cy50ZXh0KSxuLmFwcGVuZChtLmRpc3BsYXlFbGVtZW50cy5zY3JvbGxXaW5kb3cpLG4uYXBwZW5kKG0uZGlzcGxheUVsZW1lbnRzLmh0bWwpLG0uZGlzcGxheUVsZW1lbnRzLmZvcm1pbnB1dC5hdHRyKFwibmFtZVwiLG0uX25hbWUpLG4uYXBwZW5kKG0uZGlzcGxheUVsZW1lbnRzLmZvcm1pbnB1dCksby50YWJpbmRleCYmKG4ucmVtb3ZlQXR0cihcInRhYmluZGV4XCIpLG0uZGlzcGxheUVsZW1lbnRzLnRleHQuYXR0cihcInRhYmluZGV4XCIsby50YWJpbmRleCksbS5kaXNwbGF5RWxlbWVudHMuaHRtbC5hdHRyKFwidGFiaW5kZXhcIixvLnRhYmluZGV4KSksby5wbGFjZWhvbGRlciYmKG0uZGlzcGxheUVsZW1lbnRzLnRleHQuYXR0cihcInBsYWNlaG9sZGVyXCIsby5wbGFjZWhvbGRlciksbS5kaXNwbGF5RWxlbWVudHMuaHRtbC5hdHRyKFwicGxhY2Vob2xkZXJcIixvLnBsYWNlaG9sZGVyKSksby50YURpc2FibGVkJiYobS5kaXNwbGF5RWxlbWVudHMudGV4dC5hdHRyKFwidGEtcmVhZG9ubHlcIixcImRpc2FibGVkXCIpLG0uZGlzcGxheUVsZW1lbnRzLmh0bWwuYXR0cihcInRhLXJlYWRvbmx5XCIsXCJkaXNhYmxlZFwiKSxtLmRpc2FibGVkPW0uJHBhcmVudC4kZXZhbChvLnRhRGlzYWJsZWQpLG0uJHBhcmVudC4kd2F0Y2goby50YURpc2FibGVkLGZ1bmN0aW9uKGEpe20uZGlzYWJsZWQ9YSxtLmRpc2FibGVkP24uYWRkQ2xhc3MobS5jbGFzc2VzLmRpc2FibGVkKTpuLnJlbW92ZUNsYXNzKG0uY2xhc3Nlcy5kaXNhYmxlZCl9KSksby50YVBhc3RlJiYobS5fcGFzdGVIYW5kbGVyPWZ1bmN0aW9uKGEpe3JldHVybiBsKG8udGFQYXN0ZSkobS4kcGFyZW50LHskaHRtbDphfSl9LG0uZGlzcGxheUVsZW1lbnRzLnRleHQuYXR0cihcInRhLXBhc3RlXCIsXCJfcGFzdGVIYW5kbGVyKCRodG1sKVwiKSksXHJcbi8vIGNvbXBpbGUgdGhlIHNjb3BlIHdpdGggdGhlIHRleHQgYW5kIGh0bWwgZWxlbWVudHMgb25seSAtIGlmIHdlIGRvIHRoaXMgd2l0aCB0aGUgbWFpbiBlbGVtZW50IGl0IGNhdXNlcyBhIGNvbXBpbGUgbG9vcFxyXG5iKG0uZGlzcGxheUVsZW1lbnRzLnNjcm9sbFdpbmRvdykobSksYihtLmRpc3BsYXlFbGVtZW50cy5odG1sKShtKSxtLnVwZGF0ZVRhQmluZHRhVGV4dEVsZW1lbnQ9bVtcInVwZGF0ZVRhQmluZHRhVGV4dEVsZW1lbnRcIitEXSxtLnVwZGF0ZVRhQmluZHRhSHRtbEVsZW1lbnQ9bVtcInVwZGF0ZVRhQmluZHRhSHRtbEVsZW1lbnRcIitEXSxcclxuLy8gYWRkIHRoZSBjbGFzc2VzIG1hbnVhbGx5IGxhc3Rcclxubi5hZGRDbGFzcyhcInRhLXJvb3RcIiksbS5kaXNwbGF5RWxlbWVudHMuc2Nyb2xsV2luZG93LmFkZENsYXNzKFwidGEtdGV4dCB0YS1lZGl0b3IgXCIrbS5jbGFzc2VzLnRleHRFZGl0b3IpLG0uZGlzcGxheUVsZW1lbnRzLmh0bWwuYWRkQ2xhc3MoXCJ0YS1odG1sIHRhLWVkaXRvciBcIittLmNsYXNzZXMuaHRtbEVkaXRvcik7dmFyIEc9ZnVuY3Rpb24oYSxiKXsvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogdGhpcyBpcyBvbmx5IGhlcmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiByYW5neSB3aGVyZSByYW5neS5zYXZlU2VsZWN0aW9uKCkgaGFzIGNsZWFyZWQgdGhlIHN0YXRlICovXHJcbmIhPT1oWzBdLnF1ZXJ5Q29tbWFuZFN0YXRlKGEpJiZoWzBdLmV4ZWNDb21tYW5kKGEsITEsbnVsbCl9O1xyXG4vLyB1c2VkIGluIHRoZSB0b29sYmFyIGFjdGlvbnNcclxubS5fYWN0aW9uUnVubmluZz0hMTt2YXIgSD0hMTtcclxuLy8gY2hhbmdlcyB0byB0aGUgbW9kZWwgdmFyaWFibGUgZnJvbSBvdXRzaWRlIHRoZSBodG1sL3RleHQgaW5wdXRzXHJcbi8vIGlmIG5vIG5nTW9kZWwsIHRoZW4gdGhlIG9ubHkgaW5wdXQgaXMgZnJvbSBpbnNpZGUgdGV4dC1hbmd1bGFyXHJcbmlmKG0uc3RhcnRBY3Rpb249ZnVuY3Rpb24oKXt2YXIgYj0hMSxjPSExLGQ9ITEsZT0hMTtcclxuLy9jb25zb2xlLmxvZygnQicsICRkb2N1bWVudFswXS5xdWVyeUNvbW1hbmRTdGF0ZSgnYm9sZCcpLCAnSScsICRkb2N1bWVudFswXS5xdWVyeUNvbW1hbmRTdGF0ZSgnaXRhbGljJyksICdfJywgJGRvY3VtZW50WzBdLnF1ZXJ5Q29tbWFuZFN0YXRlKCd1bmRlcmxpbmUnKSwgJ1MnLCAkZG9jdW1lbnRbMF0ucXVlcnlDb21tYW5kU3RhdGUoJ3N0cmlrZVRocm91Z2gnKSApO1xyXG4vL2NvbnNvbGUubG9nKCdCJywgX2JlZm9yZVN0YXRlQm9sZCwgJ0knLCBfYmVmb3JlU3RhdGVJdGFsaWMsICdfJywgX2JlZm9yZVN0YXRlVW5kZXJsaW5lLCAnUycsIF9iZWZvcmVTdGF0ZVN0cmlrZXRob3VnaCk7XHJcbi8vIGlmIHJhbmd5IGxpYnJhcnkgaXMgbG9hZGVkIHJldHVybiBhIGZ1bmN0aW9uIHRvIHJlbG9hZCB0aGUgY3VycmVudCBzZWxlY3Rpb25cclxuLy8gcmFuZ3kuc2F2ZVNlbGVjdGlvbigpIGNsZWFyIHRoZSBzdGF0ZSBvZiBib2xkLCBpdGFsaWMsIHVuZGVybGluZSwgc3RyaWtldGhyb3VnaFxyXG4vLyBzbyB3ZSByZXNldCB0aGVtIGhlcmUuLi4uISEhXHJcbi8vIHRoaXMgZml4ZXMgYnVncyAjNDIzLCAjMTEyOSwgIzExMDUsICM2OTMgd2hpY2ggYXJlIGFjdHVhbGx5IHJhbmd5IGJ1Z3MhXHJcbnJldHVybiBtLl9hY3Rpb25SdW5uaW5nPSEwLGI9aFswXS5xdWVyeUNvbW1hbmRTdGF0ZShcImJvbGRcIiksYz1oWzBdLnF1ZXJ5Q29tbWFuZFN0YXRlKFwiaXRhbGljXCIpLGQ9aFswXS5xdWVyeUNvbW1hbmRTdGF0ZShcInVuZGVybGluZVwiKSxlPWhbMF0ucXVlcnlDb21tYW5kU3RhdGUoXCJzdHJpa2VUaHJvdWdoXCIpLEg9YS5zYXZlU2VsZWN0aW9uKCksRyhcImJvbGRcIixiKSxHKFwiaXRhbGljXCIsYyksRyhcInVuZGVybGluZVwiLGQpLEcoXCJzdHJpa2VUaHJvdWdoXCIsZSksZnVuY3Rpb24oKXtIJiZhLnJlc3RvcmVTZWxlY3Rpb24oSCl9fSxtLmVuZEFjdGlvbj1mdW5jdGlvbigpe20uX2FjdGlvblJ1bm5pbmc9ITEsSCYmKG0uc2hvd0h0bWw/bS5kaXNwbGF5RWxlbWVudHMuaHRtbFswXS5mb2N1cygpOm0uZGlzcGxheUVsZW1lbnRzLnRleHRbMF0uZm9jdXMoKSxcclxuLy8gcmFuZ3kucmVzdG9yZVNlbGVjdGlvbihfc2F2ZWRTZWxlY3Rpb24pO1xyXG5hLnJlbW92ZU1hcmtlcnMoSCkpLEg9ITEsbS51cGRhdGVTZWxlY3RlZFN0eWxlcygpLFxyXG4vLyBvbmx5IHVwZGF0ZSBpZiBpbiB0ZXh0IG9yIFdZU0lXWUcgbW9kZVxyXG5tLnNob3dIdG1sfHxtW1widXBkYXRlVGFCaW5kdGFUZXh0RWxlbWVudFwiK0RdKCl9LFxyXG4vLyBub3RlIHRoYXQgZm9jdXNvdXQgPiBmb2N1c2luIGlzIGNhbGxlZCBldmVyeXRpbWUgd2UgY2xpY2sgYSBidXR0b24gLSBleGNlcHQgYmFkIHN1cHBvcnQ6IGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvZG9tL2V2ZW50cy9ibHVyZm9jdXMuaHRtbFxyXG4vLyBjYXNjYWRlcyB0byBkaXNwbGF5RWxlbWVudHMudGV4dCBhbmQgZGlzcGxheUVsZW1lbnRzLmh0bWwgYXV0b21hdGljYWxseS5cclxudT1mdW5jdGlvbihhKXttLmZvY3Vzc2VkPSEwLG4uYWRkQ2xhc3MobS5jbGFzc2VzLmZvY3Vzc2VkKSwvKioqKioqKiAgTk9UIEZVTkNUSU9OQUwgWUVUXHJcblx0XHRcdFx0XHRpZiAoZS50YXJnZXQuaWQgPT09ICd0YVRleHRFbGVtZW50JyArIF9zZXJpYWwpIHtcclxuXHRcdFx0XHRcdFx0Y29uc29sZS5sb2coJ19mb2N1c2luIHRhVGV4dEVsZW1lbnQnKTtcclxuXHRcdFx0XHRcdFx0Ly8gd2Ugb25seSBkbyB0aGlzIGlmIE5PVCBmb2N1c3NlZFxyXG5cdFx0XHRcdFx0XHR0ZXh0QW5ndWxhck1hbmFnZXIucmVzdG9yZUZvY3VzU2VsZWN0aW9uKHNjb3BlLl9uYW1lKTtcclxuXHRcdFx0XHRcdH1cclxuKioqKioqKi9cclxueC5mb2N1cygpLG4udHJpZ2dlckhhbmRsZXIoXCJmb2N1c1wiKSxcclxuLy8gd2UgY2FsbCBlZGl0b3JTY29wZS51cGRhdGVTZWxlY3RlZFN0eWxlcygpIGhlcmUgYmVjYXVzZSB3ZSB3YW50IHRoZSB0b29sYmFyIHRvIGJlIGZvY3Vzc2VkXHJcbi8vIGFzIHNvb24gYXMgd2UgaGF2ZSBmb2N1cy4gIE90aGVyd2lzZSB0aGlzIG9ubHkgaGFwcGVucyBvbiBtb3VzZWRvd24gb3Iga2V5ZG93biBldGMuLi5cclxuLyogaXN0YW5idWwgaWdub3JlIGVsc2U6IGRvbid0IHJ1biBpZiBhbHJlYWR5IHJ1bm5pbmcgKi9cclxubS51cGRhdGVTZWxlY3RlZFN0eWxlcyYmIW0uX2JVcGRhdGVTZWxlY3RlZFN0eWxlcyYmXHJcbi8vIHdlIGRvbid0IHNldCBlZGl0b3JTY29wZS5fYlVwZGF0ZVNlbGVjdGVkU3R5bGVzIGhlcmUsIGJlY2F1c2Ugd2UgZG8gbm90IHdhbnQgdGhlXHJcbi8vIHVwZGF0ZVNlbGVjdGVkU3R5bGVzKCkgdG8gcnVuIHR3aWNlIHdoaWNoIGl0IHdpbGwgZG8gYWZ0ZXIgMjAwIG1zZWMgaWYgd2UgaGF2ZVxyXG4vLyBzZXQgZWRpdG9yU2NvcGUuX2JVcGRhdGVTZWxlY3RlZFN0eWxlc1xyXG4vL1xyXG4vLyBXT1csIG5vcm1hbGx5IEkgd291bGQgZG8gYSBzY29wZS4kYXBwbHkgaGVyZSwgYnV0IHRoaXMgY2F1c2VzIEVSUk9ScyB3aGVuIGRvaW5nIHRlc3RzIVxyXG5jKGZ1bmN0aW9uKCl7bS51cGRhdGVTZWxlY3RlZFN0eWxlcygpfSwwKX0sbS5kaXNwbGF5RWxlbWVudHMuaHRtbC5vbihcImZvY3VzXCIsdSksbS5kaXNwbGF5RWxlbWVudHMudGV4dC5vbihcImZvY3VzXCIsdSksdj1mdW5jdGlvbihhKXsvKioqKioqKioqKioqKioqKioqIE5PVCBGVU5DVElPTkFMIFlFVFxyXG5cdFx0XHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRcdFx0dmFyIF9zID0gcmFuZ3kuZ2V0U2VsZWN0aW9uKCk7XHJcblx0XHRcdFx0XHRcdGlmIChfcykge1xyXG5cdFx0XHRcdFx0XHRcdC8vIHdlIHNhdmUgdGhlIHNlbGVjdGlvbiB3aGVuIHdlIGxvb3NlIGZvY3VzIHNvIHRoYXQgaWYgZG8gYSB3cmFwU2VsZWN0aW9uLCB0aGVcclxuXHRcdFx0XHRcdFx0XHQvLyBhcHJvcHJpYXRlIHNlbGVjdGlvbiBpbiB0aGUgZWRpdG9yIGlzIHJlc3RvcmVkIGJlZm9yZSBhY3Rpb24uXHJcblx0XHRcdFx0XHRcdFx0dmFyIF9zYXZlZEZvY3VzUmFuZ2UgPSByYW5neS5zYXZlUmFuZ2UoX3MuZ2V0UmFuZ2VBdCgwKSk7XHJcblx0XHRcdFx0XHRcdFx0dGV4dEFuZ3VsYXJNYW5hZ2VyLnNhdmVGb2N1c1NlbGVjdGlvbihzY29wZS5fbmFtZSwgX3NhdmVkRm9jdXNSYW5nZSk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH0gY2F0Y2goZXJyb3IpIHsgfVxyXG5cdFx0XHRcdFx0KioqKioqKioqKioqKioqKiovXHJcbi8vIGlmIHdlIGFyZSBOT1QgcnVubmlnIGFuIGFjdGlvbiBhbmQgaGF2ZSBOT1QgZm9jdXNzZWQgYWdhaW4gb24gdGhlIHRleHQgZXRjIHRoZW4gZmlyZSB0aGUgYmx1ciBldmVudHNcclxuLy8gdG8gcHJldmVudCBtdWx0aXBsZSBhcHBseSBlcnJvciBkZWZlciB0byBuZXh0IHNlZW1zIHRvIHdvcmsuXHJcbnJldHVybiBtLl9hY3Rpb25SdW5uaW5nfHxoWzBdLmFjdGl2ZUVsZW1lbnQ9PT1tLmRpc3BsYXlFbGVtZW50cy5odG1sWzBdfHxoWzBdLmFjdGl2ZUVsZW1lbnQ9PT1tLmRpc3BsYXlFbGVtZW50cy50ZXh0WzBdfHwobi5yZW1vdmVDbGFzcyhtLmNsYXNzZXMuZm9jdXNzZWQpLHgudW5mb2N1cygpLGMoZnVuY3Rpb24oKXttLl9iVXBkYXRlU2VsZWN0ZWRTdHlsZXM9ITEsbi50cmlnZ2VySGFuZGxlcihcImJsdXJcIiksbS5mb2N1c3NlZD0hMX0sMCkpLGEucHJldmVudERlZmF1bHQoKSwhMX0sbS5kaXNwbGF5RWxlbWVudHMuaHRtbC5vbihcImJsdXJcIix2KSxtLmRpc3BsYXlFbGVtZW50cy50ZXh0Lm9uKFwiYmx1clwiLHYpLG0uZGlzcGxheUVsZW1lbnRzLnRleHQub24oXCJwYXN0ZVwiLGZ1bmN0aW9uKGEpe24udHJpZ2dlckhhbmRsZXIoXCJwYXN0ZVwiLGEpfSksXHJcbi8vIFNldHVwIHRoZSBkZWZhdWx0IHRvb2xiYXIgdG9vbHMsIHRoaXMgd2F5IGFsbG93cyB0aGUgdXNlciB0byBhZGQgbmV3IHRvb2xzIGxpa2UgcGx1Z2lucy5cclxuLy8gVGhpcyBpcyBvbiB0aGUgZWRpdG9yIGZvciBmdXR1cmUgcHJvb2ZpbmcgaWYgd2UgZmluZCBhIGJldHRlciB3YXkgdG8gZG8gdGhpcy5cclxubS5xdWVyeUZvcm1hdEJsb2NrU3RhdGU9ZnVuY3Rpb24oYSl7XHJcbi8vICRkb2N1bWVudFswXS5xdWVyeUNvbW1hbmRWYWx1ZSgnZm9ybWF0QmxvY2snKSBlcnJvcnMgaW4gRmlyZWZveCBpZiB3ZSBjYWxsIHRoaXMgd2hlbiBmb2N1c3NlZCBvbiB0aGUgdGV4dGFyZWFcclxucmV0dXJuIW0uc2hvd0h0bWwmJmEudG9Mb3dlckNhc2UoKT09PWhbMF0ucXVlcnlDb21tYW5kVmFsdWUoXCJmb3JtYXRCbG9ja1wiKS50b0xvd2VyQ2FzZSgpfSxtLnF1ZXJ5Q29tbWFuZFN0YXRlPWZ1bmN0aW9uKGEpe1xyXG4vLyAkZG9jdW1lbnRbMF0ucXVlcnlDb21tYW5kVmFsdWUoJ2Zvcm1hdEJsb2NrJykgZXJyb3JzIGluIEZpcmVmb3ggaWYgd2UgY2FsbCB0aGlzIHdoZW4gZm9jdXNzZWQgb24gdGhlIHRleHRhcmVhXHJcbnJldHVybiBtLnNob3dIdG1sP1wiXCI6aFswXS5xdWVyeUNvbW1hbmRTdGF0ZShhKX0sbS5zd2l0Y2hWaWV3PWZ1bmN0aW9uKCl7bS5zaG93SHRtbD0hbS5zaG93SHRtbCxpLmVuYWJsZWQoITEsbS5kaXNwbGF5RWxlbWVudHMuaHRtbCksaS5lbmFibGVkKCExLG0uZGlzcGxheUVsZW1lbnRzLnRleHQpLFxyXG4vL1Nob3cgdGhlIEhUTUwgdmlld1xyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogbmdNb2RlbCBleGlzdHMgY2hlY2sgKi9cclxuLyogVEhJUyBpcyBub3QgdGhlIGNvcnJlY3QgdGhpbmcgdG8gZG8sIGhlcmUuLi4uXHJcbiAgIFRoZSBuZ01vZGVsIGlzIGNvcnJlY3QsIGJ1dCBpdCBpcyBub3QgZm9ybWF0dGVkIGFzIHRoZSB1c2VyIGFzIGRvbmUgaXQuLi5cclxuXHRcdFx0XHRcdHZhciBfbW9kZWw7XHJcblx0XHRcdFx0XHRpZiAobmdNb2RlbCkge1xyXG5cdFx0XHRcdFx0XHRfbW9kZWwgPSBuZ01vZGVsLiR2aWV3VmFsdWU7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRfbW9kZWwgPSBzY29wZS5odG1sO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0dmFyIF9odG1sID0gc2NvcGUuZGlzcGxheUVsZW1lbnRzLmh0bWxbMF0udmFsdWU7XHJcblx0XHRcdFx0XHRpZiAoZ2V0RG9tRnJvbUh0bWwoX2h0bWwpLmNoaWxkRWxlbWVudENvdW50ICE9PSBnZXREb21Gcm9tSHRtbChfbW9kZWwpLmNoaWxkRWxlbWVudENvdW50KSB7XHJcblx0XHRcdFx0XHRcdC8vIHRoZSBtb2RlbCBhbmQgdGhlIGh0bWwgZG8gbm90IGFncmVlXHJcblx0XHRcdFx0XHRcdC8vIHRoZXkgY2FuIGdldCBvdXQgb2Ygc3luYyBhbmQgd2hlbiB0aGV5IGRvLCB3ZSBjb3JyZWN0IHRoYXQgaGVyZS4uLlxyXG5cdFx0XHRcdFx0XHRzY29wZS5kaXNwbGF5RWxlbWVudHMuaHRtbC52YWwoX21vZGVsKTtcclxuXHRcdFx0XHRcdH1cclxuKi9cclxubS5zaG93SHRtbD9cclxuLy9kZWZlciB1bnRpbCB0aGUgZWxlbWVudCBpcyB2aXNpYmxlXHJcbmMoZnVuY3Rpb24oKXtcclxuLy8gWzBdIGRlcmVmZXJlbmNlcyB0aGUgRE9NIG9iamVjdCBmcm9tIHRoZSBhbmd1bGFyLmVsZW1lbnRcclxucmV0dXJuIGkuZW5hYmxlZCghMCxtLmRpc3BsYXlFbGVtZW50cy5odG1sKSxpLmVuYWJsZWQoITAsbS5kaXNwbGF5RWxlbWVudHMudGV4dCksbS5kaXNwbGF5RWxlbWVudHMuaHRtbFswXS5mb2N1cygpfSwxMDApOlxyXG4vL1Nob3cgdGhlIFdZU0lXWUcgdmlld1xyXG4vL2RlZmVyIHVudGlsIHRoZSBlbGVtZW50IGlzIHZpc2libGVcclxuYyhmdW5jdGlvbigpe1xyXG4vLyBbMF0gZGVyZWZlcmVuY2VzIHRoZSBET00gb2JqZWN0IGZyb20gdGhlIGFuZ3VsYXIuZWxlbWVudFxyXG5yZXR1cm4gaS5lbmFibGVkKCEwLG0uZGlzcGxheUVsZW1lbnRzLmh0bWwpLGkuZW5hYmxlZCghMCxtLmRpc3BsYXlFbGVtZW50cy50ZXh0KSxtLmRpc3BsYXlFbGVtZW50cy50ZXh0WzBdLmZvY3VzKCl9LDEwMCl9LG8ubmdNb2RlbCl7dmFyIEk9ITA7cC4kcmVuZGVyPWZ1bmN0aW9uKCl7aWYoSSl7XHJcbi8vIHdlIG5lZWQgdGhpcyBmaXJzdFJ1biB0byBzZXQgdGhlIG9yaWdpbmFsQ29udGVudHMgb3RoZXJ3aXNlIGl0IGdldHMgb3ZlcnJpZGVkIGJ5IHRoZSBzZXR0aW5nIG9mIG5nTW9kZWwgdG8gdW5kZWZpbmVkIGZyb20gTmFOXHJcbkk9ITE7XHJcbi8vIGlmIHZpZXcgdmFsdWUgaXMgbnVsbCBvciB1bmRlZmluZWQgaW5pdGlhbGx5IGFuZCB0aGVyZSB3YXMgb3JpZ2luYWwgY29udGVudCwgc2V0IHRvIHRoZSBvcmlnaW5hbCBjb250ZW50XHJcbnZhciBhPW0uJHBhcmVudC4kZXZhbChvLm5nTW9kZWwpO3ZvaWQgMCE9PWEmJm51bGwhPT1hfHwhd3x8XCJcIj09PXd8fFxyXG4vLyBvbiBwYXNzaW5nIHRocm91Z2ggdG8gdGFCaW5kIGl0IHdpbGwgYmUgc2FuaXRpc2VkXHJcbnAuJHNldFZpZXdWYWx1ZSh3KX1tLmRpc3BsYXlFbGVtZW50cy5mb3JtaW5wdXQudmFsKHAuJHZpZXdWYWx1ZSksXHJcbi8vIGlmIHRoZSBlZGl0b3JzIGFyZW4ndCBmb2N1c2VkIHRoZXkgbmVlZCB0byBiZSB1cGRhdGVkLCBvdGhlcndpc2UgdGhleSBhcmUgZG9pbmcgdGhlIHVwZGF0aW5nXHJcbm0uaHRtbD1wLiR2aWV3VmFsdWV8fFwiXCJ9LFxyXG4vLyB0cmlnZ2VyIHRoZSB2YWxpZGF0aW9uIGNhbGxzXHJcbm4uYXR0cihcInJlcXVpcmVkXCIpJiYocC4kdmFsaWRhdG9ycy5yZXF1aXJlZD1mdW5jdGlvbihhLGIpe3ZhciBjPWF8fGI7cmV0dXJuISghY3x8XCJcIj09PWMudHJpbSgpKX0pfWVsc2VcclxuLy8gaWYgbm8gbmdNb2RlbCB0aGVuIHVwZGF0ZSBmcm9tIHRoZSBjb250ZW50cyBvZiB0aGUgb3JpZ2lvbmFsIGh0bWwuXHJcbm0uZGlzcGxheUVsZW1lbnRzLmZvcm1pbnB1dC52YWwodyksbS5odG1sPXc7aWYoXHJcbi8vIGNoYW5nZXMgZnJvbSB0YUJpbmQgYmFjayB1cCB0byBoZXJlXHJcbm0uJHdhdGNoKFwiaHRtbFwiLGZ1bmN0aW9uKGEsYil7YSE9PWImJihvLm5nTW9kZWwmJnAuJHZpZXdWYWx1ZSE9PWEmJnAuJHNldFZpZXdWYWx1ZShhKSxtLmRpc3BsYXlFbGVtZW50cy5mb3JtaW5wdXQudmFsKGEpKX0pLG8udGFUYXJnZXRUb29sYmFycyl4PWcucmVnaXN0ZXJFZGl0b3IobS5fbmFtZSxtLG8udGFUYXJnZXRUb29sYmFycy5zcGxpdChcIixcIikpO2Vsc2V7dmFyIEo9YW5ndWxhci5lbGVtZW50KCc8ZGl2IHRleHQtYW5ndWxhci10b29sYmFyIG5hbWU9XCJ0ZXh0QW5ndWxhclRvb2xiYXInK0QrJ1wiPicpO1xyXG4vLyBwYXNzdGhyb3VnaCBpbml0IG9mIHRvb2xiYXIgb3B0aW9uc1xyXG5vLnRhVG9vbGJhciYmSi5hdHRyKFwidGEtdG9vbGJhclwiLG8udGFUb29sYmFyKSxvLnRhVG9vbGJhckNsYXNzJiZKLmF0dHIoXCJ0YS10b29sYmFyLWNsYXNzXCIsby50YVRvb2xiYXJDbGFzcyksby50YVRvb2xiYXJHcm91cENsYXNzJiZKLmF0dHIoXCJ0YS10b29sYmFyLWdyb3VwLWNsYXNzXCIsby50YVRvb2xiYXJHcm91cENsYXNzKSxvLnRhVG9vbGJhckJ1dHRvbkNsYXNzJiZKLmF0dHIoXCJ0YS10b29sYmFyLWJ1dHRvbi1jbGFzc1wiLG8udGFUb29sYmFyQnV0dG9uQ2xhc3MpLG8udGFUb29sYmFyQWN0aXZlQnV0dG9uQ2xhc3MmJkouYXR0cihcInRhLXRvb2xiYXItYWN0aXZlLWJ1dHRvbi1jbGFzc1wiLG8udGFUb29sYmFyQWN0aXZlQnV0dG9uQ2xhc3MpLG8udGFGb2N1c3NlZENsYXNzJiZKLmF0dHIoXCJ0YS1mb2N1c3NlZC1jbGFzc1wiLG8udGFGb2N1c3NlZENsYXNzKSxuLnByZXBlbmQoSiksYihKKShtLiRwYXJlbnQpLHg9Zy5yZWdpc3RlckVkaXRvcihtLl9uYW1lLG0sW1widGV4dEFuZ3VsYXJUb29sYmFyXCIrRF0pfW0uJG9uKFwiJGRlc3Ryb3lcIixmdW5jdGlvbigpe2cudW5yZWdpc3RlckVkaXRvcihtLl9uYW1lKSxhbmd1bGFyLmVsZW1lbnQod2luZG93KS5vZmYoXCJibHVyXCIpfSksXHJcbi8vIGNhdGNoIGVsZW1lbnQgc2VsZWN0IGV2ZW50IGFuZCBwYXNzIHRvIHRvb2xiYXIgdG9vbHNcclxubS4kb24oXCJ0YS1lbGVtZW50LXNlbGVjdFwiLGZ1bmN0aW9uKGEsYil7eC50cmlnZ2VyRWxlbWVudFNlbGVjdChhLGIpJiZtW1wicmVBcHBseU9uU2VsZWN0b3JIYW5kbGVyc3RhVGV4dEVsZW1lbnRcIitEXSgpfSksbS4kb24oXCJ0YS1kcm9wLWV2ZW50XCIsZnVuY3Rpb24oYSxiLGQsZSl7ZSYmZS5maWxlcyYmZS5maWxlcy5sZW5ndGg+MD8obS5kaXNwbGF5RWxlbWVudHMudGV4dFswXS5mb2N1cygpLGFuZ3VsYXIuZm9yRWFjaChlLmZpbGVzLGZ1bmN0aW9uKGEpe1xyXG4vLyB0YWtpbmcgYWR2YW50YWdlIG9mIGJvb2xlYW4gZXhlY3V0aW9uLCBpZiB0aGUgZmlsZURyb3BIYW5kbGVyIHJldHVybnMgdHJ1ZSwgbm90aGluZyBlbHNlIGFmdGVyIGl0IGlzIGV4ZWN1dGVkXHJcbi8vIElmIGl0IGlzIGZhbHNlIHRoZW4gZXhlY3V0ZSB0aGUgZGVmYXVsdEZpbGVEcm9wSGFuZGxlciBpZiB0aGUgZmlsZURyb3BIYW5kbGVyIGlzIE5PVCB0aGUgZGVmYXVsdCBvbmVcclxuLy8gT25jZSBvbmUgb2YgdGhlc2UgaGFzIGJlZW4gZXhlY3V0ZWQgd3JhcCB0aGUgcmVzdWx0IGFzIGEgcHJvbWlzZSwgaWYgdW5kZWZpbmVkIG9yIHZhcmlhYmxlIHVwZGF0ZSB0aGUgdGFCaW5kLCBlbHNlIHdlIHNob3VsZCB3YWl0IGZvciB0aGUgcHJvbWlzZVxyXG50cnl7ay53aGVuKG0uZmlsZURyb3BIYW5kbGVyKGEsbS53cmFwU2VsZWN0aW9uKXx8bS5maWxlRHJvcEhhbmRsZXIhPT1tLmRlZmF1bHRGaWxlRHJvcEhhbmRsZXImJmsud2hlbihtLmRlZmF1bHRGaWxlRHJvcEhhbmRsZXIoYSxtLndyYXBTZWxlY3Rpb24pKSkudGhlbihmdW5jdGlvbigpe21bXCJ1cGRhdGVUYUJpbmR0YVRleHRFbGVtZW50XCIrRF0oKX0pfWNhdGNoKGEpe2ouZXJyb3IoYSl9fSksZC5wcmV2ZW50RGVmYXVsdCgpLGQuc3RvcFByb3BhZ2F0aW9uKCkpOmMoZnVuY3Rpb24oKXttW1widXBkYXRlVGFCaW5kdGFUZXh0RWxlbWVudFwiK0RdKCl9LDApfSksXHJcbi8vIHRoZSBmb2xsb3dpbmcgaXMgZm9yIGFwcGx5aW5nIHRoZSBhY3RpdmUgc3RhdGVzIHRvIHRoZSB0b29scyB0aGF0IHN1cHBvcnQgaXRcclxubS5fYlVwZGF0ZVNlbGVjdGVkU3R5bGVzPSExLC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBicm93c2VyIHdpbmRvdy90YWIgbGVhdmUgY2hlY2sgKi9cclxuYW5ndWxhci5lbGVtZW50KHdpbmRvdykub24oXCJibHVyXCIsZnVuY3Rpb24oKXttLl9iVXBkYXRlU2VsZWN0ZWRTdHlsZXM9ITEsbS5mb2N1c3NlZD0hMX0pLFxyXG4vLyBsb29wIHRocm91Z2ggYWxsIHRoZSB0b29scyBwb2xsaW5nIHRoZWlyIGFjdGl2ZVN0YXRlIGZ1bmN0aW9uIGlmIGl0IGV4aXN0c1xyXG5tLnVwZGF0ZVNlbGVjdGVkU3R5bGVzPWZ1bmN0aW9uKCl7dmFyIGE7LyogaXN0YW5idWwgaWdub3JlIG5leHQ6IFRoaXMgY2hlY2sgaXMgdG8gZW5zdXJlIG11bHRpcGxlIHRpbWVvdXRzIGRvbid0IGV4aXN0ICovXHJcbkEmJmMuY2FuY2VsKEEpLFxyXG4vLyB0ZXN0IGlmIHRoZSBjb21tb24gZWxlbWVudCBJU04nVCB0aGUgcm9vdCB0YS10ZXh0IG5vZGVcclxudm9pZCAwIT09KGE9ZS5nZXRTZWxlY3Rpb25FbGVtZW50KCkpJiZhLnBhcmVudE5vZGUhPT1tLmRpc3BsYXlFbGVtZW50cy50ZXh0WzBdP3gudXBkYXRlU2VsZWN0ZWRTdHlsZXMoYW5ndWxhci5lbGVtZW50KGEpKTp4LnVwZGF0ZVNlbGVjdGVkU3R5bGVzKCksXHJcbi8vIHVzZWQgdG8gdXBkYXRlIHRoZSBhY3RpdmUgc3RhdGUgd2hlbiBhIGtleSBpcyBoZWxkIGRvd24sIGllIHRoZSBsZWZ0IGFycm93XHJcbi8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlOiBicm93c2VyIG9ubHkgY2hlY2sgKi9cclxubS5fYlVwZGF0ZVNlbGVjdGVkU3R5bGVzJiYoQT1jKG0udXBkYXRlU2VsZWN0ZWRTdHlsZXMsMjAwKSl9LFxyXG4vLyBzdGFydCB1cGRhdGluZyBvbiBrZXlkb3duXHJcbnE9ZnVuY3Rpb24oKXsvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogaWUgY2F0Y2ggKi9cclxuLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IGllIGNhdGNoICovXHJcbi8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlOiBkb24ndCBydW4gaWYgYWxyZWFkeSBydW5uaW5nICovXHJcbnJldHVybiBtLmZvY3Vzc2VkP3ZvaWQobS5fYlVwZGF0ZVNlbGVjdGVkU3R5bGVzfHwobS5fYlVwZGF0ZVNlbGVjdGVkU3R5bGVzPSEwLG0uJGFwcGx5KGZ1bmN0aW9uKCl7bS51cGRhdGVTZWxlY3RlZFN0eWxlcygpfSkpKTp2b2lkKG0uX2JVcGRhdGVTZWxlY3RlZFN0eWxlcz0hMSl9LG0uZGlzcGxheUVsZW1lbnRzLmh0bWwub24oXCJrZXlkb3duXCIscSksbS5kaXNwbGF5RWxlbWVudHMudGV4dC5vbihcImtleWRvd25cIixxKSxcclxuLy8gc3RvcCB1cGRhdGluZyBvbiBrZXkgdXAgYW5kIHVwZGF0ZSB0aGUgZGlzcGxheS9tb2RlbFxyXG5yPWZ1bmN0aW9uKCl7bS5fYlVwZGF0ZVNlbGVjdGVkU3R5bGVzPSExfSxtLmRpc3BsYXlFbGVtZW50cy5odG1sLm9uKFwia2V5dXBcIixyKSxtLmRpc3BsYXlFbGVtZW50cy50ZXh0Lm9uKFwia2V5dXBcIixyKSxcclxuLy8gc3RvcCB1cGRhdGluZyBvbiBrZXkgdXAgYW5kIHVwZGF0ZSB0aGUgZGlzcGxheS9tb2RlbFxyXG5zPWZ1bmN0aW9uKGEsYil7XHJcbi8vIGJ1ZyBmaXggZm9yIEZpcmVmb3guICBJZiB3ZSBhcmUgc2VsZWN0aW5nIGEgPGE+IGFscmVhZHksIGFueSBjaGFyYWN0ZXJzIHdpbGxcclxuLy8gYmUgYWRkZWQgd2l0aGluIHRoZSA8YT4gd2hpY2ggaXMgYmFkIVxyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogZG9uJ3Qgc2VlIGhvdyB0byB0ZXN0IHRoaXMuLi4gKi9cclxuaWYoZS5nZXRTZWxlY3Rpb24pe3ZhciBjPWUuZ2V0U2VsZWN0aW9uKCk7XHJcbi8vIGluIGEgd2VpcmQgY2FzZSAoY2FuJ3QgcmVwcm9kdWNlKSB0YVNlbGVjdGlvbi5nZXRTZWxlY3Rpb25FbGVtZW50KCkgY2FuIGJlIHVuZGVmaW5lZCEhXHJcbi8vIHRoaXMgY29tZXMgZnJvbSByYW5nZS5jb21tb25BbmNlc3RvckNvbnRhaW5lcjtcclxuLy8gc28gSSBjaGVjayBmb3IgdGhpcyBoZXJlIHdoaWNoIGZpeGVzIHRoZSBlcnJvciBjYXNlXHJcbmUuZ2V0U2VsZWN0aW9uRWxlbWVudCgpJiZcImFcIj09PWUuZ2V0U2VsZWN0aW9uRWxlbWVudCgpLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkmJihcclxuLy8gY2hlY2sgYW5kIHNlZSBpZiB3ZSBhcmUgYXQgdGhlIGVkZ2Ugb2YgdGhlIDxhPlxyXG4zPT09Yy5zdGFydC5lbGVtZW50Lm5vZGVUeXBlJiZjLnN0YXJ0LmVsZW1lbnQudGV4dENvbnRlbnQubGVuZ3RoPT09Yy5lbmQub2Zmc2V0JiZcclxuLy8gd2UgYXJlIGF0IHRoZSBlbmQgb2YgdGhlIDxhPiEhIVxyXG4vLyBzbyBtb3ZlIHRoZSBzZWxlY3Rpb24gdG8gYWZ0ZXIgdGhlIDxhPiEhXHJcbmUuc2V0U2VsZWN0aW9uQWZ0ZXJFbGVtZW50KGUuZ2V0U2VsZWN0aW9uRWxlbWVudCgpKSwzPT09Yy5zdGFydC5lbGVtZW50Lm5vZGVUeXBlJiYwPT09Yy5zdGFydC5vZmZzZXQmJlxyXG4vLyB3ZSBhcmUgYXQgdGhlIHN0YXJ0IG9mIHRoZSA8YT4hISFcclxuLy8gc28gbW92ZSB0aGUgc2VsZWN0aW9uIGJlZm9yZSB0aGUgPGE+ISFcclxuZS5zZXRTZWxlY3Rpb25CZWZvcmVFbGVtZW50KGUuZ2V0U2VsZWN0aW9uRWxlbWVudCgpKSl9LyogaXN0YW5idWwgaWdub3JlIGVsc2U6IHRoaXMgaXMgZm9yIGNhdGNoaW5nIHRoZSBqcUxpdGUgdGVzdGluZyovXHJcbmImJmFuZ3VsYXIuZXh0ZW5kKGEsYiksbS4kYXBwbHkoZnVuY3Rpb24oKXtpZih4LnNlbmRLZXlDb21tYW5kKGEpKS8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlOiBkb24ndCBydW4gaWYgYWxyZWFkeSBydW5uaW5nICovXHJcbnJldHVybiBtLl9iVXBkYXRlU2VsZWN0ZWRTdHlsZXN8fG0udXBkYXRlU2VsZWN0ZWRTdHlsZXMoKSxhLnByZXZlbnREZWZhdWx0KCksITF9KX0sbS5kaXNwbGF5RWxlbWVudHMuaHRtbC5vbihcImtleXByZXNzXCIscyksbS5kaXNwbGF5RWxlbWVudHMudGV4dC5vbihcImtleXByZXNzXCIscyksXHJcbi8vIHVwZGF0ZSB0aGUgdG9vbGJhciBhY3RpdmUgc3RhdGVzIHdoZW4gd2UgY2xpY2sgc29tZXdoZXJlIGluIHRoZSB0ZXh0L2h0bWwgYm94ZWRcclxudD1mdW5jdGlvbigpe1xyXG4vLyBlbnN1cmUgb25seSBvbmUgZXhlY3V0aW9uIG9mIHVwZGF0ZVNlbGVjdGVkU3R5bGVzKClcclxubS5fYlVwZGF0ZVNlbGVjdGVkU3R5bGVzPSExLFxyXG4vLyBmb3Igc29tZSByZWFzb24sIHVubGVzcyB3ZSBkbyBhICR0aW1lb3V0IGhlcmUsIGFmdGVyIGEgX21vdXNldXAgd2hlbiB0aGUgbGluZSBpc1xyXG4vLyBoaWdobGlnaHRlZCwgYW5kIGluc3RlYWQgdXNlIGEgc2NvcGUuJGFwcGx5KGZ1bmN0aW9uKCl7IHNjb3BlLnVwZGF0ZVNlbGVjdGVkU3R5bGVzKCk7IH0pO1xyXG4vLyBkb2Vzbid0IHdvcmsgcHJvcGVybHksIHNvIHdlIHJlcGxhY2VkIHRoaXMgd2l0aDpcclxuLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IG5vdCB0ZXN0ZWQgICovXHJcbmMoZnVuY3Rpb24oKXttLnVwZGF0ZVNlbGVjdGVkU3R5bGVzKCl9LDApfSxtLmRpc3BsYXlFbGVtZW50cy5odG1sLm9uKFwibW91c2V1cFwiLHQpLG0uZGlzcGxheUVsZW1lbnRzLnRleHQub24oXCJtb3VzZXVwXCIsdCl9fX1dKSx1LnNlcnZpY2UoXCJ0ZXh0QW5ndWxhck1hbmFnZXJcIixbXCJ0YVRvb2xFeGVjdXRlQWN0aW9uXCIsXCJ0YVRvb2xzXCIsXCJ0YVJlZ2lzdGVyVG9vbFwiLFwiJGludGVydmFsXCIsXCIkcm9vdFNjb3BlXCIsXCIkbG9nXCIsZnVuY3Rpb24oYSxiLGMsZCxlLGcpe1xyXG4vLyB0aGlzIHNlcnZpY2UgaXMgdXNlZCB0byBtYW5hZ2UgYWxsIHRleHRBbmd1bGFyIGVkaXRvcnMgYW5kIHRvb2xiYXJzLlxyXG4vLyBBbGwgcHVibGljbHkgcHVibGlzaGVkIGZ1bmN0aW9ucyB0aGF0IG1vZGlmeS9uZWVkIHRvIGFjY2VzcyB0aGUgdG9vbGJhciBvciBlZGl0b3Igc2NvcGVzIHNob3VsZCBiZSBpbiBoZXJlXHJcbi8vIHRoZXNlIGNvbnRhaW4gcmVmZXJlbmNlcyB0byBhbGwgdGhlIGVkaXRvcnMgYW5kIHRvb2xiYXJzIHRoYXQgaGF2ZSBiZWVuIGluaXRpYWxpc2VkIGluIHRoaXMgYXBwXHJcbnZhciBoLGk9e30saj17fSxrPTAsbD1mdW5jdGlvbihhKXthbmd1bGFyLmZvckVhY2goaixmdW5jdGlvbihiKXtiLmVkaXRvckZ1bmN0aW9ucy51cGRhdGVTZWxlY3RlZFN0eWxlcyhhKX0pfSxtPTUwLG49ZnVuY3Rpb24oKXtrPURhdGUubm93KCksLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IHNldHVwIGEgb25lIHRpbWUgdXBkYXRlU3R5bGVzKCkgKi9cclxuaD1kKGZ1bmN0aW9uKCl7bCgpLGg9dm9pZCAwfSxtLDEpfTsvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogbWFrZSBzdXJlIGNsZWFuIHVwIG9uIGRlc3Ryb3kgKi9cclxuZS4kb24oXCJkZXN0cm95XCIsZnVuY3Rpb24oKXtoJiYoZC5jYW5jZWwoaCksaD12b2lkIDApfSk7dmFyIG89ZnVuY3Rpb24oKXtNYXRoLmFicyhEYXRlLm5vdygpLWspPm0mJlxyXG4vLyB3ZSBoYXZlIGFscmVhZHkgdHJpZ2dlcmVkIHRoZSB1cGRhdGVTdHlsZXMgYSBsb25nIHRpbWUgYmFjay4uLiBzbyBzZXR1cCBpdCBhZ2Fpbi4uLlxyXG5uKCl9O1xyXG4vLyB3aGVuIHdlIGZvY3VzIGludG8gYSB0b29sYmFyLCB3ZSBuZWVkIHRvIHNldCB0aGUgVE9PTEJBUidzICRwYXJlbnQgdG8gYmUgdGhlIHRvb2xiYXJzIGl0J3MgbGlua2VkIHRvLlxyXG4vLyBXZSBhbHNvIG5lZWQgdG8gc2V0IHRoZSB0b29scyB0byBiZSB1cGRhdGVkIHRvIGJlIHRoZSB0b29sYmFycy4uLlxyXG5yZXR1cm57XHJcbi8vIHJlZ2lzdGVyIGFuIGVkaXRvciBhbmQgdGhlIHRvb2xiYXJzIHRoYXQgaXQgaXMgYWZmZWN0ZWQgYnlcclxucmVnaXN0ZXJFZGl0b3I6ZnVuY3Rpb24oYyxkLGUpe1xyXG4vLyBOT1RFOiBuYW1lID09PSBlZGl0b3JTY29wZS5fbmFtZVxyXG4vLyB0YXJnZXRUb29sYmFycyBpcyBhbiBbXSBvZiAndG9vbGJhciBuYW1lJ3NcclxuLy8gdGFyZ2V0VG9vbGJhcnMgYXJlIG9wdGlvbmFsLCB3ZSBkb24ndCByZXF1aXJlIGEgdG9vbGJhciB0byBmdW5jdGlvblxyXG5pZighY3x8XCJcIj09PWMpdGhyb3dcInRleHRBbmd1bGFyIEVycm9yOiBBbiBlZGl0b3IgcmVxdWlyZXMgYSBuYW1lXCI7aWYoIWQpdGhyb3dcInRleHRBbmd1bGFyIEVycm9yOiBBbiBlZGl0b3IgcmVxdWlyZXMgYSBzY29wZVwiO2lmKGpbY10pdGhyb3cndGV4dEFuZ3VsYXIgRXJyb3I6IEFuIEVkaXRvciB3aXRoIG5hbWUgXCInK2MrJ1wiIGFscmVhZHkgZXhpc3RzJztyZXR1cm4galtjXT17c2NvcGU6ZCx0b29sYmFyczplLFxyXG4vLyB0b29sYmFyU2NvcGVzIHVzZWQgYnkgdGhpcyBlZGl0b3JcclxudG9vbGJhclNjb3BlczpbXSxfcmVnaXN0ZXJUb29sYmFyU2NvcGU6ZnVuY3Rpb24oYSl7XHJcbi8vIGFkZCB0byB0aGUgbGlzdCBsYXRlXHJcbnRoaXMudG9vbGJhcnMuaW5kZXhPZihhLm5hbWUpPj0wJiZcclxuLy8gaWYgdGhpcyB0b29sYmFyU2NvcGUgaXMgYmVpbmcgdXNlZCBieSB0aGlzIGVkaXRvciB3ZSBhZGQgaXQgYXMgb25lIG9mIHRoZSBzY29wZXNcclxudGhpcy50b29sYmFyU2NvcGVzLnB1c2goYSl9LFxyXG4vLyB0aGlzIGlzIGEgc3VpdGUgb2YgZnVuY3Rpb25zIHRoZSBlZGl0b3Igc2hvdWxkIHVzZSB0byB1cGRhdGUgYWxsIGl0J3MgbGlua2VkIHRvb2xiYXJzXHJcbmVkaXRvckZ1bmN0aW9uczp7ZGlzYWJsZTpmdW5jdGlvbigpe1xyXG4vLyBkaXNhYmxlIGFsbCBsaW5rZWQgdG9vbGJhcnNcclxuYW5ndWxhci5mb3JFYWNoKGpbY10udG9vbGJhclNjb3BlcyxmdW5jdGlvbihhKXthLmRpc2FibGVkPSEwfSl9LGVuYWJsZTpmdW5jdGlvbigpe1xyXG4vLyBlbmFibGUgYWxsIGxpbmtlZCB0b29sYmFyc1xyXG5hbmd1bGFyLmZvckVhY2goaltjXS50b29sYmFyU2NvcGVzLGZ1bmN0aW9uKGEpe2EuZGlzYWJsZWQ9ITF9KX0sZm9jdXM6ZnVuY3Rpb24oKXtcclxuLy8gdGhpcyBzaG91bGQgYmUgY2FsbGVkIHdoZW4gdGhlIGVkaXRvciBpcyBmb2N1c3NlZFxyXG5hbmd1bGFyLmZvckVhY2goaltjXS50b29sYmFyU2NvcGVzLGZ1bmN0aW9uKGEpe2EuX3BhcmVudD1kLGEuZGlzYWJsZWQ9ITEsYS5mb2N1c3NlZD0hMH0pLGQuZm9jdXNzZWQ9ITB9LHVuZm9jdXM6ZnVuY3Rpb24oKXtcclxuLy8gdGhpcyBzaG91bGQgYmUgY2FsbGVkIHdoZW4gdGhlIGVkaXRvciBiZWNvbWVzIHVuZm9jdXNzZWRcclxuYW5ndWxhci5mb3JFYWNoKGpbY10udG9vbGJhclNjb3BlcyxmdW5jdGlvbihhKXthLmRpc2FibGVkPSEwLGEuZm9jdXNzZWQ9ITF9KSxkLmZvY3Vzc2VkPSExfSx1cGRhdGVTZWxlY3RlZFN0eWxlczpmdW5jdGlvbihhKXtcclxuLy8gdXBkYXRlIHRoZSBhY3RpdmUgc3RhdGUgb2YgYWxsIGJ1dHRvbnMgb24gbGlrZWQgdG9vbGJhcnNcclxuYW5ndWxhci5mb3JFYWNoKGpbY10udG9vbGJhclNjb3BlcyxmdW5jdGlvbihiKXthbmd1bGFyLmZvckVhY2goYi50b29scyxmdW5jdGlvbihjKXtjLmFjdGl2ZVN0YXRlJiYoYi5fcGFyZW50PWQsXHJcbi8vIHNlbGVjdGVkRWxlbWVudCBtYXkgYmUgdW5kZWZpbmVkIGlmIG5vdGhpbmcgc2VsZWN0ZWRcclxuYy5hY3RpdmU9Yy5hY3RpdmVTdGF0ZShhKSl9KX0pfSxzZW5kS2V5Q29tbWFuZDpmdW5jdGlvbihlKXtcclxuLy8gd2UgcmV0dXJuIHRydWUgaWYgd2UgYXBwbGllZCBhbiBhY3Rpb24sIGZhbHNlIG90aGVyd2lzZVxyXG52YXIgZj0hMTtyZXR1cm4oZS5jdHJsS2V5fHxlLm1ldGFLZXl8fGUuc3BlY2lhbEtleSkmJmFuZ3VsYXIuZm9yRWFjaChiLGZ1bmN0aW9uKGIsZyl7aWYoYi5jb21tYW5kS2V5Q29kZSYmKGIuY29tbWFuZEtleUNvZGU9PT1lLndoaWNofHxiLmNvbW1hbmRLZXlDb2RlPT09ZS5zcGVjaWFsS2V5KSlmb3IodmFyIGg9MDtoPGpbY10udG9vbGJhclNjb3Blcy5sZW5ndGg7aCsrKWlmKHZvaWQgMCE9PWpbY10udG9vbGJhclNjb3Blc1toXS50b29sc1tnXSl7YS5jYWxsKGpbY10udG9vbGJhclNjb3Blc1toXS50b29sc1tnXSxkKSxmPSEwO2JyZWFrfX0pLGZ9LHRyaWdnZXJFbGVtZW50U2VsZWN0OmZ1bmN0aW9uKGEsZSl7XHJcbi8vIHNlYXJjaCB0aHJvdWdoIHRoZSB0YVRvb2xzIHRvIHNlZSBpZiBhIG1hdGNoIGZvciB0aGUgdGFnIGlzIG1hZGUuXHJcbi8vIGlmIHRoZXJlIGlzLCBzZWUgaWYgdGhlIHRvb2wgaXMgb24gYSByZWdpc3RlcmVkIHRvb2xiYXIgYW5kIG5vdCBkaXNhYmxlZC5cclxuLy8gTk9URTogVGhpcyBjYW4gdHJpZ2dlciBvbiBNVUxUSVBMRSB0b29scyBzaW11bHRhbmVvdXNseS5cclxudmFyIGY9ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9ITAsZD0wO2Q8Yi5sZW5ndGg7ZCsrKWM9YyYmYS5hdHRyKGJbZF0pO3JldHVybiBjfSxnPVtdLGg9e30saT0hMTtlPWFuZ3VsYXIuZWxlbWVudChlKTtcclxuLy8gZ2V0IGFsbCB2YWxpZCB0b29scyBieSBlbGVtZW50IG5hbWUsIGtlZXAgdHJhY2sgaWYgb25lIG1hdGNoZXMgdGhlXHJcbnZhciBrPSExO1xyXG4vLyBSdW4gdGhlIGFjdGlvbnMgb24gdGhlIGZpcnN0IHZpc2libGUgZmlsdGVyZWQgdG9vbCBvbmx5XHJcbmlmKGFuZ3VsYXIuZm9yRWFjaChiLGZ1bmN0aW9uKGEsYil7YS5vbkVsZW1lbnRTZWxlY3QmJmEub25FbGVtZW50U2VsZWN0LmVsZW1lbnQmJmEub25FbGVtZW50U2VsZWN0LmVsZW1lbnQudG9Mb3dlckNhc2UoKT09PWVbMF0udGFnTmFtZS50b0xvd2VyQ2FzZSgpJiYoIWEub25FbGVtZW50U2VsZWN0LmZpbHRlcnx8YS5vbkVsZW1lbnRTZWxlY3QuZmlsdGVyKGUpKSYmKFxyXG4vLyB0aGlzIHNob3VsZCBvbmx5IGVuZCB1cCB0cnVlIGlmIHRoZSBlbGVtZW50IG1hdGNoZXMgdGhlIG9ubHkgYXR0cmlidXRlc1xyXG5rPWt8fGFuZ3VsYXIuaXNBcnJheShhLm9uRWxlbWVudFNlbGVjdC5vbmx5V2l0aEF0dHJzKSYmZihlLGEub25FbGVtZW50U2VsZWN0Lm9ubHlXaXRoQXR0cnMpLGEub25FbGVtZW50U2VsZWN0Lm9ubHlXaXRoQXR0cnMmJiFmKGUsYS5vbkVsZW1lbnRTZWxlY3Qub25seVdpdGhBdHRycyl8fChoW2JdPWEpKX0pLFxyXG4vLyBpZiB3ZSBtYXRjaGVkIGF0dHJpYnV0ZXMgdG8gZmlsdGVyIG9uLCB0aGVuIGZpbHRlciwgZWxzZSBjb250aW51ZVxyXG5rPyhhbmd1bGFyLmZvckVhY2goaCxmdW5jdGlvbihhLGIpe2Eub25FbGVtZW50U2VsZWN0Lm9ubHlXaXRoQXR0cnMmJmYoZSxhLm9uRWxlbWVudFNlbGVjdC5vbmx5V2l0aEF0dHJzKSYmZy5wdXNoKHtuYW1lOmIsdG9vbDphfSl9KSxcclxuLy8gc29ydCBtb3N0IHNwZWNpZmljIChtb3N0IGF0dHJzIHRvIGZpbmQpIGZpcnN0XHJcbmcuc29ydChmdW5jdGlvbihhLGIpe3JldHVybiBiLnRvb2wub25FbGVtZW50U2VsZWN0Lm9ubHlXaXRoQXR0cnMubGVuZ3RoLWEudG9vbC5vbkVsZW1lbnRTZWxlY3Qub25seVdpdGhBdHRycy5sZW5ndGh9KSk6YW5ndWxhci5mb3JFYWNoKGgsZnVuY3Rpb24oYSxiKXtnLnB1c2goe25hbWU6Yix0b29sOmF9KX0pLGcubGVuZ3RoPjApZm9yKHZhciBsPTA7bDxnLmxlbmd0aDtsKyspe2Zvcih2YXIgbT1nW2xdLnRvb2wsbj1nW2xdLm5hbWUsbz0wO288altjXS50b29sYmFyU2NvcGVzLmxlbmd0aDtvKyspaWYodm9pZCAwIT09altjXS50b29sYmFyU2NvcGVzW29dLnRvb2xzW25dKXttLm9uRWxlbWVudFNlbGVjdC5hY3Rpb24uY2FsbChqW2NdLnRvb2xiYXJTY29wZXNbb10udG9vbHNbbl0sYSxlLGQpLGk9ITA7YnJlYWt9aWYoaSlicmVha31yZXR1cm4gaX19fSxhbmd1bGFyLmZvckVhY2goZSxmdW5jdGlvbihhKXtpW2FdJiZqW2NdLnRvb2xiYXJTY29wZXMucHVzaChpW2FdKX0pLG8oKSxqW2NdLmVkaXRvckZ1bmN0aW9uc30sXHJcbi8vIHJldHJpZXZlIGVkaXRvciBieSBuYW1lLCBsYXJnZWx5IHVzZWQgYnkgdGVzdGluZyBzdWl0ZXMgb25seVxyXG5yZXRyaWV2ZUVkaXRvcjpmdW5jdGlvbihhKXtyZXR1cm4galthXX0sdW5yZWdpc3RlckVkaXRvcjpmdW5jdGlvbihhKXtkZWxldGUgalthXSxvKCl9LFxyXG4vLyByZWdpc3RlcnMgYSB0b29sYmFyIHN1Y2ggdGhhdCBpdCBjYW4gYmUgbGlua2VkIHRvIGVkaXRvcnNcclxucmVnaXN0ZXJUb29sYmFyOmZ1bmN0aW9uKGEpe2lmKCFhKXRocm93XCJ0ZXh0QW5ndWxhciBFcnJvcjogQSB0b29sYmFyIHJlcXVpcmVzIGEgc2NvcGVcIjtpZighYS5uYW1lfHxcIlwiPT09YS5uYW1lKXRocm93XCJ0ZXh0QW5ndWxhciBFcnJvcjogQSB0b29sYmFyIHJlcXVpcmVzIGEgbmFtZVwiO2lmKGlbYS5uYW1lXSl0aHJvdyd0ZXh0QW5ndWxhciBFcnJvcjogQSB0b29sYmFyIHdpdGggbmFtZSBcIicrYS5uYW1lKydcIiBhbHJlYWR5IGV4aXN0cyc7aVthLm5hbWVdPWEsXHJcbi8vIHdhbGsgYWxsIHRoZSBlZGl0b3JzIGFuZCBjb25uZWN0IHRoaXMgdG9vbGJhclNjb3BlIHRvIHRoZSBlZGl0b3JzLi4uLiBpZiB3ZSBuZWVkIHRvLiAgVGhpcyB3YXksIGl0IGRvZXNcclxuLy8gbm90IG1hdHRlciBpZiB3ZSByZWdpc3RlciB0aGUgZWRpdG9ycyBhZnRlciB0aGUgdG9vbGJhcnMgb3Igbm90XHJcbi8vIE5vdGUgdGhlIGVkaXRvciB3aWxsIGlnbm9yZSB0aGlzIHRvb2xiYXJTY29wZSBpZiBpdCBpcyBub3QgY29ubmVjdGVkIHRvIGl0Li4uXHJcbmFuZ3VsYXIuZm9yRWFjaChqLGZ1bmN0aW9uKGIpe2IuX3JlZ2lzdGVyVG9vbGJhclNjb3BlKGEpfSksbygpfSxcclxuLy8gcmV0cmlldmUgdG9vbGJhciBieSBuYW1lLCBsYXJnZWx5IHVzZWQgYnkgdGVzdGluZyBzdWl0ZXMgb25seVxyXG5yZXRyaWV2ZVRvb2xiYXI6ZnVuY3Rpb24oYSl7cmV0dXJuIGlbYV19LFxyXG4vLyByZXRyaWV2ZSB0b29sYmFycyBieSBlZGl0b3IgbmFtZSwgbGFyZ2VseSB1c2VkIGJ5IHRlc3Rpbmcgc3VpdGVzIG9ubHlcclxucmV0cmlldmVUb29sYmFyc1ZpYUVkaXRvcjpmdW5jdGlvbihhKXt2YXIgYj1bXSxjPXRoaXM7cmV0dXJuIGFuZ3VsYXIuZm9yRWFjaCh0aGlzLnJldHJpZXZlRWRpdG9yKGEpLnRvb2xiYXJzLGZ1bmN0aW9uKGEpe2IucHVzaChjLnJldHJpZXZlVG9vbGJhcihhKSl9KSxifSx1bnJlZ2lzdGVyVG9vbGJhcjpmdW5jdGlvbihhKXtkZWxldGUgaVthXSxvKCl9LFxyXG4vLyBmdW5jdGlvbnMgZm9yIHVwZGF0aW5nIHRoZSB0b29sYmFyIGJ1dHRvbnMgZGlzcGxheVxyXG51cGRhdGVUb29sc0Rpc3BsYXk6ZnVuY3Rpb24oYSl7XHJcbi8vIHBhc3MgYSBwYXJ0aWFsIHN0cnVjdCBvZiB0aGUgdGFUb29scywgdGhpcyBhbGxvd3MgdXMgdG8gdXBkYXRlIHRoZSB0b29scyBvbiB0aGUgZmx5LCB3aWxsIG5vdCBjaGFuZ2UgdGhlIGRlZmF1bHRzLlxyXG52YXIgYj10aGlzO2FuZ3VsYXIuZm9yRWFjaChhLGZ1bmN0aW9uKGEsYyl7Yi51cGRhdGVUb29sRGlzcGxheShjLGEpfSl9LFxyXG4vLyB0aGlzIGZ1bmN0aW9uIHJlc2V0cyBhbGwgdG9vbGJhcnMgdG8gdGhlaXIgZGVmYXVsdCB0b29sIGRlZmluaXRpb25zXHJcbnJlc2V0VG9vbHNEaXNwbGF5OmZ1bmN0aW9uKCl7dmFyIGE9dGhpczthbmd1bGFyLmZvckVhY2goYixmdW5jdGlvbihiLGMpe2EucmVzZXRUb29sRGlzcGxheShjKX0pLG8oKX0sXHJcbi8vIHVwZGF0ZSBhIHRvb2wgb24gYWxsIHRvb2xiYXJzXHJcbnVwZGF0ZVRvb2xEaXNwbGF5OmZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpczthbmd1bGFyLmZvckVhY2goaSxmdW5jdGlvbihkLGUpe2MudXBkYXRlVG9vbGJhclRvb2xEaXNwbGF5KGUsYSxiKX0pLG8oKX0sXHJcbi8vIHJlc2V0cyBhIHRvb2wgdG8gdGhlIGRlZmF1bHQvc3RhcnRpbmcgc3RhdGUgb24gYWxsIHRvb2xiYXJzXHJcbnJlc2V0VG9vbERpc3BsYXk6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpczthbmd1bGFyLmZvckVhY2goaSxmdW5jdGlvbihjLGQpe2IucmVzZXRUb29sYmFyVG9vbERpc3BsYXkoZCxhKX0pLG8oKX0sXHJcbi8vIHVwZGF0ZSBhIHRvb2wgb24gYSBzcGVjaWZpYyB0b29sYmFyXHJcbnVwZGF0ZVRvb2xiYXJUb29sRGlzcGxheTpmdW5jdGlvbihhLGIsYyl7aWYoIWlbYV0pdGhyb3cndGV4dEFuZ3VsYXIgRXJyb3I6IE5vIFRvb2xiYXIgd2l0aCBuYW1lIFwiJythKydcIiBleGlzdHMnO2lbYV0udXBkYXRlVG9vbERpc3BsYXkoYixjKX0sXHJcbi8vIHJlc2V0IGEgdG9vbCBvbiBhIHNwZWNpZmljIHRvb2xiYXIgdG8gaXQncyBkZWZhdWx0IHN0YXJ0aW5nIHZhbHVlXHJcbnJlc2V0VG9vbGJhclRvb2xEaXNwbGF5OmZ1bmN0aW9uKGEsYyl7aWYoIWlbYV0pdGhyb3cndGV4dEFuZ3VsYXIgRXJyb3I6IE5vIFRvb2xiYXIgd2l0aCBuYW1lIFwiJythKydcIiBleGlzdHMnO2lbYV0udXBkYXRlVG9vbERpc3BsYXkoYyxiW2NdLCEwKX0sXHJcbi8vIHJlbW92ZXMgYSB0b29sIGZyb20gYWxsIHRvb2xiYXJzIGFuZCBpdCdzIGRlZmluaXRpb25cclxucmVtb3ZlVG9vbDpmdW5jdGlvbihhKXtkZWxldGUgYlthXSxhbmd1bGFyLmZvckVhY2goaSxmdW5jdGlvbihiKXtkZWxldGUgYi50b29sc1thXTtmb3IodmFyIGM9MDtjPGIudG9vbGJhci5sZW5ndGg7YysrKXtmb3IodmFyIGQsZT0wO2U8Yi50b29sYmFyW2NdLmxlbmd0aDtlKyspe2lmKGIudG9vbGJhcltjXVtlXT09PWEpe2Q9e2dyb3VwOmMsaW5kZXg6ZX07YnJlYWt9aWYodm9pZCAwIT09ZClicmVha312b2lkIDAhPT1kJiYoYi50b29sYmFyW2QuZ3JvdXBdLnNsaWNlKGQuaW5kZXgsMSksYi5fJGVsZW1lbnQuY2hpbGRyZW4oKS5lcShkLmdyb3VwKS5jaGlsZHJlbigpLmVxKGQuaW5kZXgpLnJlbW92ZSgpKX19KSxvKCl9LFxyXG4vLyB0b29sa2V5LCB0b29sRGVmaW5pdGlvbiBhcmUgcmVxdWlyZWQuIElmIGdyb3VwIGlzIG5vdCBzcGVjaWZpZWQgd2lsbCBwaWNrIHRoZSBsYXN0IGdyb3VwLCBpZiBpbmRleCBpc250IGRlZmluZWQgd2lsbCBhcHBlbmQgdG8gZ3JvdXBcclxuYWRkVG9vbDpmdW5jdGlvbihhLGIsZCxlKXtjKGEsYiksYW5ndWxhci5mb3JFYWNoKGksZnVuY3Rpb24oYyl7Yy5hZGRUb29sKGEsYixkLGUpfSksbygpfSxcclxuLy8gYWRkcyBhIFRvb2wgYnV0IG9ubHkgdG8gb25lIHRvb2xiYXIgbm90IGFsbFxyXG5hZGRUb29sVG9Ub29sYmFyOmZ1bmN0aW9uKGEsYixkLGUsZil7YyhhLGIpLGlbZF0uYWRkVG9vbChhLGIsZSxmKSxvKCl9LFxyXG4vLyB0aGlzIGlzIHVzZWQgd2hlbiBleHRlcm5hbGx5IHRoZSBodG1sIG9mIGFuIGVkaXRvciBoYXMgYmVlbiBjaGFuZ2VkIGFuZCB0ZXh0QW5ndWxhciBuZWVkcyB0byBiZSBub3RpZmllZCB0byB1cGRhdGUgdGhlIG1vZGVsLlxyXG4vLyB0aGlzIHdpbGwgY2FsbCBhICRkaWdlc3QgaWYgbm90IGFscmVhZHkgaGFwcGVuaW5nXHJcbnJlZnJlc2hFZGl0b3I6ZnVuY3Rpb24oYSl7aWYoIWpbYV0pdGhyb3cndGV4dEFuZ3VsYXIgRXJyb3I6IE5vIEVkaXRvciB3aXRoIG5hbWUgXCInK2ErJ1wiIGV4aXN0cyc7althXS5zY29wZS51cGRhdGVUYUJpbmR0YVRleHRFbGVtZW50KCksLyogaXN0YW5idWwgaWdub3JlIGVsc2U6IHBoYXNlIGNhdGNoICovXHJcbmpbYV0uc2NvcGUuJCRwaGFzZXx8althXS5zY29wZS4kZGlnZXN0KCksbygpfSxcclxuLy8gdGhpcyBpcyB1c2VkIGJ5IHRhQmluZCB0byBzZW5kIGEga2V5IGNvbW1hbmQgaW4gcmVzcG9uc2UgdG8gYSBzcGVjaWFsIGtleSBldmVudFxyXG5zZW5kS2V5Q29tbWFuZDpmdW5jdGlvbihhLGIpe3ZhciBjPWpbYS5fbmFtZV07LyogaXN0YW5idWwgaWdub3JlIGVsc2U6IGlmIG5vdGhpbmcgdG8gZG8sIGRvIG5vdGhpbmcgKi9cclxuaWYoYyYmYy5lZGl0b3JGdW5jdGlvbnMuc2VuZEtleUNvbW1hbmQoYikpLyogaXN0YW5idWwgaWdub3JlIGVsc2U6IGRvbid0IHJ1biBpZiBhbHJlYWR5IHJ1bm5pbmcgKi9cclxucmV0dXJuIGEuX2JVcGRhdGVTZWxlY3RlZFN0eWxlc3x8YS51cGRhdGVTZWxlY3RlZFN0eWxlcygpLGIucHJldmVudERlZmF1bHQoKSwhMX0sXHJcbi8vXHJcbi8vIFdoZW4gYSB0b29sYmFyIGFuZCB0b29scyBhcmUgY3JlYXRlZCwgaXQgaXNuJ3QgdW50aWwgdGhlcmUgaXMgYSBrZXkgZXZlbnQgb3IgbW91c2UgZXZlbnRcclxuLy8gdGhhdCB0aGUgdXBkYXRlU2VsZWN0ZWRTdHlsZXMoKSBpcyBjYWxsZWQgYmVoaW5kIHRoZSBzY2VuZXMuXHJcbi8vIFRoaXMgZnVuY3Rpb24gZm9yY2VzIGFuIHVwZGF0ZSB0aHJvdWdoIHRoZSBleGlzdGluZyBlZGl0b3JzIHRvIGhlbHAgdGhlIGFwcGxpY2F0aW9uIG1ha2Ugc3VyZVxyXG4vLyB0aGUgaW5pdGFsIHN0YXRlIGlzIGNvcnJlY3QuXHJcbi8vXHJcbnVwZGF0ZVN0eWxlczpsLFxyXG4vLyByZXR1cm4gdGhlIGN1cnJlbnQgdmVyc2lvbiBvZiB0ZXh0QW5ndWxhciBpbiB1c2UgdG8gdGhlIHVzZXJcclxuZ2V0VmVyc2lvbjpmdW5jdGlvbigpe3JldHVybiBmfSxcclxuLy8gZm9yIHRlc3RpbmdcclxuZ2V0VG9vbGJhclNjb3BlczpmdW5jdGlvbigpe3ZhciBhPVtdO3JldHVybiBhbmd1bGFyLmZvckVhY2goaixmdW5jdGlvbihiKXthPWEuY29uY2F0KGIudG9vbGJhclNjb3Blcyl9KSxhfX19XSksdS5kaXJlY3RpdmUoXCJ0ZXh0QW5ndWxhclRvb2xiYXJcIixbXCIkY29tcGlsZVwiLFwidGV4dEFuZ3VsYXJNYW5hZ2VyXCIsXCJ0YU9wdGlvbnNcIixcInRhVG9vbHNcIixcInRhVG9vbEV4ZWN1dGVBY3Rpb25cIixcIiR3aW5kb3dcIixmdW5jdGlvbihhLGIsYyxkLGUsZil7cmV0dXJue3Njb3BlOntuYW1lOlwiQFwifSxyZXN0cmljdDpcIkVBXCIsbGluazpmdW5jdGlvbihnLGgsaSl7aWYoIWcubmFtZXx8XCJcIj09PWcubmFtZSl0aHJvd1widGV4dEFuZ3VsYXIgRXJyb3I6IEEgdG9vbGJhciByZXF1aXJlcyBhIG5hbWVcIjthbmd1bGFyLmV4dGVuZChnLGFuZ3VsYXIuY29weShjKSksaS50YVRvb2xiYXImJihnLnRvb2xiYXI9Zy4kcGFyZW50LiRldmFsKGkudGFUb29sYmFyKSksaS50YVRvb2xiYXJDbGFzcyYmKGcuY2xhc3Nlcy50b29sYmFyPWkudGFUb29sYmFyQ2xhc3MpLGkudGFUb29sYmFyR3JvdXBDbGFzcyYmKGcuY2xhc3Nlcy50b29sYmFyR3JvdXA9aS50YVRvb2xiYXJHcm91cENsYXNzKSxpLnRhVG9vbGJhckJ1dHRvbkNsYXNzJiYoZy5jbGFzc2VzLnRvb2xiYXJCdXR0b249aS50YVRvb2xiYXJCdXR0b25DbGFzcyksaS50YVRvb2xiYXJBY3RpdmVCdXR0b25DbGFzcyYmKGcuY2xhc3Nlcy50b29sYmFyQnV0dG9uQWN0aXZlPWkudGFUb29sYmFyQWN0aXZlQnV0dG9uQ2xhc3MpLGkudGFGb2N1c3NlZENsYXNzJiYoZy5jbGFzc2VzLmZvY3Vzc2VkPWkudGFGb2N1c3NlZENsYXNzKSxnLmRpc2FibGVkPSEwLGcuZm9jdXNzZWQ9ITEsZy5fJGVsZW1lbnQ9aCxoWzBdLmlubmVySFRNTD1cIlwiLGguYWRkQ2xhc3MoXCJ0YS10b29sYmFyIFwiK2cuY2xhc3Nlcy50b29sYmFyKSxnLiR3YXRjaChcImZvY3Vzc2VkXCIsZnVuY3Rpb24oKXtnLmZvY3Vzc2VkP2guYWRkQ2xhc3MoZy5jbGFzc2VzLmZvY3Vzc2VkKTpoLnJlbW92ZUNsYXNzKGcuY2xhc3Nlcy5mb2N1c3NlZCl9KTt2YXIgaj1mdW5jdGlvbihiLGMpe3ZhciBkO2lmKGQ9YiYmYi5kaXNwbGF5P2FuZ3VsYXIuZWxlbWVudChiLmRpc3BsYXkpOmFuZ3VsYXIuZWxlbWVudChcIjxidXR0b24gdHlwZT0nYnV0dG9uJz5cIiksYiYmYi5jbGFzcz9kLmFkZENsYXNzKGIuY2xhc3MpOmQuYWRkQ2xhc3MoZy5jbGFzc2VzLnRvb2xiYXJCdXR0b24pLGQuYXR0cihcIm5hbWVcIixjLm5hbWUpLFxyXG4vLyBpbXBvcnRhbnQgdG8gbm90IHRha2UgZm9jdXMgZnJvbSB0aGUgbWFpbiB0ZXh0L2h0bWwgZW50cnlcclxuZC5hdHRyKFwidGEtYnV0dG9uXCIsXCJ0YS1idXR0b25cIiksZC5hdHRyKFwibmctZGlzYWJsZWRcIixcImlzRGlzYWJsZWQoKVwiKSxkLmF0dHIoXCJ0YWJpbmRleFwiLFwiLTFcIiksZC5hdHRyKFwibmctY2xpY2tcIixcImV4ZWN1dGVBY3Rpb24oKVwiKSxkLmF0dHIoXCJuZy1jbGFzc1wiLFwiZGlzcGxheUFjdGl2ZVRvb2xDbGFzcyhhY3RpdmUpXCIpLGImJmIudG9vbHRpcHRleHQmJmQuYXR0cihcInRpdGxlXCIsYi50b29sdGlwdGV4dCksYiYmIWIuZGlzcGxheSYmIWMuX2Rpc3BsYXkmJihcclxuLy8gZmlyc3QgY2xlYXIgb3V0IHRoZSBjdXJyZW50IGNvbnRlbnRzIGlmIGFueVxyXG5kWzBdLmlubmVySFRNTD1cIlwiLFxyXG4vLyBhZGQgdGhlIGJ1dHRvblRleHRcclxuYi5idXR0b250ZXh0JiYoZFswXS5pbm5lckhUTUw9Yi5idXR0b250ZXh0KSxiLmljb25jbGFzcykpe3ZhciBlPWFuZ3VsYXIuZWxlbWVudChcIjxpPlwiKSxmPWRbMF0uaW5uZXJIVE1MO2UuYWRkQ2xhc3MoYi5pY29uY2xhc3MpLGRbMF0uaW5uZXJIVE1MPVwiXCIsZC5hcHBlbmQoZSksZiYmXCJcIiE9PWYmJmQuYXBwZW5kKFwiJm5ic3A7XCIrZil9cmV0dXJuIGMuX2xhc3RUb29sRGVmaW5pdGlvbj1hbmd1bGFyLmNvcHkoYiksYShkKShjKX07XHJcbi8vIEtlZXAgYSByZWZlcmVuY2UgZm9yIHVwZGF0aW5nIHRoZSBhY3RpdmUgc3RhdGVzIGxhdGVyXHJcbmcudG9vbHM9e30sXHJcbi8vIGNyZWF0ZSB0aGUgdG9vbHMgaW4gdGhlIHRvb2xiYXJcclxuLy8gZGVmYXVsdCBmdW5jdGlvbnMgYW5kIHZhbHVlcyB0byBwcmV2ZW50IGVycm9ycyBpbiB0ZXN0aW5nIGFuZCBvbiBpbml0XHJcbmcuX3BhcmVudD17ZGlzYWJsZWQ6ITAsc2hvd0h0bWw6ITEscXVlcnlGb3JtYXRCbG9ja1N0YXRlOmZ1bmN0aW9uKCl7cmV0dXJuITF9LHF1ZXJ5Q29tbWFuZFN0YXRlOmZ1bmN0aW9uKCl7cmV0dXJuITF9fTt2YXIgaz17JHdpbmRvdzpmLCRlZGl0b3I6ZnVuY3Rpb24oKXtcclxuLy8gZHluYW1pY2FsbHkgZ2V0cyB0aGUgZWRpdG9yIGFzIGl0IGlzIHNldFxyXG5yZXR1cm4gZy5fcGFyZW50fSxpc0Rpc2FibGVkOmZ1bmN0aW9uKCl7XHJcbi8vIHZpZXcgc2VsZWN0aW9uIGJ1dHRvbiBpcyBhbHdheXMgZW5hYmxlZCBzaW5jZSBpdCBkb2VzbiBub3QgZGVwZW5kIG9uIGEgc2VsY3Rpb24hXHJcbi8vIHZpZXcgc2VsZWN0aW9uIGJ1dHRvbiBpcyBhbHdheXMgZW5hYmxlZCBzaW5jZSBpdCBkb2VzbiBub3QgZGVwZW5kIG9uIGEgc2VsY3Rpb24hXHJcbi8vIHRoaXMgYnJhY2tldCBpcyBpbXBvcnRhbnQgYXMgd2l0aG91dCBpdCBpdCBqdXN0IHJldHVybnMgdGhlIGZpcnN0IGJyYWNrZXQgYW5kIGlnbm9yZXMgdGhlIHJlc3RcclxuLy8gd2hlbiB0aGUgYnV0dG9uJ3MgZGlzYWJsZWQgZnVuY3Rpb24vdmFsdWUgZXZhbHVhdGVzIHRvIHRydWVcclxuLy8gYWxsIGJ1dHRvbnMgZXhjZXB0IHRoZSBIVE1MIFN3aXRjaCBidXR0b24gc2hvdWxkIGJlIGRpc2FibGVkIGluIHRoZSBzaG93SHRtbCAoUkFXIGh0bWwpIG1vZGVcclxuLy8gaWYgdGhlIHRvb2xiYXIgaXMgZGlzYWJsZWRcclxuLy8gaWYgdGhlIGN1cnJlbnQgZWRpdG9yIGlzIGRpc2FibGVkXHJcbnJldHVybihcImh0bWxcIiE9PXRoaXMubmFtZXx8IWcuX3BhcmVudC5zdGFydEFjdGlvbikmJihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0aGlzLiRldmFsKFwiZGlzYWJsZWRcIikmJnRoaXMuJGV2YWwoXCJkaXNhYmxlZFwiKXx8dGhpcy4kZXZhbChcImRpc2FibGVkKClcIil8fFwiaHRtbFwiIT09dGhpcy5uYW1lJiZ0aGlzLiRlZGl0b3IoKS5zaG93SHRtbHx8dGhpcy4kcGFyZW50LmRpc2FibGVkfHx0aGlzLiRlZGl0b3IoKS5kaXNhYmxlZCl9LGRpc3BsYXlBY3RpdmVUb29sQ2xhc3M6ZnVuY3Rpb24oYSl7cmV0dXJuIGE/Zy5jbGFzc2VzLnRvb2xiYXJCdXR0b25BY3RpdmU6XCJcIn0sZXhlY3V0ZUFjdGlvbjplfTthbmd1bGFyLmZvckVhY2goZy50b29sYmFyLGZ1bmN0aW9uKGEpe1xyXG4vLyBzZXR1cCB0aGUgdG9vbGJhciBncm91cFxyXG52YXIgYj1hbmd1bGFyLmVsZW1lbnQoXCI8ZGl2PlwiKTtiLmFkZENsYXNzKGcuY2xhc3Nlcy50b29sYmFyR3JvdXApLGFuZ3VsYXIuZm9yRWFjaChhLGZ1bmN0aW9uKGEpe1xyXG4vLyBpbml0IGFuZCBhZGQgdGhlIHRvb2xzIHRvIHRoZSBncm91cFxyXG4vLyBhIHRvb2wgbmFtZSAoa2V5IG5hbWUgZnJvbSB0YVRvb2xzIHN0cnVjdClcclxuLy9jcmVhdGVzIGEgY2hpbGQgc2NvcGUgb2YgdGhlIG1haW4gYW5ndWxhclRleHQgc2NvcGUgYW5kIHRoZW4gZXh0ZW5kcyB0aGUgY2hpbGRTY29wZSB3aXRoIHRoZSBmdW5jdGlvbnMgb2YgdGhpcyBwYXJ0aWN1bGFyIHRvb2xcclxuLy8gcmVmZXJlbmNlIHRvIHRoZSBzY29wZSBhbmQgZWxlbWVudCBrZXB0XHJcbmcudG9vbHNbYV09YW5ndWxhci5leHRlbmQoZy4kbmV3KCEwKSxkW2FdLGsse25hbWU6YX0pLGcudG9vbHNbYV0uJGVsZW1lbnQ9aihkW2FdLGcudG9vbHNbYV0pLFxyXG4vLyBhcHBlbmQgdGhlIHRvb2wgY29tcGlsZWQgd2l0aCB0aGUgY2hpbGRTY29wZSB0byB0aGUgZ3JvdXAgZWxlbWVudFxyXG5iLmFwcGVuZChnLnRvb2xzW2FdLiRlbGVtZW50KX0pLFxyXG4vLyBhcHBlbmQgdGhlIGdyb3VwIHRvIHRoZSB0b29sYmFyXHJcbmguYXBwZW5kKGIpfSksXHJcbi8vIHVwZGF0ZSBhIHRvb2xcclxuLy8gaWYgYSB2YWx1ZSBpcyBzZXQgdG8gbnVsbCwgcmVtb3ZlIGZyb20gdGhlIGRpc3BsYXlcclxuLy8gd2hlbiBmb3JjZU5ldyBpcyBzZXQgdG8gdHJ1ZSBpdCB3aWxsIGlnbm9yZSBhbGwgcHJldmlvdXMgc2V0dGluZ3MsIHVzZWQgdG8gcmVzZXQgdG8gdGFUb29scyBkZWZpbml0aW9uXHJcbi8vIHRvIHJlc2V0IHRvIGRlZmF1bHRzIHBhc3MgaW4gdGFUb29sc1trZXldIGFzIF9uZXdUb29sIGFuZCBmb3JjZU5ldyBhcyB0cnVlLCBpZSBgdXBkYXRlVG9vbERpc3BsYXkoa2V5LCB0YVRvb2xzW2tleV0sIHRydWUpO2BcclxuZy51cGRhdGVUb29sRGlzcGxheT1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9Zy50b29sc1thXTtpZihkKXtpZihcclxuLy8gZ2V0IHRoZSBsYXN0IHRvb2xEZWZpbml0aW9uLCB0aGVuIG92ZXJyaWRlIHdpdGggdGhlIG5ldyBkZWZpbml0aW9uXHJcbmQuX2xhc3RUb29sRGVmaW5pdGlvbiYmIWMmJihiPWFuZ3VsYXIuZXh0ZW5kKHt9LGQuX2xhc3RUb29sRGVmaW5pdGlvbixiKSksbnVsbD09PWIuYnV0dG9udGV4dCYmbnVsbD09PWIuaWNvbmNsYXNzJiZudWxsPT09Yi5kaXNwbGF5KXRocm93J3RleHRBbmd1bGFyIEVycm9yOiBUb29sIERlZmluaXRpb24gZm9yIHVwZGF0aW5nIFwiJythKydcIiBkb2VzIG5vdCBoYXZlIGEgdmFsaWQgZGlzcGxheS9pY29uY2xhc3MvYnV0dG9udGV4dCB2YWx1ZSc7XHJcbi8vIGlmIHRvb2wgaXMgZGVmaW5lZCBvbiB0aGlzIHRvb2xiYXIsIHVwZGF0ZS9yZWRvIHRoZSB0b29sXHJcbm51bGw9PT1iLmJ1dHRvbnRleHQmJmRlbGV0ZSBiLmJ1dHRvbnRleHQsbnVsbD09PWIuaWNvbmNsYXNzJiZkZWxldGUgYi5pY29uY2xhc3MsbnVsbD09PWIuZGlzcGxheSYmZGVsZXRlIGIuZGlzcGxheTt2YXIgZT1qKGIsZCk7ZC4kZWxlbWVudC5yZXBsYWNlV2l0aChlKSxkLiRlbGVtZW50PWV9fSxcclxuLy8gd2UgYXNzdW1lIGhlcmUgdGhhdCBhbGwgdmFsdWVzIHBhc3NlZCBhcmUgdmFsaWQgYW5kIGNvcnJlY3RcclxuZy5hZGRUb29sPWZ1bmN0aW9uKGEsYixjLGUpe2cudG9vbHNbYV09YW5ndWxhci5leHRlbmQoZy4kbmV3KCEwKSxkW2FdLGsse25hbWU6YX0pLGcudG9vbHNbYV0uJGVsZW1lbnQ9aihkW2FdLGcudG9vbHNbYV0pO3ZhciBmO3ZvaWQgMD09PWMmJihjPWcudG9vbGJhci5sZW5ndGgtMSksZj1hbmd1bGFyLmVsZW1lbnQoaC5jaGlsZHJlbigpW2NdKSx2b2lkIDA9PT1lPyhmLmFwcGVuZChnLnRvb2xzW2FdLiRlbGVtZW50KSxnLnRvb2xiYXJbY11bZy50b29sYmFyW2NdLmxlbmd0aC0xXT1hKTooZi5jaGlsZHJlbigpLmVxKGUpLmFmdGVyKGcudG9vbHNbYV0uJGVsZW1lbnQpLGcudG9vbGJhcltjXVtlXT1hKX0sYi5yZWdpc3RlclRvb2xiYXIoZyksZy4kb24oXCIkZGVzdHJveVwiLGZ1bmN0aW9uKCl7Yi51bnJlZ2lzdGVyVG9vbGJhcihnLm5hbWUpfSl9fX1dKSx1LmRpcmVjdGl2ZShcInRleHRBbmd1bGFyVmVyc2lvblwiLFtcInRleHRBbmd1bGFyTWFuYWdlclwiLGZ1bmN0aW9uKGEpe3ZhciBiPWEuZ2V0VmVyc2lvbigpO3JldHVybntyZXN0cmljdDpcIkVBXCIsbGluazpmdW5jdGlvbihhLGMsZCl7Yy5odG1sKGIpfX19XSksdS5uYW1lfSk7Il0sImZpbGUiOiJ0ZXh0QW5ndWxhci5taW4uanMiLCJzb3VyY2VSb290IjoiL3NvdXJjZS8ifQ==
